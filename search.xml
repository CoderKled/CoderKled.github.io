<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM学习笔记</title>
      <link href="/2021/11/10/JVM/"/>
      <url>/2021/11/10/JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1.类文件结构"></a>1.类文件结构</h1><h2 id="1-Class文件结构"><a href="#1-Class文件结构" class="headerlink" title="1.Class文件结构"></a>1.Class文件结构</h2><p>*只有两种数据类型：无符号数，表</p><p>*前四个字节（一个字节放两个十六进制位）是魔数，判定该class是否能被虚拟机接受，0xCAFEBABE</p><p>*紧接着四个字节的前两个是次版本号，后两个是主版本号</p><h3 id="1-常量池"><a href="#1-常量池" class="headerlink" title="1.常量池"></a>1.常量池</h3><p>*从第九个字节开始是常量池，而第九个字节标记了常量池的大小。在class文件中，只有常量池的容量是从1开始计数，其余都是0开始。如第九个字节是0x16 -&gt; 22 -&gt; 即常量池有21项常量1~21</p><p>*每一项常量都是一个表</p><p><em>CONSTANT_Utf8_info型的常量的最大长度就是JAVA中方法或字段的最大长度。*<em>CONSTANT_Utf8_info中length是u2类型，所以如果JAVA程序中定义了超过65535，即64KB的字符变量或者方法名就无法编译</em></em></p><p>*查看字节码内容 javap -verbose</p><h3 id="2-访问标志"><a href="#2-访问标志" class="headerlink" title="2.访问标志"></a>2.访问标志</h3><p>*常量池结束后紧接着的2个字节代表访问标志，用于识别这个Class是接口？abstract？public？等等</p><h3 id="3-类索引，父类索引，接口索引集合"><a href="#3-类索引，父类索引，接口索引集合" class="headerlink" title="3.类索引，父类索引，接口索引集合"></a>3.类索引，父类索引，接口索引集合</h3><p>*因为JAVA中除了Object，都有父类，所以除了Object的JAVA类的父类索引都不为0</p><h1 id="2-类加载机制"><a href="#2-类加载机制" class="headerlink" title="2.类加载机制"></a>2.类加载机制</h1><h2 id="1-类加载时机"><a href="#1-类加载时机" class="headerlink" title="1.类加载时机"></a>1.类加载时机</h2><p>1.加载，验证，准备，初始化，卸载的顺序是固定的，而解析则不一定</p><p>2.六种情况必须立即对类进行初始化：</p><p>​    （1）遇到new,getstatic,putstatic, invokestatic四条指令时，而会生成这四条指令的典型场景有</p><p>​        1.用new实例化对象时<strong>（静态加载）</strong></p><p>​        <strong>2.除被final修饰的静态字段被读取或设置</strong></p><p>​        3.调用静态方法<strong>（静态加载）</strong></p><p>​    （2）对类型进行反射调用时<strong>（动态加载）</strong></p><p>​    <strong>（3）初始化类时，如果他的父类还没初始化，必须先初始化他的父类（接口的这一点和类不同，接口在初始化时，并不要求他的父接口全部完成初始化，只有真的用到父接口时（如引用了父接口内定义的常量）时才会初始化）</strong>  <strong>（属于静态加载）</strong></p><p>​    （4）JVM启动时，用户需指定一个要执行的主类（包含Main的那个类），JVM会对其初始化</p><p>​    （5）对一个MethodHandle实例解析结果为REF_newInvokeSpecial, REF_getStatic, REF_putStatic,  REF_invokeStatic时</p><p>​    （6）默认方法（被default修饰的接口方法）的实现类发生初始化时，必须先初始化这个接口</p><p>3.P264 265 266的被动引用例子，要作为JAVA笔记中代码块调用顺序的补充</p><p>​    （1）通过子类直接引用父类的静态字段，不会触发子类的初始化</p><p>​    （2）通过数组定义来所引用的类，不会触发此类的初始化</p><p>​    （3）与上面第二点呼应。常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，不会触发初始化</p><h2 id="2-类的加载过程"><a href="#2-类的加载过程" class="headerlink" title="2.类的加载过程"></a>2.类的加载过程</h2><p><strong>（验证+准备+解析属于连接过程）</strong></p><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p>1.完成三件事</p><p>（1）通过类名定义此类的二进制流</p><p>（2）将此字节流代表的的静态存储结构转化为方法区运行时数据结构</p><p>（3）在内存中生成代表此<strong>类的java.lang.Class对象</strong>作为方法区这个类的各种数据访问入口</p><p>2.加载尚未完成，链接可能就开始了。但是这俩的开始时间的先后顺序时固定的</p><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><p><img src="/images/image-20211110215400270.png" alt="image-20211110215400270"></p><p>1.如果不通过验证就会抛出java.lang.VerifyError或其子类异常</p><p>验证内容</p><p>1.文件格式验证（CAFEBABE等）</p><p>2.元数据验证（这个类是否有父类（除Object都有父类），有没有继承不允许被继承的类等）</p><p>3.字节码验证（确保程序语义是否合法，符合逻辑）</p><p>4.符号引用验证（确保解析正常）</p><h3 id="3-准备（针对静态）"><a href="#3-准备（针对静态）" class="headerlink" title="3.准备（针对静态）"></a>3.准备（针对静态）</h3><p>1.为静态变量分配内存并设置默认初始值</p><p><strong>注意，如果一个静态变量被final修饰就不适用了，因为final在编译的时候就已经分配了，所以在此阶段会直接给这个常量编译时赋的值而不是默认值了</strong></p><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><p>此阶段将符号引用转化为直接引用</p><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><p><strong>（准备是赋默认值，初始化是赋程序员给的值如num=2，准备只会让num=0）静态代码块，就是在这个时候被调用的（还有静态变量的显式赋值）</strong></p><p>1.初始化阶段就是执行类构造器<client>()的过程,他<strong>只操作静态变量，方法</strong>。因为它是编译器自动收集类中所有对静态变量赋值动作和静态代码块中的语句合并来的</p><p>2.<code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</p><p>理解：</p><p><img src="/images/image-20211110215414618.png" alt="image-20211110215414618"></p><p>这段代码number=20那里初始化不会报错的原因就是因为在准备阶段，静态的number已经被赋值为0了，所以即便是先执行静态代码块中的内容，程序也知道number是已经被声明过的。所以在初始化阶段，会那顺序来初始化，就把Number=0覆盖掉，变成20，然后再覆盖，变成10。 为什么后面会报错呢？因为这种形式的代码只能赋值，不能调用（这叫非法前向调用）</p><p>3.<clinit>()与类的构造器不同。在虚拟机的视角下，类的构造器是<init>()。父类的clinit是优先于自己的</p><p>4.<strong>虚拟机在加载类时只会调用一次clinit()，然后就把它放在方法区</strong>。对于多线程，如果有很多个线程要初始化一个类，<strong>只会有一个线程去执行这个类的clinit() （即执行静态代码块等等），其他线程都会被阻塞在外面直到clinit进行完毕。</strong></p><h2 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3.类加载器"></a>3.类加载器</h2><p>1.Java的核心类库例如String类库都是由引导加载器加载的，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sout(String.class.getClassLoader())</span><br></pre></td></tr></table></figure><p>输出null值，因为BootStrapClassLoader对象是拿不到的</p><p>对于用户自定义类来说使用的是系统类加载器加载即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sout(A.class.getClassLoader())</span><br></pre></td></tr></table></figure><p>输出的是一个AppClassLoader的对象信息</p><h4 id="1-启动类加载器"><a href="#1-启动类加载器" class="headerlink" title="1.启动类加载器"></a>1.启动类加载器</h4><p><strong>（引导类加载器BootStrapClassLoader）（C/C++写的）</strong></p><p>1.是JVM的一部分，用来加载JAVA的核心类库</p><p>2.没有父加载器<strong>（就他没继承ClassLoader）</strong></p><p>3.<strong>加载包名为java,javax,sun等开头的类</strong></p><h4 id="2-扩展类加载器"><a href="#2-扩展类加载器" class="headerlink" title="2.扩展类加载器"></a>2.扩展类加载器</h4><p>1.派生于ClassLoader</p><p>2**.加载jre/lib/ext中**的字节码文件，如果用户创建的JAR包放在了jre/lib/ext中，那么也会由扩展类加载器来加载</p><h4 id="3-系统类加载器AppClassLoader"><a href="#3-系统类加载器AppClassLoader" class="headerlink" title="3.系统类加载器AppClassLoader"></a>3.系统类加载器AppClassLoader</h4><p>1.是一个内部类</p><p>2.派生于ClassLoader</p><p>3.父类加载器是扩展类加载器</p><p><img src="/images/image-20211110215805077.png" alt="image-20211110215805077"></p><h4 id="4-用户自定义加载器"><a href="#4-用户自定义加载器" class="headerlink" title="4.用户自定义加载器"></a>4.用户自定义加载器</h4><p>后面会讲，使用情况</p><p>1.隔离加载类</p><p>2.修改类加载的方式</p><p>3.扩展加载源</p><p>4.防止源码泄露（因为JAVA可以反编译所以会泄露）</p><h4 id="5-关于ClassLoader"><a href="#5-关于ClassLoader" class="headerlink" title="5.关于ClassLoader"></a>5.关于ClassLoader</h4><p><strong>（凡是ClassLoader下的都是JAVA写的）</strong></p><p>1.是一个抽象类</p><p>2.除BootStraop都的类加载器都继承于他</p><p><img src="/images/image-20211110215814731.png" alt="image-20211110215814731"></p><h2 id="4-双亲委派机制"><a href="#4-双亲委派机制" class="headerlink" title="4.双亲委派机制"></a>4.双亲委派机制</h2><p>1.（跟类的加载比较像，自己是在父类加载完后才进行），如果一个类加载器收到了加载请求，不会自己先去加载而是向父类加载去委托，如果他的父类加载器还存在父类，就一直网上找到达顶层加载器。如果父类的那些加载器可以完成对该类的加载就成功返回，如果不行才会自己去加载<strong>（这就是为什么自己写一个java.lang.String类，然后在自己另一个类中去执行调用，调用不到的原因。因为首先被父类加载器判断是可以由父类加载的，就没自定义加载器什么事了）</strong>（如果顶层（bootstrap）发现这个类不该由我加载，就会给第二层（扩展类加载器）问他行不行，以此类推到子加载器（一般默认是系统加载器APPClassLoader，或者是用户自定义类加载器）发现由他管，就加载） <strong>（蛇形）</strong></p><p><img src="/images/image-20211110215823127.png" alt="image-20211110215823127"></p><h3 id="这就是沙箱安全机制"><a href="#这就是沙箱安全机制" class="headerlink" title="这就是沙箱安全机制"></a>这就是沙箱安全机制</h3><p><strong>一个好的例子（前面是在别的类中执行，现在这里是直接在自定义String类中运行）</strong></p><p><img src="/images/image-20211110215848022.png" alt="image-20211110215848022"></p><p>如果在自己定义的java.lang.String里加一个Main函数，会报错。因为此时就是想去执行对自己定义的String类的加载，由于是java开头的包，就会交由引导类加载器来加载。而引导类加载器要加载的核心类库是没有main方法的，所以报错<strong>（这里体现的就是沙箱安全机制）</strong></p><p>2.优势</p><p>避免重复加载</p><p>保护程序安全，防止核心API被篡改</p><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h2><p>1.判断两个Class是不是同一个</p><p>类的完整名（包括包名要一致）</p><p><strong>加载这个Class的ClassLoader要相同（这个就与双亲委派呼应起来了）</strong></p><p>2.JVM必须只要加载一个类是由引导类（启动类）加载器加载的还是用户类加载器加载的。如果是用户类加载器加载的话，JVM就会将这个类加载器的引用作为类型的信息的一部分放在方法区中<strong>（这就是为什么去获取BootStrapClassLoader的时候返回的是null，而其他调用是能看到类型的）</strong></p><p>3.<img src="/images/image-20211110215909818.png" alt="image-20211110215909818"></p><h1 id="3-运行时数据区"><a href="#3-运行时数据区" class="headerlink" title="3.运行时数据区"></a>3.运行时数据区</h1><p><strong>（重点是虚拟机栈，堆，方法区）</strong></p><p><img src="/images/image-20211110215921594.png" alt="image-20211110215921594"></p><p>红色区域（两个一组）是一个进程，一个虚拟机对应一组（一个虚拟机就会对应一个进程），灰色区域（三个一组）是一个线程对应一组</p><p>假设一个进程有五个线程，那么就会有五组灰色区域，5个线程共用一组红色区域</p><h2 id="1-运行时数据区及线程"><a href="#1-运行时数据区及线程" class="headerlink" title="1.运行时数据区及线程"></a>1.运行时数据区及线程</h2><p><img src="/images/image-20211110215932992.png" alt="image-20211110215932992"></p><p>类比一下也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品。</p><p>每个JVM只有一个Runtime实例</p><p>*<strong>运行时数据区内部图</strong></p><p><img src="/images/image-20211110215945958.png" alt="image-20211110215945958"></p><h3 id="2-程序计数器（PC寄存器）"><a href="#2-程序计数器（PC寄存器）" class="headerlink" title="2.程序计数器（PC寄存器）"></a>2.程序计数器（PC寄存器）</h3><p>1.用于存储下一条指令的地址</p><p>2.每个线程都有自己的程序计数器，是线程私有的，生命周期与线程一致</p><p>3.任何时间，线程都只有一个方法在运行</p><p><img src="/images/image-20211110215955929.png" alt="image-20211110215955929"></p><h4 id="两个常见的面试问题"><a href="#两个常见的面试问题" class="headerlink" title="*两个常见的面试问题"></a>*两个常见的面试问题</h4><p>1.</p><p><img src="/images/image-20211110220003405.png" alt="image-20211110220003405"></p><p>2.</p><p><img src="/images/image-20211110220017045.png" alt="image-20211110220017045"></p><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈*"></a>2.虚拟机栈*</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>优点：跨平台，指令集小</p><p>缺点：性能低（不是指速度慢）</p><p>*对于栈来说没有垃圾回收问题，因为栈只有入栈和出栈两种操作。但是会存在异常的情况</p><p><strong>==============面试题======================</strong></p><p><strong>开发中遇到的异常有哪些？</strong></p><p>首先，在JAVA虚拟机中，java栈的大小可以是动态也可以是静态</p><p>1.如果采用静态的，那么每个线程的java虚拟机栈容量在线程创建的时候就定好了。如果线程请求分配的容量大于原本的容量，就会抛出StackOverFlowError</p><p>2.如果采用动态的，（1）在尝试扩展的时候无法申请到足够内存，（2）或在创建新线程时没有足够内存区创建对应的虚拟机栈，就会抛出OutOfMemoryError</p><p><strong>================================================</strong></p><p>*栈是运行时的单位，堆是存储的单位</p><p>*<strong>每个线程都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应着一次次的JAVA方法调用</strong>。虚拟机栈是线程私有的</p><p>虚拟机栈的作用：</p><p>管程序运行，它保存方法的局部变量（8种基本数据类型，对象的<strong>引用地址</strong>（对象本身在堆中）），部分结果，并参与方法的调用和返回</p><h3 id="2-栈帧（栈的存储单位）"><a href="#2-栈帧（栈的存储单位）" class="headerlink" title="2.栈帧（栈的存储单位）"></a>2.栈帧（栈的存储单位）</h3><p>1.每个线程都有自己的栈，里面的数据的基本单位是栈帧</p><p>2.每个方法对应一个栈帧</p><p>3.一个时间点上只会有一个活动的栈帧</p><p>4.不同线程中的栈帧是不能相互引用的（很好理解，因为每个线程本来就是相对独立的，他们只是可以共享他们所在的那个进程的资源）</p><p>5.Java中有两种返回方式（1）正常的return（void函数其实在结束的时候也会return）（2）抛出异常（指的是未捕获的异常，抛给调用自己的方法）。 两种方式都将导致当前栈帧弹出</p><h4 id="1-栈帧的内部结构"><a href="#1-栈帧的内部结构" class="headerlink" title="1.栈帧的内部结构"></a>1.栈帧的内部结构</h4><p><img src="/images/image-20211110220040997.png" alt="image-20211110220040997"></p><h4 id="2-局部变量表"><a href="#2-局部变量表" class="headerlink" title="2.局部变量表*"></a>2.局部变量表*</h4><p>1.是一个数组，用于存储方法参数和在方法体内的局部变量（即各类基本数据类型，对象的引用，以及returnAddress类型）</p><p>2.由于是建立在线程的栈上，是线程的私有数据，所以不存在安全问题</p><p>3.所需要的容量大小在编译器就已经确定了，在运行期间不会更改</p><p><img src="/images/image-20211110220049940.png" alt="image-20211110220049940"></p><p><strong>注意一下成员变量和局部变量的区别</strong></p><p>*<strong>局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></p><h5 id="关于slot的理解"><a href="#关于slot的理解" class="headerlink" title="关于slot的理解"></a>关于slot的理解</h5><p>1.是局部变量表里最基本单元</p><p>2.用于存储基本数据类型，引用类型以及returnAddress类型</p><p><strong>3.32位数据占一个槽，64位的占两个（long，double）</strong></p><p>4.<strong>如果当前帧是由构造方法或者普通实例方法（即非静态的方法）创建的，那么对于这个对象的引用this就会放在index为0的slot处</strong>（每个方法或这个构造方法其实都隐含着this的）  <strong>（这也是为什么static方法中是不能用this的（因为this不存在于静态方法的局部变量表中））</strong></p><p><img src="/images/image-20211110220102629.png" alt="image-20211110220102629"></p><p>5.slot是可以重复利用的，当局部变量表里的变量被回收时（就比如</p><p><img src="/images/image-20211110220111037.png" alt="image-20211110220111037"></p><p>b会被回收，所以b的位子就被回收给c用了，所以这个局部变量表的长度是3而不是4</p><h4 id="1-操作数栈"><a href="#1-操作数栈" class="headerlink" title="1.操作数栈*"></a>1.操作数栈*</h4><p>1.主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</p><p>2.如果调用的方法有返回值，那么它结束后，返回值会被压入当前栈帧的<strong>操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令</p><p>=================<strong>操作过程</strong>==========================</p><p><img src="/images/image-20211110220119360.png" alt="image-20211110220119360"></p><p>要注意，局部变量表的0位置在图中没画出来，0位置就是这个类的this</p><p><img src="/images/image-20211110220128014.png" alt="image-20211110220128014"></p><p><img src="/images/image-20211110220136348.png" alt="image-20211110220136348"></p><p><img src="/images/image-20211110220145729.png" alt="image-20211110220145729"></p><p><img src="/images/image-20211110220153944.png" alt="image-20211110220153944"></p><p><strong>===================================================</strong></p><h4 id="2-帧数据区（一些附加信息，动态链接，方法返回地址）"><a href="#2-帧数据区（一些附加信息，动态链接，方法返回地址）" class="headerlink" title="2.帧数据区（一些附加信息，动态链接，方法返回地址）"></a>2.帧数据区（一些附加信息，动态链接，方法返回地址）</h4><h5 id="1-动态链接（指向运行时常量池的方法引用）"><a href="#1-动态链接（指向运行时常量池的方法引用）" class="headerlink" title="1.动态链接（指向运行时常量池的方法引用）"></a>1.动态链接（指向运行时常量池的方法引用）</h5><p>*在Java源文件被编译到字节码文件中后，所有变量和方法都会作为<strong>符号引用</strong>保存在class文件的常量池里</p><p>*描述一个方法（一个方法对应一个栈帧）调用另一个其他方法时，就是通过常量池中指向方法的符号引用来表示的。<strong>动态链接的作用就是把符号引用转化为直接引用</strong>（在类加载的解析阶段进行）（符转直其实就是看着符号标的位置去方法区找对应的方法）</p><p><img src="/images/image-20211110220206569.png" alt="image-20211110220206569"></p><p>//常量池中的符号引用</p><p><img src="/images/image-20211110220214214.png" alt="image-20211110220214214"></p><p>//代码中指向常量池的引用  ‘’#’’（也就是动态链接）</p><p><img src="/images/image-20211110220221206.png" alt="image-20211110220221206"></p><p>目前的结构图</p><p><img src="/images/image-20211110220229211.png" alt="image-20211110220229211"></p><h6 id="为什么需要常量池呢？"><a href="#为什么需要常量池呢？" class="headerlink" title="为什么需要常量池呢？"></a>为什么需要常量池呢？</h6><p>常量池提供一些符号和常量，便于指令识别。这样做也就不会让class文件因为装了太多方法和常量而变得很大，引用就好了。</p><h5 id="2-方法的调用"><a href="#2-方法的调用" class="headerlink" title="2.方法的调用**"></a>2.方法的调用**</h5><p>静态链接：当一个字节码文件被装载进JVM内部时，<strong>目标方法在编译期可知且运行期保持不变</strong>。这种情况的符号引用转直接引用叫静态链接</p><p>（早期绑定）</p><p>动态链接：<strong>被调方法在编译器无法被确定下来</strong>，只有在程序运行期才能将符号引用转化为直接引用，叫动态链接</p><p>（晚期绑定）</p><p>非虚方法：</p><p>编译器就确定了具体调用版本且在运行时不改变</p><p>静态，<strong>私有</strong>，final(用invokevirtue调但他不是虚方法)，实例构造器，<strong>父类方法</strong>都是非虚方法</p><p>其他的方法就都是虚的</p><p>非虚方法在编译时是非常确定会去哪里调哪个方法</p><p><img src="/images/image-20211110220240259.png" alt="image-20211110220240259"></p><p>lamda表达式就是用invokedynamic来调的，因为只有运行的时候才知道lamda表达式中的类型</p><p>JAVA是静态类型语言，Python是动态类型语言</p><p><img src="/images/image-20211110220248687.png" alt="image-20211110220248687"></p><p>静态和动态的区别在于，静态类型语言判断变量自身的类型信息，动态语言通过变量的值来判断类型（变量没有类型，而变量值有）</p><h6 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h6><p>*为了提高性能，不每次都在调用时向上找找找，于是JVM在方法区建立虚方法表（因为非虚方法都很确定在哪里调，所以不需要在这个表里）表中存放着各个方法的入口（就不需要向上向上找了）</p><p>*虚方法表何时创建？</p><p>在类加载链接阶段创建，当类准备阶段完成后，类的方法表也初始化完毕</p><p><strong>虚方法表示例</strong></p><p><img src="/images/image-20211110220302162.png" alt="image-20211110220302162"></p><h5 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h5><p>*存储该方法在pc寄存器（存储下一条要执行的指令的值）中的值</p><p>*无论目前的方法所调用的那个方法是正常退出还是出现未处理异常而非正常退出，都会返回到被调用的位置。</p><p><strong>方法的退出本质就是当前栈帧出栈的过程</strong></p><p>正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法指令的下一条指令的地址</strong></p><p>异常退出时，返回地址通过异常表确定，栈帧一般不会保存这部分信息</p><p><strong>这也是为什么异常退出不会给调用者返回任何值</strong></p><h5 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h5><p>栈帧允许携带与JVM实现相关的一些附加信息，不能保证每个栈帧都有</p><h3 id="3-虚拟机栈的相关面试题"><a href="#3-虚拟机栈的相关面试题" class="headerlink" title="3.虚拟机栈的相关面试题**"></a>3.虚拟机栈的相关面试题**</h3><p><strong>1.举例栈溢出的情况</strong></p><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM（OutOfMemoryError）</p><p>（可通过-Xss来设置栈的大小）</p><p><strong>2.调整栈大小，就能保证不出现溢出吗</strong></p><p>可以视情况做到，但是不能保证</p><p>死循环的话不管栈有多大都会溢出（栈小很快溢出，栈大慢点溢出罢了）</p><p><strong>3.分配的栈内存越大越好吗？</strong></p><p>理论上越大，能降低出现SOF的概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p><p><strong>4.垃圾回收是否会涉及到虚拟机栈</strong></p><p>不会</p><p><img src="/images/image-20211110220318887.png" alt="image-20211110220318887"></p><p><img src="/images/image-20211110220326382.png" alt="image-20211110220326382"></p><p><strong>5.方法中定义的局部变量是否线程安全</strong></p><p><a href="https://youthlql.gitee.io/post/5b1b6560.html">https://youthlql.gitee.io/post/5b1b6560.html</a></p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p><img src="/images/image-20211110220344355.png" alt="image-20211110220344355"></p><p>用来装native修饰的本地方法</p><p><img src="/images/image-20211110220353140.png" alt="image-20211110220353140"></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆*"></a>堆*</h2><p>*每一个JVM实例（也就是每一个进程）都对应一个堆内存</p><p>*可处于物理上不连续的空间中，但是逻辑上是连续的</p><p>*<strong>线程共享堆，但不是绝对的共享。里面也可以划分线程线程私有的缓冲区</strong>TLAB</p><p>*所有的对象实例（几乎所有）（注意是实例，引用在虚拟机栈里）和数组，都在堆里</p><p>*</p><p><img src="/images/image-20211110220400965.png" alt="image-20211110220400965"></p><p>*设置堆空间大小（年轻代+老年代，不包括元空间）</p><p><img src="/images/image-20211110220411446.png" alt="image-20211110220411446"></p><p>ms: memory start</p><h1 id="没分章节的内容"><a href="#没分章节的内容" class="headerlink" title="*没分章节的内容"></a>*没分章节的内容</h1><h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><p><strong>为什么要用本地方法？</strong></p><p>1.C , C++盛行，需要交互</p><p>2.要与操作系统交互，因为操作系统是C/C++写的，所以需要本地方法</p><p>3.Sun的解释器是C实现的</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.jsp学习笔记</title>
      <link href="/2021/11/10/jsp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/10/jsp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>是java的服务器页面</p><p>主要作用是代替Servlet程序回传Html页面的数据</p><p>（Servlet程序回传html页面数据的开发成本和维护成本都高）</p><h1 id="1-jsp的访问方式"><a href="#1-jsp的访问方式" class="headerlink" title="1.jsp的访问方式"></a>1.jsp的访问方式</h1><p><img src="/images/image-20211112145133829.png" alt="image-20211112145133829"></p><h1 id="2-jsp的本质"><a href="#2-jsp的本质" class="headerlink" title="2.jsp的本质"></a>2.jsp的本质</h1><p>*<strong>jsp页面本质上是servlet程序</strong></p><p>第一次访问jsp页面时，Tomcat服务器回把jsp翻译成为一个java源文件并将它编译，生成.class的字节码文件。而打开该java文件后看到的类直接继承了HttpJspBase类</p><p>HttpJspBase类继承了HttpServlet</p><p>被翻译出来的java源文件实际上也是通过HttpServletResponse的输出流回传html页面数据</p><p><img src="/images/image-20211112145148165.png" alt="image-20211112145148165"></p><h1 id="3-jsp语法"><a href="#3-jsp语法" class="headerlink" title="3.jsp语法"></a>3.jsp语法</h1><h2 id="1-头部page指令及属性"><a href="#1-头部page指令及属性" class="headerlink" title="1.头部page指令及属性"></a>1.头部page指令及属性</h2><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211112145200115.png" alt="image-20211112145200115"></p><p>关于第ii点，可以通过查看.java源文件得到证明</p><p><img src="/images/image-20211112145224101.png" alt="image-20211112145224101"></p><p>当把autoFlash设定为false并把buffer属性改小，若此时jsp页面的数据过多就会报如上的缓冲区溢出错误。所以，没事不要去改autoFlash和buffer属性。</p><p><img src="/images/image-20211112145237297.png" alt="image-20211112145237297"></p><p><strong>关于erropage的路径一定要注意</strong>。前面提到过，浏览器和服务器对于斜杠/的解析结果时不一样的。而jsp本质是servlet程序，所以erropage里若要写斜杠/打头，他标识的是hrrp://localhost:8080/工程路径/。<strong>这个路径的映射到IDEA代码的webapp目录下</strong></p><p><img src="/images/image-20211112145243412.png" alt="image-20211112145243412"></p><p>这三项一般都不会去改，就让他默认就好了</p><h2 id="2-jsp脚本"><a href="#2-jsp脚本" class="headerlink" title="2.jsp脚本"></a>2.jsp脚本</h2><h3 id="a-声明脚本（用的少）"><a href="#a-声明脚本（用的少）" class="headerlink" title="a.声明脚本（用的少）"></a>a.声明脚本（用的少）</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! 声明java代码 %&gt;</span><br></pre></td></tr></table></figure><p>作用：给jsp翻译出来的Java类定义属性和方法，甚至是静态代码块，内部类等等</p><p>他是放在<strong>jsp名_jsp类</strong>中的</p><p>例如：<img src="/images/image-20211112145258063.png" alt="image-20211112145258063"></p><p>在.java文件中可以查看到</p><p><img src="/images/image-20211112145308565.png" alt="image-20211112145308565"></p><h3 id="b-表达式脚本（较常用）"><a href="#b-表达式脚本（较常用）" class="headerlink" title="b.表达式脚本（较常用）"></a>b.表达式脚本（较常用）</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= 表达式 %&gt;</span><br></pre></td></tr></table></figure><p>作用：在jsp页面上输出数据。其输出方式本质上（即在.java文件 中是以out.print()来输出的）</p><p>就比如上例的map </p><p>如果在jsp上写&lt;%=map%&gt;，调用界面时显示的不是map这三个字母而是System.out.println(map)的结果。</p><p>概括起来就是，表达式脚本里可以写对象</p><p><strong>表达式脚本的特点</strong></p><p>1.所有表达式脚本都会被翻译到jsp对应的.java文件中的_jspService()方法中</p><p>2.都会作为out.write()的参数输出到页面上</p><p>3.由于所有表达式脚本都会被翻译到_jspService()中，所以__jspService()方法中的对象都可以直接使用</p><p>4.表达式脚本的末尾不能加分号;</p><p><strong>如何理解第三点？</strong></p><p>即便在jsp代码没有定义HttpServletRequest request，但是依然可以在jsp中写</p><p><img src="/images/image-20211112145319993.png" alt="image-20211112145319993"></p><p>然后在浏览器上用?加上参数，就可以在jsp页面上显示参数中username的值</p><p><strong>第四点的原因？</strong></p><p>表达式脚本的内容最终是一整个放到out.print()中，如果我在表达式参数中因为习惯加了一个;例如</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= map; %&gt;</span><br></pre></td></tr></table></figure><p>那他实际上就是out.print(map;)，妥妥的语法错误</p><h3 id="c-代码脚本"><a href="#c-代码脚本" class="headerlink" title="c.代码脚本"></a>c.代码脚本</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%  正常的java语句 %</span><br></pre></td></tr></table></figure><p>作用：可以在Jsp中编写需要的功能。</p><p>*代码脚本中的内容就是纯天然的不加别的东西地放在_jspService()里，它并不像表达式脚本一样，翻译后的内容是由out.print()包起来的</p><p>*能写的例如有if语句，for循环</p><p>*要注意如果是写方法啥的要用声明脚本</p><p>*虽然很明显，但是还是要区分以下，因为表达式脚本是放在out.print()中输出的，out是作为response存在的，所以他输出的内容是显示在浏览器页面中的。但是在代码脚本中，习惯性还是写的System.out.println()，所以输出的内容是在控制台并非页面上</p><p>*和表达式脚本相似，因为大家都是被翻译后放到_jspService()中，所以_jspService()方法中传进来的参数，定义过的变量啥的都能直接用</p><p><strong>代码脚本特点：</strong></p><p>1.被翻译后都放在_jspService()中</p><p>2.由1，_jspService()中的现有对象都可以直接使用</p><p>3.代码脚本可以由多个代码脚本块组合完成一个完整的java语句</p><p>4.代码脚本和表达式脚本组合使用可以将结果往页面上输入</p><p><strong>第三点举例</strong></p><p><img src="/images/image-20211112145333627.png" alt="image-20211112145333627"></p><p>两个残缺的代码块可以放进去组成一句完整的代码</p><p><strong>第四点举例</strong></p><p><img src="/images/image-20211112145342356.png" alt="image-20211112145342356"></p><p>这就把0~10输出到了页面上，而不是控制台。</p><p>由此衍生出做表格的妙用，不需要像之前一样复制好几行<tr></p><p><img src="/images/image-20211112145357205.png" alt="image-20211112145357205"></p><p><img src="/images/image-20211112145405461.png" alt="image-20211112145405461"></p><h2 id="3-jsp注释"><a href="#3-jsp注释" class="headerlink" title="3.jsp注释"></a>3.jsp注释</h2><p>在jsp中可以写三种注释</p><p>1.html注释<!--注释 --></p><p>会被翻译到java源代码中在_jspService()方法中，以out.write()输出</p><p>2.java注释/*   */  //</p><p>会被翻译到java源代码中</p><p>3.jsp注释&lt;%– –%&gt;</p><p>可以注释掉jsp页面中所有代码包括以上两个</p><h2 id="4-jsp九大内置对象"><a href="#4-jsp九大内置对象" class="headerlink" title="4.jsp九大内置对象"></a>4.jsp九大内置对象</h2><p>指Tomcat在翻译jsp页面成为Servlet源码后，内部提供的九大对象</p><p><img src="/images/image-20211112145418768.png" alt="image-20211112145418768"></p><p>其中，exception对象需要在头部page指令中将isErrorPage的值设定为true，才会出现。</p><h2 id="5-jsp四大域对象"><a href="#5-jsp四大域对象" class="headerlink" title="5.jsp四大域对象"></a>5.jsp四大域对象</h2><p>在以上内置对象中，有四个是域对象</p><p><img src="/images/image-20211112145426300.png" alt="image-20211112145426300"></p><h2 id="6-out输出和response-getWriter输出的区别"><a href="#6-out输出和response-getWriter输出的区别" class="headerlink" title="6.out输出和response.getWriter输出的区别"></a>6.out输出和response.getWriter输出的区别</h2><p><img src="/images/image-20211112145524558.png" alt="image-20211112145524558"></p><p>由此可以得到，如果代码是</p><p><img src="/images/image-20211112145533771.png" alt="image-20211112145533771"></p><p>out1会先加到response缓冲区，然后out2放到out缓冲区，然后两个response紧接着放在out1之后，最后由于jsp所有代码执行完毕，out.flush又执行一次，out2由out缓冲区加载到response缓冲区末尾。最终结果就是</p><p><img src="/images/image-20211112145541344.png" alt="image-20211112145541344"></p><p>由于jsp翻译后，底层源码都是用out来输出，所以一般统一使用out来输出避免打乱页面输出内容顺序</p><h2 id="7-out的print和write方法区别"><a href="#7-out的print和write方法区别" class="headerlink" title="7.out的print和write方法区别"></a>7.out的print和write方法区别</h2><p><strong>先说结论：在jsp页面中可以统一使用out.print()进行输出</strong></p><p>由实验结果表明</p><p>out.write和out.print输出字符串类型数据都没有任何问题</p><p>对于print，通过源码看看到</p><p><img src="/images/image-20211112145553199.png" alt="image-20211112145553199"></p><p>输出任意数据都没问题，因为底层，print都将数据转化成字符串然后调用write进行输出</p><p>而为什么write输出其他类型的数据就会出问题，根据源码</p><p><img src="/images/image-20211112145600912.png" alt="image-20211112145600912"></p><p>向write传递的参数会被强转为char存储在输出的缓冲数组中，<strong>而用char强转就是他只能输出字符串的关键所在</strong>，用char强转所得到的是参数c所对应的ascii码字符，就与原值相悖了</p><h2 id="8-jsp常用标签"><a href="#8-jsp常用标签" class="headerlink" title="8.jsp常用标签"></a>8.jsp常用标签</h2><p>随着Java EE技术的革新，现在对jsp的使用已经多了，jsp的作用基本只剩下输出数据，jsp中不会包含多复杂的代码，所以一搬用静态包含就够了（当然知识还是都要学）</p><h3 id="a-静态包含"><a href="#a-静态包含" class="headerlink" title="a.静态包含"></a>a.静态包含</h3><p><img src="/images/image-20211112145608932.png" alt="image-20211112145608932"></p><p>依然是要注意这个斜杠/。（但是好像不加斜杠，默认是帮忙加了，因为不加斜杠的初始路径也是webapp）</p><p><img src="/images/image-20211112145616884.png" alt="image-20211112145616884"></p><p><img src="/images/image-20211112145626428.png" alt="image-20211112145626428"></p><p>可以看到，静态包含的特点</p><p>1.静态包含不会翻译被包含的jsp页面</p><p>2.静态包含是把被包含地jsp页面代码拷贝到包含的位置，用write包起来进行输出</p><h3 id="b-动态包含"><a href="#b-动态包含" class="headerlink" title="b.动态包含"></a>b.动态包含</h3><p><img src="/images/image-20211112145640288.png" alt="image-20211112145640288"></p><p>动态包含也可以和静态包含一样把被包含的内容输出到包含的位置</p><p>不过</p><p><strong>动态包含特点：</strong></p><p>1.动态包含会把被包含的jsp页面翻译出来成为.java</p><p><img src="/images/image-20211112145653981.png" alt="image-20211112145653981"></p><p>2.在使用包含的那个jsp（这里把他称为也理解为<strong>main.jsp</strong>）被翻译出来的.java文件中，被包含的jsp文件不同于静态包含，静态包含是直接拷贝过去用write包起来，而动态包含是使用代码去调用被包含的jsp页面（即<strong>footer2.jsp</strong>）</p><p><img src="/images/image-20211112145701596.png" alt="image-20211112145701596"></p><p>3.动态包含还可以传递参数</p><p><img src="/images/image-20211112145711363.png" alt="image-20211112145711363"></p><p><img src="/images/image-20211112145719800.png" alt="image-20211112145719800"></p><p><img src="/images/image-20211112145728262.png" alt="image-20211112145728262"></p><p><strong>第二第三点的底层原理</strong></p><p><img src="/images/image-20211112145736660.png" alt="image-20211112145736660"></p><p>可以通过看第二点中的图，看出，main.jsp是把自己的response和request内置对象传给footer2.jsp。即footer2的内置对象是对main的内置对象的引用。所以他俩的request和response都指向的是同一个out缓冲区。所以当main的out.write()执行后（注意图上的write写错了），开始调用footer2的out.write()。等代码全部结束后，out缓冲区自行进行flush操作，最终就得到了显示的正常结果。（个人觉得很像在一个方法里调用另一个方法，当主方法调用子方法时是把子方法压栈，然后主方法等到子方法执行完后才恢复执行，最终统一flush）</p><h3 id="c-请求转发"><a href="#c-请求转发" class="headerlink" title="c.请求转发"></a>c.请求转发</h3><p><img src="/images/image-20211112145752046.png" alt="image-20211112145752046"></p><p>都是请求转发，这两句代码没啥区别（两个路径按理说都应在前面加上/，但是不加也没问题，默认是从webapp开始的）</p><p><img src="/images/image-20211112145809067.png" alt="image-20211112145809067"></p><p>在提示中，加了/是可以往java文件夹里索引的，但是通过实验，同时就单单通过这个IDEA提示也可以看到，不加/也能索引到</p><h1 id="4-Listener监听器"><a href="#4-Listener监听器" class="headerlink" title="4.Listener监听器"></a>4.Listener监听器</h1><p>1.是Java EE的规范，是一个接口</p><p>2.作用是，监听某种事务的变化。然后通过回调函数，回馈给客户（程序）去做响应处理</p><p>随着技术变革，很多监听器都不用了，唯独</p><h2 id="1-ServletContextListener"><a href="#1-ServletContextListener" class="headerlink" title="1.ServletContextListener"></a>1.ServletContextListener</h2><p>*ServletContextListener可以监听ServletContext对象的创建和销毁</p><p>*由前面所学可知，ServletContext对象随着web工程的创建而创建，web工程停止时销毁</p><p>*该监听器监听到创建和销毁后都会调用其方法反馈，分别是</p><p><img src="/images/image-20211112145828040.png" alt="image-20211112145828040"></p><p>使用步骤：</p><p>1.编写类实现ServletContextListener接口</p><p>2.实现以上两个回调方法</p><p>3.到web.xml中配置监听器</p><p><img src="/images/image-20211112144229478.png" alt="image-20211112144229478"></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JavaWeb </tag>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈反射</title>
      <link href="/2021/11/10/%E6%B5%85%E8%B0%88%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/11/10/%E6%B5%85%E8%B0%88%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h1><h2 id="1-动态语言-amp-静态语言"><a href="#1-动态语言-amp-静态语言" class="headerlink" title="1.动态语言&amp;静态语言"></a>1.动态语言&amp;静态语言</h2><p>从声明变量方式看动态与静态语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String author = <span class="string">&quot;CoderKled&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dream <span class="operator">=</span> <span class="string">&quot;Tencet&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distance = <span class="string">&quot;far&quot;</span></span><br></pre></td></tr></table></figure><p>可以看出动态语言与静态语言的区别之一在于：</p><p>静态语言判断变量自身的类型信息需要靠声明</p><p>动态语言的变量的类型信息则是根据其值来判断</p><p>Java不是动态语言，但是可以被称为是“准动态”，其原因在于Java具有一定的动态性，它是由反射机制等所赋予的。</p><h2 id="2-反射功能"><a href="#2-反射功能" class="headerlink" title="2.反射功能"></a>2.反射功能</h2><ul><li><strong>在运行时</strong>分析类的能力（如判断对象所属类，获取类的所有成员变量与方法信息等）</li><li>在运行时检查对象（例如，编写一个适用于所有类的toString方法）</li><li>实现泛型数组操作代码</li><li>利用Method对象</li><li>生成动态代理</li></ul><p>*反射可以在不通过修改源码的情况下控制程序</p><p>*在反射中，方法也是对象，可以用方法对象来调用方法</p><h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。就像一面镜子，透过它就能看到该对象所属类的信息。</p><p>Java运行时系统始终会为所有对象维护一个<strong>运行时类型标识</strong>，这个信息会跟踪每个对象所属的类。虚拟机利用运行时类型信息选择要执行的方法。</p><p>笔者理解为，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><p>a对象的编译类型是Animal，运行类型是Cat，该运行类型标识会一直伴随a对象的整个生命周期</p><h2 id="1-获取Class对象"><a href="#1-获取Class对象" class="headerlink" title="1.获取Class对象"></a>1.获取Class对象</h2><ul><li>方式一：getClass()  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Coder kled = <span class="keyword">new</span> Coder();</span><br><span class="line">Class c = kled.getClass();</span><br></pre></td></tr></table></figure><p>此处呼应前文所讲，系统维护的是一个运行时类型标识，所以getClass得到的是运行类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line">System.out.println(cat.getClass());</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211110210804735.png" alt="image-20211110210804735"></p><ul><li>方式二：静态方法forName()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;Coder&quot;</span>;</span><br><span class="line">Class c = Class.forName(name);</span><br></pre></td></tr></table></figure><ul><li>方式三：类型.class（可以是基本数据类型或void关键字）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = <span class="keyword">int</span>.class;</span><br><span class="line">Class c2 = String.class;</span><br><span class="line">Class c3 = Double[].class;</span><br></pre></td></tr></table></figure><ul><li>方式四：ClassLoader</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = ReflectionTest.class.getClassLoader();<span class="comment">//ReflectionTest是本类类名</span></span><br><span class="line">Class c = classLoader.loadClass(<span class="string">&quot;Coder&quot;</span>);</span><br></pre></td></tr></table></figure><p>由于虚拟机只为每个类型管理<strong>唯一一个</strong>Class对象，所以是可以用==来对两个Class进行对比的。</p><h2 id="2-突击复习instanceof"><a href="#2-突击复习instanceof" class="headerlink" title="2.突击复习instanceof"></a>2.突击复习instanceof</h2><p>判断对象是否是这个特定类或者是它的子类的一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(cat.getClass() == Cat.class);</span><br><span class="line">System.out.println(cat.getClass() == Animal.class);</span><br><span class="line">System.out.println(cat <span class="keyword">instanceof</span>  Animal);</span><br><span class="line">System.out.println(cat <span class="keyword">instanceof</span>  Cat);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211110210732793.png" alt="image-20211110210732793"></p><h2 id="3-getConstructor"><a href="#3-getConstructor" class="headerlink" title="3.getConstructor()"></a>3.getConstructor()</h2><p>若有一个Class类型的对象，可以通过getConstructor()来获取他的构造器对象，但是要根据以下代码注意区分</p><p><img src="/images/image-20211110212258605.png" alt="image-20211110212258605"></p><p><img src="/images/image-20211110212309805.png" alt="image-20211110212309805"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 反射 </tag>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
