<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/02/25/RabbitMQ/"/>
      <url>/2022/02/25/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="1-RabbitMQ组件"><a href="#1-RabbitMQ组件" class="headerlink" title="1. RabbitMQ组件"></a>1. RabbitMQ组件</h1><p><img src="/images/image-20220225121517916.png" alt="image-20220225121517916"></p><ul><li><strong>Broker</strong>：消息队列服务器实体  </li><li><strong>Virtual Host</strong>：虚拟主机  <ul><li>标识一批交换机、消息队列和相关对象，形成的整体  </li><li>虚拟主机是共享相同的身份认证和加密环境的独立服务器域  </li><li>每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制  </li><li>vhost是AMQP概念的基础，<strong>RabbitMQ默认的vhost是 /<strong>，</strong>必须在链接时指定</strong>  </li></ul></li><li><strong>Exchange</strong>：交换器（路由）  <ul><li>用来接收生产者发送的消息并将这些消息路由给服务器中的队列</li></ul></li><li><strong>Queue</strong>：消息队列     （可以直接理解成一个List用来保存消息）<ul><li>用来保存消息直到发送给消费者  </li><li>它是消息的容器，也是消息的终点</li><li>一个消息可投入一个或多个队列  </li><li>消息一直在队列里面，等待消费者连接到这个队列将其取走  </li></ul></li><li><strong>Banding</strong>：绑定，用于消息队列和交换机之间的关联  </li><li><strong>Channel</strong>：通道  <ul><li>多路复用连接中的一条独立的双向数据流通道  </li><li>信道是建立在真实的TCP连接内的<strong>虚拟链接</strong>  </li><li>AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，都是通过信道完成的</li><li>  因为对于操作系统来说，建立和销毁TCP连接都是非常昂贵的开销，所以引入了信道的概念，用来复用TCP连接  </li></ul></li><li><strong>Publisher</strong>：消息的生产者，也是一个向交换器发布消息的客户端应用程序  </li><li><strong>Consumer</strong>：消息的消费者，表示一个从消息队列中取得消息的客户端应用程序  </li></ul><h1 id="2-使用RabbitMQ"><a href="#2-使用RabbitMQ" class="headerlink" title="2. 使用RabbitMQ"></a>2. 使用RabbitMQ</h1><h2 id="1-启动"><a href="#1-启动" class="headerlink" title="1. 启动"></a>1. 启动</h2><ul><li>启动后台管理插件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]# rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><ul><li>启动/关闭/状态/重启命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]# systemctl start rabbitmq-server.service</span><br><span class="line">[root@localhost opt]# systemctl status rabbitmq-server.service</span><br><span class="line">[root@localhost opt]# systemctl restart rabbitmq-server.service</span><br><span class="line">[root@localhost opt]# systemctl stop rabbitmq-server.service</span><br></pre></td></tr></table></figure><ul><li>查看RabbitMQ进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]# ps -ef | grep rabbitmq</span><br></pre></td></tr></table></figure><ul><li><p>RabbitMQ管理界面的端口  ：15672  </p><p>RabbitMQ提供给编程语言客户端链接的端口 ：5672</p><p>RabbitMQ集群的端口 ：25672  </p></li></ul><p>由于guest用户默认不允许远程连接，所以创建自己的账号</p><ul><li>创建账号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]# rabbitmqctl add_user kled 123456</span><br></pre></td></tr></table></figure><ul><li>设置用户角色</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]# rabbitmqctl set_user_tags kled administrator</span><br></pre></td></tr></table></figure><ul><li>设置用户权限（满权限）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]# rabbitmqctl set_permissions -p &quot;/&quot; laosun &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><ul><li>（可以修改密码）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]# rabbitmqctl change_password kled 123123</span><br></pre></td></tr></table></figure><h2 id="2-入门"><a href="#2-入门" class="headerlink" title="2. 入门"></a>2. 入门</h2><ul><li>编写获取连接的方法类并测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂（工厂模式）</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//2.在工厂对象中设置MQ的连接信息（ip,port,bhost,username,password）</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);<span class="comment">//RabbitMQ提供给编程语言客户端链接的端口</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.10.100&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;kled&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/rabbit_start&quot;</span>);<span class="comment">//自己在rabbitMQ的客户端上创建了这个虚拟机</span></span><br><span class="line">        <span class="comment">//3.通过工厂获得与MQ的连接</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="3-RabbitMQ模式"><a href="#3-RabbitMQ模式" class="headerlink" title="3. RabbitMQ模式"></a>3. RabbitMQ模式</h1><p>其实就是前面RabbitMQ组件的不同调用组合</p><p><img src="/images/image-20220225151957812.png" alt="image-20220225151957812"></p><ul><li><p>除开RPC的五种消息模型大体分为两类</p><ul><li>1（简单模式）和2（工作队列模式）属于点对点</li><li>3（发布订阅模式）,4（路由模式）,5（通配符模式）属于发布订阅模式（一对多）</li></ul></li><li><p><strong>点对点模式：</strong>包含三个角色   <strong>（类比速递易）</strong>   性能一般</p><ul><li>消息队列（queue），发送者（sender），接收者（receiver）  </li><li>每个消息发送到一个特定的队列中，接收者从中获得消息  </li><li>队列中保留这些消息，直到他们被消费或超时   </li><li>特点：  <ul><li><ol><li>每个消息只有一个消费者<strong>（每个快递只有一个收件人）</strong>，一旦消费，消息就不在队列中了  </li><li>发送者和接收者之间没有依赖性，发送者发送完成，不管接收者是否运行，都不会影响消息发送到队列中<strong>（我给你发快递，不管你收不收，反正我发完了）</strong>  </li><li>  接收者成功接收消息之后需向对象应答成功<strong>（确认收货）</strong>  </li></ol></li></ul></li><li>如果希望发送的每个消息都会被成功处理，那需要P2P  </li></ul></li><li><p><strong>发布订阅模式</strong>：publish（Pub）/subscribe（Sub）       <strong>（类比抖音观众与博主）</strong></p><ul><li>包含三个角色：交换机（exchange），发布者（publisher），订阅者（subcriber）  </li><li>多个发布者将消息发送交换机，系统将这些消息传递给多个订阅者  </li><li>特点：  <ul><li><ol><li>每个消息可以有多个订阅者  </li><li>发布者和订阅者之间在时间上有依赖，对于某个交换机的订阅者，必须创建一个订阅后，才能消费发布者的消息    <strong>（必须关注才有推送）</strong></li><li>为了消费消息，订阅者必须保持运行状态；<strong>（抖音没开就没法收到抖音的消息推送）</strong></li></ol></li></ul></li><li>如果希望发送的消息被多个消费者处理，可采用本模式  </li></ul></li></ul><h2 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h2><ul><li><p>官方文档译文：</p><p>RabbitMQ是一个消息代理:它接收和转发消息。你可以把它想象成一个邮局:当你把你想要寄的邮件放到一个邮箱里，你可以确定邮递员先生或女士最终会把邮件送到你的收件人那里。在这个类比中，RabbitMQ是一个邮箱、一个邮局和一个邮递员。  </p></li><li><p>RabbitMQ本身只是接收，存储和转发消息，并不会对信息进行处理！<br>类似邮局，处理信件的应该是收件人而不是邮局</p></li></ul><p><img src="/images/image-20220225153750050.png" alt="image-20220225153750050"></p><ul><li>发送者（生产者）P</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;hello, rabbitMQ&quot;</span>;</span><br><span class="line">        <span class="comment">//1.获得连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//2.在连接中创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3.创建消息队列</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数1：队列名称</span></span><br><span class="line"><span class="comment">        参数2：队列中的数据是否持久化</span></span><br><span class="line"><span class="comment">        参数3：是否排外（是否支持扩展，排外就是：当前队列只能自己用别人不能用）</span></span><br><span class="line"><span class="comment">        参数4：是否自动删除（当队列连接数为0时，队列会自己销毁，不关队列是否还保存数据）</span></span><br><span class="line"><span class="comment">        参数5：队列参数（没有参数为null）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;queue1&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//4.向指定的队列发送消息</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数1：交换机名称，当前是简单模式也就是P2P模式，所以没交换机，所以名称是&quot;&quot;</span></span><br><span class="line"><span class="comment">        参数2：目标队列的名称</span></span><br><span class="line"><span class="comment">        basicProperties:消息的属性（没有属性则为空）</span></span><br><span class="line"><span class="comment">        参数4 bytes[]  :消息的内容(只能是字节数组)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;queue1&quot;</span>,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;已发送：&quot;</span> +msg);</span><br><span class="line">        <span class="comment">//5.释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>只运行发送者后，消息就被推送到通道里了，通过RabbitMQ的客户端就能看到有一个准备好的消息已经在消息队列里了</p><p><img src="/images/image-20220225162334292.png" alt="image-20220225162334292"></p><ul><li>接收者（消费者）C</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//1.获得连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//2.获得通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//3.从通道中获取消息</span></span><br><span class="line">        DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">//交付处理</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            consumerTag：收件人信息</span></span><br><span class="line"><span class="comment">            envelope: 标签</span></span><br><span class="line"><span class="comment">            properties: 协议的配置</span></span><br><span class="line"><span class="comment">            body（是一个字节数组）: 从队列中获取的消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String s = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接受的消息：&quot;</span> + s);</span><br><span class="line">                <span class="comment">//可以进行手动ACK确认（只有下面那个basicConsume传false的时候才手动）</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                envelope.getDeliveryTag()：收件人信息</span></span><br><span class="line"><span class="comment">                参数2：是否同时确认多个消息</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//手动确认前后都可以加很多业务逻辑（if...才确认）</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//4.监听队列（获取了消息并不是要马上退出，有可能还有消息呢）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：监听队列的名字</span></span><br><span class="line"><span class="comment">            参数2：是否自动消息确认</span></span><br><span class="line"><span class="comment">            参数3：谁监听</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;queue1&quot;</span>,<span class="keyword">false</span>,defaultConsumer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而后运行接收者（消费者），就能收到发送者发的消息</p><p><img src="/images/image-20220225162453378.png" alt="image-20220225162453378"></p><p>同时，消息队列里的消息被接受到了，也就没有了</p><p><img src="/images/image-20220225162514755.png" alt="image-20220225162514755"></p><h2 id="消息确认机制ACK"><a href="#消息确认机制ACK" class="headerlink" title="消息确认机制ACK"></a>消息确认机制ACK</h2><ul><li><strong>自动ACK</strong>：消息接收后，消费者立刻自动发送ACK（快递放在快递柜）  </li><li><strong>手动ACK</strong>：消息接收后，不会发送ACK，需要手动调用（快递必须本人签收）  </li></ul><p>如果消息非常重要，最好消费完成手动ACK，如果自动ACK消费后，<strong>RabbitMQ就会把消息从队列中删除</strong>，如果此时消费者抛异常宕机，那么消息就永久丢失了  </p><h2 id="工作队列模式"><a href="#工作队列模式" class="headerlink" title="工作队列模式"></a>工作队列模式</h2><p><img src="/images/image-20220225165618504.png" alt="image-20220225165618504"></p><p>简单模式，一个消费者来处理消息，如果生产者生产消息过快过多，而消费者的能力有限，就会产生消息在队列中堆积（生活中的滞销）  </p><p>当运行许多消费者程序时，消息队列中的任务会被众多消费者共享，但其中某一个消息只会被一个消费者获取（100支肉串20个人吃，但是其中的某支肉串只能被一个人吃）  </p><ul><li>发送者（生产者）P    模拟生产非常多的情景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">       Channel channel = connection.createChannel();</span><br><span class="line">       <span class="comment">// 声明队列（此处为生产者，创建队列）注明出餐口位置，通知大家来排队</span></span><br><span class="line">       channel.queueDeclare(<span class="string">&quot;test_work_queue&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">//模拟供多求少（滞销）</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">           String msg = <span class="string">&quot;羊肉串 --&gt; &quot;</span>+i ;</span><br><span class="line">           channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;test_work_queue&quot;</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">           System.out.println(<span class="string">&quot;师傅烤好：&quot;</span> + msg);</span><br><span class="line">       &#125;</span><br><span class="line">       channel.close();</span><br><span class="line">       connection.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>接收者（消费者）C *2    模拟两个消费者，代码都一样，只是消费完一个消息后的停顿一个是0.2秒一个是0.9秒</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//统计吃掉羊肉串的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.获得连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//2.获得通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//也可以在接收方声明队列：有两个作用，如果队列不存在，则创建，如果队列存在，则获取‘</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_work_queue&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//3.从通道中获取消息</span></span><br><span class="line">        DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">//交付处理</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            consumerTag：收件人信息</span></span><br><span class="line"><span class="comment">            envelope: 标签</span></span><br><span class="line"><span class="comment">            properties: 协议的配置</span></span><br><span class="line"><span class="comment">            body（是一个字节数组）: 从队列中获取的消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String s = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;[顾客2]吃掉了：&quot;</span> + s + <span class="string">&quot;！ 总共吃掉了[&quot;</span> + i++ + <span class="string">&quot;]串~&quot;</span>);</span><br><span class="line">                <span class="comment">//消费掉一串后模拟一下休息（网络延迟）</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">900</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//可以进行手动ACK确认（只有下面那个basicConsume传false的时候才手动）</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                envelope.getDeliveryTag()：收件人信息</span></span><br><span class="line"><span class="comment">                参数2：是否同时确认多个消息</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//4.监听队列（获取了消息并不是要马上退出，有可能还有消息呢）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：监听队列的名字</span></span><br><span class="line"><span class="comment">            参数2：是否自动消息确认</span></span><br><span class="line"><span class="comment">            参数3：谁监听</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_work_queue&quot;</span>, <span class="keyword">false</span>, defaultConsumer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220225171939216.png" alt="image-20220225171939216"></p><p><img src="/images/image-20220225171950543.png" alt="image-20220225171950543"></p><p>可以看到，虽然两者消费的速度不一样（一个停顿0.2秒一个停顿0.9秒），但是并不会因为Receiver1消费的快（间隔0.2秒）他就能比Receiver2消费得更多，两者都消费同样的数量</p><ul><li>但是这样并不好，1号速度快就应该让他多消费，而不是消费完一半就停顿下来了。所以官方文档给出了解决思路：<strong>（就是要实现能者多劳）</strong></li></ul><p><img src="/images/image-20220225172324209.png" alt="image-20220225172324209"></p><p><strong>（prefetch在下面的消费端限流就用到了）</strong></p><p>公平的分配<br>您可能已经注意到分派仍然不能完全按照我们的要求工作。例如，如果有两个员工，当所有<br>奇怪的消息都很重，甚至消息都很轻时，一个员工会一直很忙，而另一个人几乎什么工作都<br>不做。好吧，RabbitMQ对此一无所知，它仍然会均匀地分派消息。<br>这是因为RabbitMQ只在消息进入队列时发送消息。<strong>它不查看用户未确认消息的数量。它</strong><br><strong>只是盲目地将每条第n个消息分派给第n个消费者。</strong><br>为了克服这个问题，我们可以使用设置为prefetchCount = 1的basicQos方法。这告诉<br>RabbitMQ一次不要给一个worker发送一条以上的消息。或者，换句话说，<strong>在worker处理并</strong><br><strong>确认前一个消息之前，不要向它发送新消息</strong>。相反，它将把它分派到下一个不繁忙的<br>worker。  </p><p>解决代码：在 channel.queueDeclare下方加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示不要给一个接收者发1个以上的信息（不要堆积消息），这样就能达到消费一个，向队列确认后再发一个（从而解决1号工作完了一半，剩下的消息全堆给2号）</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//这种方式必须是手动ACK确认才行</span></span><br></pre></td></tr></table></figure><p><img src="/images/image-20220225174615428.png" alt="image-20220225174615428"></p><p><img src="/images/image-20220225174625485.png" alt="image-20220225174625485"></p><p>从而实现了两台消费者都一直工作而不出现工作完了就空闲下来的情况（能者多劳而不是平均分配）</p><p>这种效果必须配合手动ACK机制才会生效</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><strong>如何避免消息堆积？</strong></p><p>使用workqueue模式，多个消费者监听同一个队列</p><p>接收到消息后通过线程池异步消费（其实就是上面所做的操作）</p><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p>官方文档：</p><p>发布-订阅<br>在上一篇教程中，我们创建了一个工作队列。工作队列背后的假设是，每个任务都被准确地交<br>付给一个工作者。在这一部分中，我们将做一些完全不同的事情——将消息传递给多个消费者。<br>此模式称为“发布/订阅”。<br>为了演示这个模式，我们将构建一个简单的日志记录系统。它将由两个程序组成——第一个将<br>发送日志消息，第二个将接收和打印它们。<br>在我们的日志系统中，接收程序的每一个正在运行的副本都将获得消息。这样我们就可以运行<br>一个<strong>接收器</strong>并将日志指向磁盘;与此同时，我们可以运行另一个接收器并在屏幕上看到日志。<br>基本上，发布的日志<strong>消息将广播到所有接收方</strong>。  </p><p>可以直接理解为：抖音，众多粉丝关注一个博主，博主发视频，所有粉丝都看得到视频的通知</p><p><img src="/images/image-20220225215551761.png" alt="image-20220225215551761"><img src="/images/image-20220225215559922.png" alt="image-20220225215559922"></p><p>图中，X就是视频主，红色的队列就是粉丝。binding是绑定的意思（关注）  </p><p>P生产者发送信息给X路由，X将信息转发给绑定X的队列，X队列将信息通过信道发送给消费者，从而进行消费    </p><ul><li>整个过程，<strong>必须先创建路由</strong>  <ul><li><strong>路由在生产者程序中创建</strong>  </li><li><strong>因为路由没有存储消息的能力，当生产者将信息发送给路由后，消费者还没有运行，所以没有队列，路由并不知道将信息发送给谁</strong>  </li><li><strong>运行程序的顺序</strong>：  <ol><li><strong>MessageSender</strong>  （因为只有运行发送者才会创建路由）</li><li>MessageReceiver1和MessageReceiver2  </li><li>MessageSender  </li></ol></li></ul></li></ul><ul><li>生产者P（与简单模式和工作队列模式不同，这里多了一个路由的声明哦）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明路由(exchange)</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数1：路由名</span></span><br><span class="line"><span class="comment">        参数2：路由类型</span></span><br><span class="line"><span class="comment">        类型有：direct,fanout,headers,topic</span></span><br><span class="line"><span class="comment">        // fanout: 不处理路由键（只需要将队列绑定到路由上，发送到路由的消息就都会被转发到与该路由绑定的所有队列）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;test_exchange_fanout&quot;</span>,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">// 发布订阅模式不声明队列（并不知道谁会订阅我）</span></span><br><span class="line">        <span class="comment">//channel.queueDeclare(&quot;test_work_queue&quot;, false, false, false, null);</span></span><br><span class="line">        String msg = <span class="string">&quot;hello, everyone~&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="comment">/*\</span></span><br><span class="line"><span class="comment">        参数1：路由名</span></span><br><span class="line"><span class="comment">        参数2：队列名 （因为是发布订阅模式，在发送者创建时并不知道谁会订阅，所以不写队列名）</span></span><br><span class="line"><span class="comment">        basicProperties:消息的属性（没有属性则为空）</span></span><br><span class="line"><span class="comment">        参数4 bytes[]  :消息的内容(只能是字节数组)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;test_exchange_fanout&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;生产者：&quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是先执行发送者，就可以观察到后台检测到了这个路由</p><p><img src="/images/image-20220225225907146.png" alt="image-20220225225907146"></p><ul><li>接收者（消费者）P   *2  （写两个消费者，不同的地方只在于一个队列是1一个队列是2）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_exchange_fanout_queue_2&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定路由（bind,关注）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数1：队列名称</span></span><br><span class="line"><span class="comment">        参数2：路由名</span></span><br><span class="line"><span class="comment">        参数3</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_exchange_fanout_queue_2&quot;</span>,<span class="string">&quot;test_exchange_fanout&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//3.从通道中获取消息</span></span><br><span class="line">        DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">//交付处理</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            consumerTag：收件人信息</span></span><br><span class="line"><span class="comment">            envelope: 标签</span></span><br><span class="line"><span class="comment">            properties: 协议的配置</span></span><br><span class="line"><span class="comment">            body（是一个字节数组）: 从队列中获取的消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String s = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;【2号消费者】接受的消息：&quot;</span> + s);</span><br><span class="line">                <span class="comment">//可以进行手动ACK确认（只有下面那个basicConsume传false的时候才手动）</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                envelope.getDeliveryTag()：收件人信息</span></span><br><span class="line"><span class="comment">                参数2：是否同时确认多个消息</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//4.监听队列（获取了消息并不是要马上退出，有可能还有消息呢）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：监听队列的名字</span></span><br><span class="line"><span class="comment">            参数2：是否自动消息确认</span></span><br><span class="line"><span class="comment">            参数3：谁监听</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_exchange_fanout_queue_2&quot;</span>,<span class="keyword">false</span>,defaultConsumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而后运行两个消费者程序，后台也看到了他们声明的队列</p><p><img src="/images/image-20220225230144009.png" alt="image-20220225230144009"></p><p>然后根据前面说到的顺序，再运行发送者</p><p><img src="/images/image-20220225230757580.png" alt="image-20220225230757580"><img src="/images/image-20220225230815403.png" alt="image-20220225230815403"></p><p>于是两个消费者就能收到订阅消息</p><h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><p><img src="/images/image-20220226135202625.png" alt="image-20220226135202625"></p><p>这里交换机的类型就是direct了，前面发布订阅模式用的是fanout类型</p><ul><li>路由会根据类型进行<strong>定向分发</strong>消息给不同的队列（orange类的给队列1，black,green类的消息交给队列2处理）（完全可以理解为快递的分拣）</li></ul><p><strong>运行程序的顺序</strong>：  </p><ol><li><strong>MessageSender</strong>  （因为只有运行发送者才会创建路由）</li><li>MessageReceiver1和MessageReceiver2  进行队列绑定</li><li>MessageSender  </li></ol><ul><li>发送者（生产者）P</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明路由(exchange)</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数1：路由名</span></span><br><span class="line"><span class="comment">        参数2：路由类型</span></span><br><span class="line"><span class="comment">        类型有：direct,fanout,headers,topic</span></span><br><span class="line"><span class="comment">        // direct :根据路由键定向分发消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;test_exchange_direct&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">&quot;用户注册，userId = S101&quot;</span>;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="comment">/*\</span></span><br><span class="line"><span class="comment">        参数1：路由名</span></span><br><span class="line"><span class="comment">        参数2：队列名 （这里的队列名其实就是路由键了）</span></span><br><span class="line"><span class="comment">        basicProperties:消息的属性（没有属性则为空）</span></span><br><span class="line"><span class="comment">        参数4 bytes[]  :消息的内容(只能是字节数组)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;test_exchange_direct&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;[用户系统]：&quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先运行发送者，于是他创建的路由就能被观察到</p><p><img src="/images/image-20220226140628850.png" alt="image-20220226140628850"></p><ul><li>接收者（消费者）C  *2   （2号消费者没有Insert路由键而1号设置了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_exchange_direct_queue_2&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定路由（如果路由键的类型是insert,update,delete就绑定到test_exchange_direct_queue_2上）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数1：队列名称</span></span><br><span class="line"><span class="comment">        参数2：路由名</span></span><br><span class="line"><span class="comment">        参数3: 让这个队列处理哪些消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_exchange_direct_queue_2&quot;</span>,<span class="string">&quot;test_exchange_direct&quot;</span>,<span class="string">&quot;select&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_exchange_direct_queue_2&quot;</span>,<span class="string">&quot;test_exchange_direct&quot;</span>,<span class="string">&quot;update&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_exchange_direct_queue_2&quot;</span>,<span class="string">&quot;test_exchange_direct&quot;</span>,<span class="string">&quot;delete&quot;</span>);</span><br><span class="line">        <span class="comment">//3.从通道中获取消息</span></span><br><span class="line">        DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">//交付处理</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            consumerTag：收件人信息</span></span><br><span class="line"><span class="comment">            envelope: 标签</span></span><br><span class="line"><span class="comment">            properties: 协议的配置</span></span><br><span class="line"><span class="comment">            body（是一个字节数组）: 从队列中获取的消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String s = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;【1号消费者】接受的消息：&quot;</span> + s);</span><br><span class="line">                <span class="comment">//可以进行手动ACK确认（只有下面那个basicConsume传false的时候才手动）</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                envelope.getDeliveryTag()：收件人信息</span></span><br><span class="line"><span class="comment">                参数2：是否同时确认多个消息</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//4.监听队列（获取了消息并不是要马上退出，有可能还有消息呢）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：监听队列的名字</span></span><br><span class="line"><span class="comment">            参数2：是否自动消息确认</span></span><br><span class="line"><span class="comment">            参数3：谁监听</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_exchange_direct_queue_2&quot;</span>,<span class="keyword">false</span>,defaultConsumer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行接收者，再运行生产者，结果是：1号消费者收到了信息，2号消费者没有。这也就印证了路由模式的<strong>定向分发</strong>，因为在生产者那里只对insert路由键进行了绑定</p><p><img src="/images/image-20220226141107277.png" alt="image-20220226141107277"><img src="/images/image-20220226141114844.png" alt="image-20220226141114844"></p><h2 id="通配符模式"><a href="#通配符模式" class="headerlink" title="通配符模式"></a>通配符模式</h2><p><img src="/images/image-20220226141351627.png" alt="image-20220226141351627"></p><p>和路由模式基本一样，区别就在于通配符模式支持模糊匹配，然后路由的类型变为了topic</p><ul><li>*：能匹配一个词（类似Mysql的_，但是这里是词不是字符）  （但是正好要是一个词，多一个少一个都不行）</li><li>#:  匹配0或多个词 (类似Mysql的%，但是这里是词不是字符)</li></ul><p>官网案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">quick.orange.rabbit # Q1 Q2</span><br><span class="line">lazy.orange.elephant # Q1 Q2</span><br><span class="line">quick.orange.fox # Q1</span><br><span class="line">lazy.brown.fox # Q2</span><br><span class="line">lazy.pink.rabbit # Q2</span><br><span class="line">quick.brown.fox # 无</span><br><span class="line">orange # 无                   正好要是一个词，多一个少一个都不行</span><br><span class="line">quick.orange.male.rabbit # 无       正好要是一个词，多一个少一个都不行</span><br></pre></td></tr></table></figure><ul><li>生产者与消费者代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明路由(exchange)</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数1：路由名</span></span><br><span class="line"><span class="comment">        参数2：路由类型</span></span><br><span class="line"><span class="comment">        类型有：direct,fanout,headers,topic</span></span><br><span class="line"><span class="comment">        // direct :根据路由键定向分发消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;test_exchange_topic&quot;</span>,<span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">&quot;用户注册~~~~~~&quot;</span>;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="comment">/*\</span></span><br><span class="line"><span class="comment">        参数1：路由名</span></span><br><span class="line"><span class="comment">        参数2：队列名 （这里的队列名其实就是路由键了）</span></span><br><span class="line"><span class="comment">        basicProperties:消息的属性（没有属性则为空）</span></span><br><span class="line"><span class="comment">        参数4 bytes[]  :消息的内容(只能是字节数组)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;test_exchange_topic&quot;</span>, <span class="string">&quot;user.register&quot;</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;[用户系统]：&quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_exchange_direct_topic_1&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定路由（bind,关注）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数1：队列名称</span></span><br><span class="line"><span class="comment">        参数2：路由名</span></span><br><span class="line"><span class="comment">        参数3: 让这个队列处理哪些消息(对应路由键)这里采用模糊匹配</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//Receiver2用的是user.#</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_exchange_direct_topic_1&quot;</span>,<span class="string">&quot;test_exchange_topic&quot;</span>,<span class="string">&quot;user.*&quot;</span>);</span><br><span class="line">        <span class="comment">//3.从通道中获取消息</span></span><br><span class="line">        DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">//交付处理</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            consumerTag：收件人信息</span></span><br><span class="line"><span class="comment">            envelope: 标签</span></span><br><span class="line"><span class="comment">            properties: 协议的配置</span></span><br><span class="line"><span class="comment">            body（是一个字节数组）: 从队列中获取的消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String s = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;【1号消费者】接受的消息：&quot;</span> + s);</span><br><span class="line">                <span class="comment">//可以进行手动ACK确认（只有下面那个basicConsume传false的时候才手动）</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                envelope.getDeliveryTag()：收件人信息</span></span><br><span class="line"><span class="comment">                参数2：是否同时确认多个消息</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//4.监听队列（获取了消息并不是要马上退出，有可能还有消息呢）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：监听队列的名字</span></span><br><span class="line"><span class="comment">            参数2：是否自动消息确认</span></span><br><span class="line"><span class="comment">            参数3：谁监听</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_exchange_direct_topic_1&quot;</span>,<span class="keyword">false</span>,defaultConsumer);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是.*一个是.#，而生产者那边绑定的就是user.register，所以两个消费者都能接收到消息</p><h1 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4. 持久化"></a>4. 持久化</h1><ul><li>消息的可靠性是RabbitMQ的一大特色，那么RabbitMQ是如何避免消息丢失？<ul><li>消费者的ACK确认机制，可以防止消费者丢失消息</li></ul></li></ul><p>但是万一在消费者消费之前，RabbitMQ服务器宕机了，那消息也会丢失</p><ul><li>想要将消息持久化，那么 路由和队列都要持久化 才可以</li></ul><p>实现持久化的代码只需要多加参数</p><ul><li><strong>生产者代码（实现路由的持久化）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面对路由的声明都只是两个参数，这里多加一个true</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;test_exchange_durable&quot;</span>,<span class="string">&quot;topic&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//在发布消息的时候给basicProperties赋值持久化</span></span><br><span class="line"><span class="comment">/*\</span></span><br><span class="line"><span class="comment">        参数1：路由名</span></span><br><span class="line"><span class="comment">        参数2：队列名 （这里的队列名其实就是路由键了）</span></span><br><span class="line"><span class="comment">        basicProperties:消息的属性（没有属性则为空）</span></span><br><span class="line"><span class="comment">        参数4 bytes[]  :消息的内容(只能是字节数组)</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"> channel.basicPublish(<span class="string">&quot;test_exchange_durable&quot;</span>, <span class="string">&quot;user.register&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</span><br></pre></td></tr></table></figure><p>这样就可以让路由器持久化（重启RabbitMQ后依然存在）</p><p><img src="/images/image-20220226145849060.png" alt="image-20220226145849060"></p><p>Features中所有D都是durable持久化的意思，就一直存在，重启RabbitMQ服务后的效果：</p><p><img src="/images/image-20220226150040955.png" alt="image-20220226150040955"></p><ul><li>**消费者代码（实现队列的持久化） ** </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//3.创建消息队列</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数1：队列名称</span></span><br><span class="line"><span class="comment">        参数2：队列中的数据是否持久化 (把它设为真就让队列也持久化)</span></span><br><span class="line"><span class="comment">        参数3：是否排外（是否支持扩展，排外就是：当前队列只能自己用别人不能用）</span></span><br><span class="line"><span class="comment">        参数4：是否自动删除（当队列连接数为0时，队列会自己销毁，不关队列是否还保存数据）</span></span><br><span class="line"><span class="comment">        参数5：队列参数（没有参数为null）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;test_exchange_direct_durable_1&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220226152130728.png" alt="image-20220226152130728"></p><p>于是队列也实现了持久化</p><h1 id="5-Spring整合RabbitMQ"><a href="#5-Spring整合RabbitMQ" class="headerlink" title="5.Spring整合RabbitMQ"></a>5.Spring整合RabbitMQ</h1><ul><li>五种消息模型，在企业中应用最广泛的就是最后一种：定向匹配topic</li></ul><h2 id="生产者端"><a href="#生产者端" class="headerlink" title="生产者端"></a>生产者端</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag"></span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    1.配置RabbitMQ的连接工厂</span></span><br><span class="line"><span class="comment">        （IP,端口，用户名，密码，虚拟主机）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">host</span>=<span class="string">&quot;192.168.10.100&quot;</span> <span class="attr">port</span>=<span class="string">&quot;5672&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">username</span>=<span class="string">&quot;kled&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">virtual-host</span>=<span class="string">&quot;/rabbit_start&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:connection-factory</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    2.配置队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;test_spring_queue_1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    3.配置rabbitAdmin:主要用于在Java代码中对队列的管理（创建，绑定，删除队列与路由，发送信息等都在这里面封装）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:admin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    4.配置路由，这里用topic类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:topic-exchange</span> <span class="attr">name</span>=<span class="string">&quot;spring_topic_exchange&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        路由与队列绑定</span></span><br><span class="line"><span class="comment">            解释：spring_topic_exchange路由中msg.#的消息类型会与test_spring_queue_1相绑定</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">pattern</span>=<span class="string">&quot;msg.#&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;test_spring_queue_1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:topic-exchange</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    5.配置JSON转换工具--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.support.converter.Jackson2JsonMessageConverter&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jsonMessageConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    6.配置RabbitMQ的模板--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;rabbitTemplate&quot;</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">exchange</span>=<span class="string">&quot;spring_topic_exchange&quot;</span> <span class="attr">message-converter</span>=<span class="string">&quot;jsonMessageConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Sender-java"><a href="#Sender-java" class="headerlink" title="Sender.java"></a>Sender.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.这里没有通过注解开发</span></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring/applicationContext.xml&quot;</span>);</span><br><span class="line">        RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.发消息(用map来装方便转JSON)</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;dhw&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;phone&quot;</span>,<span class="string">&quot;17381580803&quot;</span>);</span><br><span class="line">        <span class="comment">//指定路由键（路由与队列的绑定在配置文件中已经完成了）</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;msg.user&quot;</span>,map);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后：</p><p><img src="/images/image-20220226163639711.png" alt="image-20220226163639711"></p><h2 id="消费者端"><a href="#消费者端" class="headerlink" title="消费者端"></a>消费者端</h2><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag"></span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    1.配置RabbitMQ的连接工厂</span></span><br><span class="line"><span class="comment">        （IP,端口，用户名，密码，虚拟主机）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">host</span>=<span class="string">&quot;192.168.10.100&quot;</span> <span class="attr">port</span>=<span class="string">&quot;5672&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">username</span>=<span class="string">&quot;kled&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">virtual-host</span>=<span class="string">&quot;/rabbit_start&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:connection-factory</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    2.配置队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;test_spring_queue_1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    3.配置rabbitAdmin:主要用于在Java代码中对队列的管理（创建，绑定，删除队列与路由，发送信息等都在这里面封装）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:admin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--===============================以上都和生产者相同===============================================--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    4.注解扫描（为了注入自己写的ConsumerListener）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;listener&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    5.配置监听  哪个类监听哪个队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">&quot;consumerListener&quot;</span> <span class="attr">queue-names</span>=<span class="string">&quot;test_spring_queue_1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="监听器类"><a href="#监听器类" class="headerlink" title="监听器类"></a>监听器类</h3><ul><li>MessageListener接口用于spring容器接收到消息后处理消息</li><li>如果需要使用自己定义的类型（这里就用的是map）来实现处理消息时，必须实现该接口，并重写onMessage()方法</li><li>当spring容器接收消息后，会自动交由onMessage进行处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//json提供序列化和反序列化最多的类：用来转换JSON的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将message对象转换为JSON</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JsonNode jsonNode = MAPPER.readTree(message.getBody());</span><br><span class="line">            String name = jsonNode.get(<span class="string">&quot;name&quot;</span>).asText();</span><br><span class="line">            String phone = jsonNode.get(<span class="string">&quot;phone&quot;</span>).asText();</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息， name = &quot;</span> + name + <span class="string">&quot;   phone = &quot;</span> + phone);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在发送端运行两次发送消息，因为消费端一直在监听队列所以可以得出最终运行结果：</p><p><img src="/images/image-20220226163704005.png" alt="image-20220226163704005"><img src="/images/image-20220226163754151.png" alt="image-20220226163754151"></p><h1 id="6-消息成功确认机制"><a href="#6-消息成功确认机制" class="headerlink" title="6.消息成功确认机制"></a>6.消息成功确认机制</h1><p>确保生产者发送的消息成功进入消息队列中</p><ul><li>事务机制（用得少）</li><li>发布确认</li></ul><h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><ul><li>channel.txSelect(): 开启事务</li><li>channel.txCommit() ：提交事务</li><li>channel.txRollback() ：回滚事务</li></ul><p>但是其实spring已经把这三个方法封装了</p><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><p><strong>采用事务的话，会大大降低事务的吞吐量</strong></p><p>原因是，试想一下：10条消息，前9条成功，如果第10条失败，那么9条消息 要全部撤销回滚，太浪费</p><p>confirm模式则采用<strong>补发</strong>第10条的措施来完成10条消息的送达</p><ul><li>生产者配置文件，<strong>只需要添加 publisher-confirms和 confirm-callback</strong>两个参数即可</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    1.配置RabbitMQ的连接工厂  (开启了消息确认机制就在最后那个参数置为true)</span></span><br><span class="line"><span class="comment">        （IP,端口，用户名，密码，虚拟主机） (publisher-confirms)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">host</span>=<span class="string">&quot;192.168.10.100&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">port</span>=<span class="string">&quot;5672&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">username</span>=<span class="string">&quot;kled&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">virtual-host</span>=<span class="string">&quot;/rabbit_start&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">publisher-confirms</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:connection-factory</span>&gt;</span>//********************</span><br><span class="line"><span class="comment">&lt;!--    2.配置队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;test_spring_queue_1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    3.配置rabbitAdmin:主要用于在Java代码中对队列的管理（创建，绑定，删除队列与路由，发送信息等都在这里面封装）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:admin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    4.配置路由，这里用topic类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:topic-exchange</span> <span class="attr">name</span>=<span class="string">&quot;spring_topic_exchange&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        路由与队列绑定</span></span><br><span class="line"><span class="comment">            解释：spring_topic_exchange路由中msg.#的消息类型会与test_spring_queue_1相绑定</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">pattern</span>=<span class="string">&quot;msg.#&quot;</span> <span class="attr">queue</span>=<span class="string">&quot;test_spring_queue_1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:topic-exchange</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    5.配置JSON转换工具--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.support.converter.Jackson2JsonMessageConverter&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jsonMessageConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    6.配置RabbitMQ的模板--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;rabbitTemplate&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">exchange</span>=<span class="string">&quot;spring_topic_exchange&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">message-converter</span>=<span class="string">&quot;jsonMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">confirm-callback</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:template</span>&gt;</span>  //******</span><br><span class="line"><span class="comment">&lt;!--    7.确认机制的处理类(这个项目里没采用注解，所以在这里配置bean)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.confirm.MessageConfirmCallBack&quot;</span> <span class="attr">id</span>=<span class="string">&quot;messageConfirmCallBack&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>确认机制处理类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConfirmCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//CorrelationData消息相关的数据对象 追源码就能看到里面封装了消息的唯一id</span></span><br><span class="line">    <span class="comment">//第二个Bool类型的参数表示消息是否发送成功</span></span><br><span class="line">    <span class="comment">//参数3：异常信息（如果是正常的话就是个空串）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> b, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息确认成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;失败了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将发送方法添加一个参数，写上错误的路由模拟发送失败</p><p><img src="/images/image-20220226175413550.png" alt="image-20220226175413550"></p><p>把错误的路由去掉，此时就是向在spring里</p><p><img src="/images/image-20220226175437612.png" alt="image-20220226175437612"></p><h1 id="7-消费端限流"><a href="#7-消费端限流" class="headerlink" title="7. 消费端限流"></a>7. 消费端限流</h1><ul><li>Rabbitmq 服务器积压了成千上万条未处理的消息，然后随便打开一个消费者客户端，巨量的消息瞬间全部喷涌推送过来，但是单个客户端无法同时处理这么多数据， 就会被压垮崩溃。</li><li>当数据量特别大的时候，我们对生产端限流肯定是不科学的，因为有时候并发量就是特别 大，有时候并发量又特别少，这是用户的行为，我们是无法约束的</li><li> Qos （Quality of Service，服务质量）：在非自动确认消息的前提下，如果一定数目的消息未被确认前，不再进行消费新的消息<strong>（工作队列模式那里用到过）</strong></li></ul><ul><li>生产端模拟积压很多消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">           <span class="comment">//指定路由键并发送（路由与队列的绑定在配置文件中已经完成了）</span></span><br><span class="line">           rabbitTemplate.convertAndSend(<span class="string">&quot;msg.user&quot;</span>,map);</span><br><span class="line">           System.out.println(<span class="string">&quot;发送完成&quot;</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220226214445384.png" alt="image-20220226214445384"></p><ul><li>消费端设置限流，只需要多配置两个属性（acknowledge设置手动自动确认，prefetch设置每次处理多少个请求）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    5.配置监听  哪个类监听哪个队列--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    prefetch:一次处理多少条消息  （会告诉RabbitMQ不要往这个消费者身上堆多余prefetch条消息。这些消息没有ack之前，consumer会被阻塞，直到有prefetch条ack）</span></span><br><span class="line"><span class="comment">        acknowledge:手动ack还是自动ack（消费端限流需要手动确认）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">prefetch</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">acknowledge</span>=<span class="string">&quot;manual&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">&quot;consumerListener&quot;</span> <span class="attr">queue-names</span>=<span class="string">&quot;test_spring_queue_1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果要实现消息限流，之前的消息监听器就必须继承类</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/24/FastDFS/"/>
      <url>/2022/02/24/FastDFS/</url>
      
        <content type="html"><![CDATA[<h1 id="1-FastDFS"><a href="#1-FastDFS" class="headerlink" title="1. FastDFS"></a>1. FastDFS</h1><h1 id="2-上传与下载"><a href="#2-上传与下载" class="headerlink" title="2. 上传与下载"></a>2. 上传与下载</h1><h2 id="1-上传"><a href="#1-上传" class="headerlink" title="1. 上传"></a>1. 上传</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upload</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加载配置文件</span></span><br><span class="line">            ClientGlobal.initByProperties(<span class="string">&quot;config/fastdfs-client.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建tracker客户端</span></span><br><span class="line">            TrackerClient trackerClient = <span class="keyword">new</span> TrackerClient();</span><br><span class="line">            <span class="comment">//通过此客户端获取tracker的连接服务</span></span><br><span class="line">            TrackerServer trackerServer = trackerClient.getConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明storage服务</span></span><br><span class="line">            StorageServer storageServer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义storage客户端</span></span><br><span class="line">            StorageClient1 storageClient1 = <span class="keyword">new</span> StorageClient1(trackerServer, storageServer);</span><br><span class="line">            <span class="comment">//定义文件元信息</span></span><br><span class="line">            NameValuePair[] list = <span class="keyword">new</span> NameValuePair[<span class="number">1</span>];</span><br><span class="line">            list[<span class="number">0</span>] = <span class="keyword">new</span> NameValuePair(<span class="string">&quot;fileName&quot;</span>,<span class="string">&quot;image.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//上传文件  上传文件后storage会返回给本机一个fileId</span></span><br><span class="line"></span><br><span class="line">            String fileId = storageClient1.upload_appender_file1(<span class="string">&quot;F:\\image.jpg&quot;</span>, <span class="string">&quot;jpg&quot;</span>, list);</span><br><span class="line">            <span class="comment">//group1/M00/00/00/wKgKZGIXMvuEPQhqAAAAABlH-ko424.jpg</span></span><br><span class="line">            <span class="comment">//group1:因为现在只开了一台服务器，所以只有一个组就是group1</span></span><br><span class="line">            <span class="comment">//M00: 对应着storage_path0(这是配置文件里的那个参数) 配置的值指向了 /home/fasdfs/fdfs_storage/data</span></span><br><span class="line">            <span class="comment">//后面的两个 00对应着/home/fasdfs/fdfs_storage/data/00/00，这个目录下就存在着刚刚上传的那个文件</span></span><br><span class="line">            System.out.println(fileId);</span><br><span class="line">            trackerServer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="../images/image-20220224153835952.png" alt="image-20220224153835952"></p><p>对于得到的结果：</p><ul><li><strong>group1</strong>:因为现在只开了一台服务器，所以只有一个组就是group1</li><li><strong>M00</strong>: 对应着<strong>storage_path0(这是配置文件里的那个参数)</strong> 配置的值指向了 /home/fasdfs/fdfs_storage/data</li><li><strong>00/00</strong>:00对应着/home/fasdfs/fdfs_storage/data/00/00，这个目录下就存在着刚刚上传的那个文件</li></ul><p><img src="../images/image-20220224153759166.png" alt="image-20220224153759166"></p><h2 id="2-文件查询"><a href="#2-文件查询" class="headerlink" title="2. 文件查询"></a>2. 文件查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//============================和上传一模一样===========================</span></span><br><span class="line">            <span class="comment">//加载配置文件</span></span><br><span class="line">            ClientGlobal.initByProperties(<span class="string">&quot;config/fastdfs-client.properties&quot;</span>);</span><br><span class="line">            <span class="comment">//创建tracker客户端</span></span><br><span class="line">            TrackerClient trackerClient = <span class="keyword">new</span> TrackerClient();</span><br><span class="line">            <span class="comment">//通过此客户端获取tracker的连接服务</span></span><br><span class="line">            TrackerServer trackerServer = trackerClient.getConnection();</span><br><span class="line">            <span class="comment">//声明storage服务</span></span><br><span class="line">            StorageServer storageServer = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//定义storage客户端</span></span><br><span class="line">            StorageClient1 storageClient1 = <span class="keyword">new</span> StorageClient1(trackerServer, storageServer);</span><br><span class="line">            <span class="comment">//============================和上传一模一样===========================</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//查询文件   (storage服务器那边会返回一个文件信息)</span></span><br><span class="line">            FileInfo fileInfo = storageClient1.query_file_info1(<span class="string">&quot;group1/M00/00/00/wKgKZGIXMvuEPQhqAAAAABlH-ko424.jpg&quot;</span>);</span><br><span class="line">            System.out.println(fileInfo);</span><br><span class="line"></span><br><span class="line">            trackerServer.close();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>于是也就查到了之前上传的图片：</p><p><img src="../images/image-20220224155335956.png" alt="image-20220224155335956"></p><h2 id="3-文件下载"><a href="#3-文件下载" class="headerlink" title="3. 文件下载"></a>3. 文件下载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//============================和上传,查询一模一样===========================</span></span><br><span class="line">            <span class="comment">//加载配置文件</span></span><br><span class="line">            ClientGlobal.initByProperties(<span class="string">&quot;config/fastdfs-client.properties&quot;</span>);</span><br><span class="line">            <span class="comment">//创建tracker客户端</span></span><br><span class="line">            TrackerClient trackerClient = <span class="keyword">new</span> TrackerClient();</span><br><span class="line">            <span class="comment">//通过此客户端获取tracker的连接服务</span></span><br><span class="line">            TrackerServer trackerServer = trackerClient.getConnection();</span><br><span class="line">            <span class="comment">//声明storage服务</span></span><br><span class="line">            StorageServer storageServer = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//定义storage客户端</span></span><br><span class="line">            StorageClient1 storageClient1 = <span class="keyword">new</span> StorageClient1(trackerServer, storageServer);</span><br><span class="line">            <span class="comment">//============================和上传，查询一模一样===========================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//下载   (返回了一个字节数组)</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = storageClient1.download_file1(<span class="string">&quot;group1/M00/00/00/wKgKZGIXMvuEPQhqAAAAABlH-ko424.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过IO流将字节数组转换成文件放回磁盘</span></span><br><span class="line">            FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;E:/result.jpg&quot;</span>));</span><br><span class="line">            fileOutputStream.write(bytes);</span><br><span class="line"></span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">            trackerServer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：完美将上传的图片取出并存在了E盘</p><p><img src="../images/image-20220224155842778.png" alt="image-20220224155842778"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/21/Redis/"/>
      <url>/2022/02/21/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="1-一些操作"><a href="#1-一些操作" class="headerlink" title="1.一些操作"></a>1.一些操作</h1><ul><li>默认数据库数量为16</li></ul><p><img src="E:/Blogg/blog/source/images/image-20220221210417020.png" alt="image-20220221210417020"></p><ul><li>向数据库中存与取</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set k1 china</span><br><span class="line">get k1</span><br></pre></td></tr></table></figure><ul><li>查询当前数据库中键（Key）      三种通配符  ? * []</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">   *对应%   ?对应_</span>   </span><br><span class="line">keys *   #查所有键</span><br><span class="line">keys n*  #查所有n开头的键（模糊查询）</span><br><span class="line">keys *1  #查所有最后一个是1的键（模糊查询）</span><br><span class="line">keys *n* #懂的都懂</span><br><span class="line"></span><br><span class="line">keys n? #?只是一个位置的模糊</span><br><span class="line"></span><br><span class="line">keys r[ae]dis  #如果存在的话可以查出radis和redis</span><br></pre></td></tr></table></figure><ul><li>切换数据库（从零开始的）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 13   #默认16个数据库的话就是0~15</span><br></pre></td></tr></table></figure><ul><li>清空数据库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flushdb   #清空当前库</span><br><span class="line">flushall  #清空所有数据库</span><br></pre></td></tr></table></figure><ul><li>判断某个Key是否存在</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists k1  #1存在 0不存在</span><br></pre></td></tr></table></figure><ul><li>移动（剪切后粘贴）键到别的库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move k1 3</span><br></pre></td></tr></table></figure><ul><li>查看键还有多久过期（-1 永不过期，-2已过期）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ttl k1   #返回的正数就是所剩的存活时间（秒）</span><br><span class="line"></span><br><span class="line">expire k1 10 #为k1设置存活时间（单位是秒）</span><br></pre></td></tr></table></figure><ul><li>查看键的数据类型</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type k1</span><br></pre></td></tr></table></figure><h1 id="2-五大数据类型"><a href="#2-五大数据类型" class="headerlink" title="2.五大数据类型"></a>2.五大数据类型</h1><h2 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h2><ul><li><p>set /get /del /append （返回值指的是添加后value的长度）/strlen  </p></li><li><p>incr （++）/decr（–） /incrby（+=） /decrby（-=）：加减操作，操作的必须是数字类型</p></li><li><p>getrange / setrange  </p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> getrange 0 -1   #指的就是所有范围   左闭右闭</span><br><span class="line"> </span><br><span class="line"> 127.0.0.1:6379&gt; setrange k1 1 xxx # 替换k1的值，从下标1开始提供为xxx</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;axxxef</span><br></pre></td></tr></table></figure><ul><li><p>setex / setnx  </p><ul><li>set with expir：添加数据的同时设置生命周期  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex k1 5 v1 # 添加k1 v1数据的同时，设置5秒的声明周期</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;v1&quot;</span><br></pre></td></tr></table></figure><ul><li>set if not exist：添加数据的时候判断是否已经存在，防止已存在的数据被覆盖掉  </li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; get k1</span><br><span class="line">&quot;abcdef&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; setnx k1 aaa</span><br><span class="line">(integer) 0            #0就是设置失败的意思</span><br><span class="line">127.0.0.1:6379[1]&gt; get k1</span><br><span class="line">&quot;abcdef&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>mset /mget/ msetnx      m: more  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; msetnx k3 v3 k4 v4 # 如果添加的数据中有已经存在的，则失败</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; msetnx k4 v4 k5 v5 # 如果添加的数据中都不存在的，则成功</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><ul><li>​    getset：先get后set </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k6</span><br><span class="line">&quot;v6&quot;</span><br><span class="line">127.0.0.1:6379&gt; getset k6 vv6 # 先获取k6的值，然后修改k6的值为vv6</span><br><span class="line">&quot;v6&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k6</span><br><span class="line">&quot;vv6</span><br></pre></td></tr></table></figure><h2 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h2><ul><li>lpush/rpush/lrange  (0 -1表示全部)      *注意没有rrange<ul><li>left 自左向右→添加 （从上往下添加）      <strong>倒序</strong></li><li>right 自右向左←添加（从下往上添加）    <strong>正序</strong></li></ul></li><li>lpop/rpop：移除第一个元素（上左下右）  </li><li>lindex：根据下标查询元素            *没有rindex</li><li>llen：返回集合长度  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list02 1 2 3 4 5 # 从下往上添加</span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################</span></span></span><br><span class="line">127.0.0.1:6379&gt; lrange list02 0 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">########################</span></span></span><br><span class="line">127.0.0.1:6379&gt; lpop list02 # 从左（上）边移除第一个元素</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list02 # 从右（下）边移除第一个元素</span><br><span class="line">&quot;5&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#########################</span></span></span><br><span class="line">127.0.0.1:6379&gt; lindex list01 1 # 从上到下数，下标为1的值</span><br><span class="line">&quot;4&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############</span></span></span><br><span class="line">127.0.0.1:6379&gt; llen list01</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><ul><li>lrem：删除n个value  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush l2 1 2 3 4 4 4 4 5 6 7 </span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; lrem l2 10 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange l2 0 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;5&quot;</span><br><span class="line">5) &quot;6&quot;</span><br><span class="line">6) &quot;7&quot;</span><br></pre></td></tr></table></figure><ul><li>ltrim：截取指定范围的值，别的全扔掉    左闭右闭<ul><li>ltrim key begindex endindex  </li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange l2 0 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;5&quot;</span><br><span class="line">5) &quot;6&quot;</span><br><span class="line">6) &quot;7&quot;</span><br><span class="line">127.0.0.1:6379&gt; LTRIM l2 0 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange l2 0 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br></pre></td></tr></table></figure><ul><li><p>rpoplpush：从一个集合搞一个元素到另一个集合中（右出一个，左进一个）  </p><p><img src="/images/image-20220222141436478.png" alt="image-20220222141436478"></p></li><li><p>lset：改变执行下标的值</p></li><li><p>linsert：插入元素（指定某个元素之前/之后）    </p><ul><li>linsert key <strong>before/after</strong> oldvalue newvalue</li><li>性能总结：类似添加火车皮一样，头尾操作效率高，中间操作效率低    </li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush l1 1 2 3 4 5   #rpop就是5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; rpush l2 10 11 12 13  #lpush就从10左边添加</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH l1 l2</span><br><span class="line">&quot;5&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange l2 0 -1</span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;11&quot;</span><br><span class="line">4) &quot;12&quot;</span><br><span class="line">5) &quot;13&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">######################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; lset l2 1 200</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange l2 0 -1</span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;200&quot;</span><br><span class="line">3) &quot;11&quot;</span><br><span class="line">4) &quot;12&quot;</span><br><span class="line">5) &quot;13&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; LINSERT l2 after 200 java</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; lrange l2 0 -1</span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;200&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;11&quot;</span><br><span class="line">5) &quot;12&quot;</span><br><span class="line">6) &quot;13&quot;</span><br></pre></td></tr></table></figure><h2 id="3-Set"><a href="#3-Set" class="headerlink" title="3. Set"></a>3. Set</h2><p>和java中的set特点类似，不允许重复  </p><ul><li>sadd/smembers/sismember：添加/查看/判断是否存在  </li><li>scard：获得集合中的元素个数  </li><li>srem：删除集合中的元素  </li><li>srandmember：从集合中随机获取几个元素  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set1 1 2 2 2 3 4 4 5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS set1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#######################</span></span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER set1 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER set1 6</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#########################</span></span></span><br><span class="line">127.0.0.1:6379&gt; scard set1</span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">######################</span></span></span><br><span class="line">127.0.0.1:6379&gt; SREM set1 5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS set1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##########################</span></span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER set1 2   #参数指的是个数</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;2&quot;</span><br></pre></td></tr></table></figure><ul><li>spop：<strong>随机</strong>出栈（移除）  </li><li>smove：移动元素：将set1某个值挪给set2  （即便这个元素在set2中已经重复了，set1的那个元素也会移除）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd s2 1 2 3 4 5 6 7 8 9 10</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; SPOP s2</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS s2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;4&quot;</span><br><span class="line">4) &quot;5&quot;</span><br><span class="line">5) &quot;6&quot;</span><br><span class="line">6) &quot;7&quot;</span><br><span class="line">7) &quot;8&quot;</span><br><span class="line">8) &quot;9&quot;</span><br><span class="line">9) &quot;10&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#######################</span></span></span><br><span class="line">127.0.0.1:6379&gt; sadd s1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; SMOVE s1 s2 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS s1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;4&quot;</span><br></pre></td></tr></table></figure><ul><li>交集：sinter<br>并集：sunion<br>差集：sdiff    （这个就要注意参数顺序了）  sdiff s1 s2  -&gt; s1存在而s2不存在</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd s2 1 2 3 4 java pyhon c++</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS s1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;3&quot;</span><br><span class="line">6) &quot;c&quot;</span><br><span class="line">7) &quot;d&quot;</span><br><span class="line">8) &quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; sinter s1 s2</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;4&quot;</span><br><span class="line">4) &quot;1&quot;</span><br></pre></td></tr></table></figure><h2 id="4-Hash"><a href="#4-Hash" class="headerlink" title="4. Hash"></a>4. Hash</h2><p>KV模式不变，但V是一个键值对  </p><p><img src="/images/image-20220222155144971.png" alt="image-20220222155144971"></p><ul><li>hset/hget/hmset/hmget/hgetall/hdel：添加/得到/多添加/多得到/得到全部/删除属性      m: more</li><li>hlen：返回元素的属性个数  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user id 1001 # 添加user，值为id=1001</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget user</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;hget&#x27; command</span><br><span class="line">127.0.0.1:6379&gt; hget user id # 查询user，必须指明具体的字段</span><br><span class="line">&quot;1001&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; hmset student id 101 name tom age 22 # 添加学生student，属性一堆</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hget student name # 获取学生名字</span><br><span class="line">&quot;tom&quot;</span><br><span class="line">127.0.0.1:6379&gt; hmget student name age # 获取学生姓名与年龄  m more</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;22&quot;</span><br><span class="line">127.0.0.1:6379&gt; hgetall student # 获取全部信息</span><br><span class="line">1) &quot;id&quot;</span><br><span class="line">2) &quot;101&quot;</span><br><span class="line">3) &quot;name&quot;</span><br><span class="line">4) &quot;tom&quot;</span><br><span class="line">5) &quot;age&quot;</span><br><span class="line">6) &quot;22&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#######################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; hdel student age # 删除学生年龄属性</span><br><span class="line">(integer) 1 # 删除成功</span><br><span class="line">127.0.0.1:6379&gt; hgetall student</span><br><span class="line">1) &quot;id&quot;</span><br><span class="line">2) &quot;101&quot;</span><br><span class="line">3) &quot;name&quot;</span><br><span class="line">4) &quot;tom&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#########################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; hlen student</span><br><span class="line">(integer) 2         # student属性的数量，id和name，共两个属性</span><br></pre></td></tr></table></figure><ul><li>hexists：判断元素是否存在某个属性  </li><li>hkeys/hvals：获得属性的所有key/获得属性的所有value  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">27.0.0.1:6379&gt; hexists student name # student中是否存在name属性</span><br><span class="line">(integer) 1 # 存在</span><br><span class="line">127.0.0.1:6379&gt; hexists student age # student中是否存在age属性</span><br><span class="line">(integer) 0 # 不存在</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; hkeys student # 获取student所有的属性名</span><br><span class="line">1) &quot;id&quot;</span><br><span class="line">2) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals student # 获取student所有属性的值（内容）</span><br><span class="line">1) &quot;101&quot;</span><br><span class="line">2) &quot;tom&quot;</span><br></pre></td></tr></table></figure><ul><li>hincrby/hincrbyfloat：自增（整数）/自增（小数）  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset student id 101 name tom age 22</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hincrby student age 2 # 自增整数2</span><br><span class="line">(integer) 24</span><br><span class="line">127.0.0.1:6379&gt; hget student age</span><br><span class="line">&quot;24&quot;</span><br><span class="line">127.0.0.1:6379&gt; hmset user id 1001 money 1000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat user money 5.5 # 自增小数5.5</span><br><span class="line">&quot;1005.5&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget user money</span><br><span class="line">&quot;1005.5&quot;</span><br></pre></td></tr></table></figure><ul><li>hsetnx：添加的时候，先判断是否存在  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hsetnx student age 18 # 添加时，判断age是否存在</span><br><span class="line">(integer) 0 # 添加失败，因为age已存在</span><br><span class="line">127.0.0.1:6379&gt; hsetnx student sex 男 # 添加时，判断sex是否存在</span><br><span class="line">(integer) 1 # 添加成功，因为sex不存在</span><br></pre></td></tr></table></figure><h2 id="5-Zset"><a href="#5-Zset" class="headerlink" title="5. Zset"></a>5. Zset</h2><ul><li>zadd/zrange （withscores）：添加/查询  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset01 10 vip1 20 vip2 30 vip3 40 vip4 50 vip5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; zrange zset01 0 -1 # 查询数据</span><br><span class="line">1) &quot;vip1&quot;</span><br><span class="line">2) &quot;vip2&quot;</span><br><span class="line">3) &quot;vip3&quot;</span><br><span class="line">4) &quot;vip4&quot;</span><br><span class="line">5) &quot;vip5&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange zset01 0 -1 withscores # 带着分数查询数据</span><br><span class="line">1) &quot;vip1&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;vip2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;vip3&quot;</span><br><span class="line">6) &quot;30&quot;</span><br><span class="line">7) &quot;vip4&quot;</span><br><span class="line">8) &quot;40&quot;</span><br><span class="line">9) &quot;vip5&quot;</span><br><span class="line">10) &quot;50</span><br></pre></td></tr></table></figure><ul><li>zrangebyscore：模糊查询  <ul><li>( ： 不包含  </li><li>limit：跳过几个截取几个  </li></ul></li><li>zrevrangebyscore：逆序范围查找  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrangebyscore zset01 20 40 # 20 &lt;= score &lt;= 40</span><br><span class="line">1) &quot;vip2&quot;</span><br><span class="line">2) &quot;vip3&quot;</span><br><span class="line">3) &quot;vip4&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore zset01 20 (40 # 20 &lt;= score &lt; 40</span><br><span class="line">1) &quot;vip2&quot;</span><br><span class="line">2) &quot;vip3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore zset01 (20 (40 # 20 &lt; score &lt; 40</span><br><span class="line">1) &quot;vip3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore zset01 10 40 limit 2 2 # 10 &lt;= score &lt;=40，共返回四个，跳过前2个，取2个</span><br><span class="line">1) &quot;vip3&quot;</span><br><span class="line">2) &quot;vip4&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore zset01 10 40 limit 2 1 # 20 &lt;= score &lt;=40，共返回四个，跳过前2个，取1个</span><br><span class="line">1) &quot;vip3&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#########################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; zrevrangebyscore zset01 30 20 # 逆序查询分数在30~20之间的  （注意，先写大值，再写小值）</span><br><span class="line">1) &quot;vip3&quot;</span><br><span class="line">2) &quot;vip2&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrangebyscore zset01 20 30 # 如果小值在前，则结果为null</span><br><span class="line">(empty list or set)</span><br></pre></td></tr></table></figure><ul><li>zrem：删除元素  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem zset01 vip5 # 移除vip5</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><ul><li>zcard/zcount/zrank/zscore：集合长度/范围内元素个数/元素下标/通过值得到分数  </li><li>zrevrank：逆序找下标（从下向上）  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset01 10 vip1 20 vip2 30 vip3 40 vip4 50 vip5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; zrange zset01 0 -1 # 查询数据</span><br><span class="line">1) &quot;vip1&quot;</span><br><span class="line">2) &quot;vip2&quot;</span><br><span class="line">3) &quot;vip3&quot;</span><br><span class="line">4) &quot;vip4&quot;</span><br><span class="line">5) &quot;vip5&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#########################</span></span></span><br><span class="line">127.0.0.1:6379&gt; zcard zset01 # 集合中元素的个数</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; zcount zset01 20 30 # 分数在20~30之间，共有几个元素  (vip2 vip3)</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrank zset01 vip3 # vip3在集合中的下标（从上向下）</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrevrank zset01 vip3  #从下到上</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zscore zset01 vip2 # 通过元素获得对应的分数</span><br><span class="line">&quot;20&quot;</span><br></pre></td></tr></table></figure><ul><li>zrevrange：逆序查询  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange zset01 0 -1 # 顺序查询</span><br><span class="line">1) &quot;vip1&quot;</span><br><span class="line">2) &quot;vip2&quot;</span><br><span class="line">3) &quot;vip3&quot;</span><br><span class="line">4) &quot;vip4&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrange zset01 0 -1 # 逆序查询</span><br><span class="line">1) &quot;vip4&quot;</span><br><span class="line">2) &quot;vip3&quot;</span><br><span class="line">3) &quot;vip2&quot;</span><br><span class="line">4) &quot;vip1&quot;</span><br></pre></td></tr></table></figure><h1 id="3-持久化方案"><a href="#3-持久化方案" class="headerlink" title="3.持久化方案"></a>3.持久化方案</h1><h2 id="1-RDB-Redis-DataBase"><a href="#1-RDB-Redis-DataBase" class="headerlink" title="1. RDB  (Redis DataBase)"></a>1. RDB  (Redis DataBase)</h2><h3 id="自动备份机制"><a href="#自动备份机制" class="headerlink" title="自动备份机制"></a>自动备份机制</h3><ul><li>在指定的时间间隔内，将内存中的数据集的<strong>快照</strong>写入磁盘；默认保存在/usr/local/bin中，文件名dump.rdb;  </li><li>每次关机时，redis会自动将数据备份到一个文件中 ：/usr/local/bin/dump.rdb  </li></ul><p><img src="/images/image-20220222164339127.png" alt="image-20220222164339127"></p><p>如果只是用Redis的缓存功能，不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。</p><p>即把三行save都注释掉而把上面那个save “”打开</p><ul><li><p>使用shutdown模拟关机 ，关机之前和关机之后，对比dump.rdb文件的更新时间</p><p>结论：<strong>当使用shutdown命令，redis会自动将数据库备份</strong>，所以，dump.rdb文件创建时间更新了</p></li></ul><p><img src="/images/image-20220222164929434.png" alt="image-20220222164929434"></p><p><img src="/images/image-20220222164912403.png" alt="image-20220222164912403"></p><ul><li><strong>redis每次启动所读的文件是dump.rdb</strong>。所以如果将这个文件备份一份，把原来的删除，把备份的文件再改名为dump.rdb，下一次启动redis就还能读到之前备份的数据</li></ul><h3 id="手动备份"><a href="#手动备份" class="headerlink" title="手动备份"></a>手动备份</h3><p>之前自动备份，必须更改好多数据，例如上边，改变了十多条数据，或shutdown才会自动备份</p><p>若只保存一条数据，就想立刻备份，那么，执行命令 save 就会立刻备份  </p><p><img src="/images/image-20220222170605090.png" alt="image-20220222170605090"></p><p><img src="/images/image-20220222170615124.png" alt="image-20220222170615124"></p><h3 id="RDB的相关配置-opt-redis-5-0-4-redis-conf"><a href="#RDB的相关配置-opt-redis-5-0-4-redis-conf" class="headerlink" title="RDB的相关配置 (/opt/redis-5.0.4/redis.conf)"></a>RDB的相关配置 (/opt/redis-5.0.4/redis.conf)</h3><ul><li><p><strong>stop-writes-on-bgsave-error</strong>：当后台备份时候反生错误前台是否写入 </p><p>yes：当后台备份时候反生错误，前台停止写入  </p><p>no：不管死活，就是往里怼  </p></li><li><p><strong>rdbcompression</strong>：对于存储到磁盘中的<strong>快照（dump.rdb）</strong>，是否启动LZF压缩算法  （一般都是yes）</p></li><li><p><strong>rdbchecksum</strong>：在存储快照后，是否启动CRC64算法进行数据校验  </p></li><li><p><strong>dbfilename</strong>：快照备份文件名字  </p></li></ul><p><img src="/images/image-20220222172400201.png" alt="image-20220222172400201"></p><ul><li><strong>dir</strong>：快照备份文件保存的目录，默认为当前目录  </li></ul><p><img src="/images/image-20220222172556029.png" alt="image-20220222172556029"></p><p><strong>优势and劣势</strong>  </p><ul><li>优：适合大规模数据恢复，对数据完整性和一致行要求不高；  </li><li>劣：一定间隔备份一次，意外down掉，就失去最后一次快照的所有修改  </li></ul><h2 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2.AOF (Append Only File  )"></a>2.AOF (Append Only File  )</h2><ul><li>以日志的形式记录每个写操作  </li><li>将redis执行过的<strong>写指令</strong>全部记录下来（读操作不记录）  </li><li>只许追加文件，不可以改写文件  </li><li>redis在启动之初会读取该文件从<strong>头到尾执行一遍</strong>，这样来重新构建数据  </li></ul><p><img src="/images/image-20220222173430857.png" alt="image-20220222173430857"></p><p>默认是关闭这种方式的，为了操作就把他改为yes</p><p><img src="/images/image-20220222173833755.png" alt="image-20220222173833755"></p><p>存入几个KV后删除，出来发现一个appendonly.aof，进入后的内容为（<strong>即一个日志，呼应第一条</strong>）</p><p><img src="/images/image-20220222173953882.png" alt="image-20220222173953882"></p><p>在这里把flushall给删了，重新启动redis，发现之前存的KV又出现了（<strong>呼应上面的第四条</strong>）</p><p><img src="/images/image-20220222174140794.png" alt="image-20220222174140794"></p><h2 id="3-AOF相关配置"><a href="#3-AOF相关配置" class="headerlink" title="3. AOF相关配置"></a>3. AOF相关配置</h2><ul><li><strong>都开启时谁优先？</strong></li></ul><p>AOF     AOF比RDB数据保存的完整性更高         </p><ul><li>如果在appendonly.aof中乱写代码，会导致redis启动不了（所以优先AOF），此时通过命令可以修复AOF文件将里面不符合语法规范的代码删除</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reids-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220222174821537.png" alt="image-20220222174821537"></p><ul><li><p><strong>appendonly</strong>：开启aof模式  </p></li><li><p><strong>appendfilename</strong>：aof的文件名字，最好别改！  </p></li><li><p><strong>appendfsync</strong>：追写策略  </p><ul><li>always：每次数据变更，就会立即记录到磁盘，性能较差，但数据完整性好  </li><li><strong>everysec****（默认）</strong>：默认设置，异步操作，每秒记录，如果一秒内宕机，会有数据丢失  </li><li>no：不追写  </li></ul></li><li><p><strong>no-appendfsync-on-rewrite</strong>：重写时是否运用Appendfsync追写策略；用默认no即可，保证数据安全性。  </p><p>AOF采用文件追加的方式，文件会越来越大，为了解决这个问题，增加了重写机制，redis会自动记录上一次AOF文件的大小，当AOF文件大小达到预先设定的大小时，redis就会启动AOF文件进行内容压缩，只保留可以恢复数据的最小指令集合   <strong>但是默认不打开</strong></p></li><li><p><strong>auto-aof-rewrite-percentage</strong>：如果AOF文件大小已经超过原来的100%，也就是一倍，才重写压缩  </p></li><li><p><strong>auto-aof-rewrite-min-size</strong>：如果AOF文件已经超过了64mb，才重写压缩  </p></li></ul><p><img src="/images/image-20220222180252446.png" alt="image-20220222180252446"></p><h2 id="4-AOF与RDB"><a href="#4-AOF与RDB" class="headerlink" title="4. AOF与RDB"></a>4. AOF与RDB</h2><ul><li>RDB：只用作后备用途，建议15分钟备份一次就好  </li><li>AOF  <ul><li>在最恶劣的情况下，也只丢失不超过2秒的数据，<strong>数据完整性比较高，但代价太大，会带来持续的IO</strong>  </li><li>对硬盘的大小要求也高，默认64mb太小了，企业级最少都是5G以上  </li></ul></li></ul><h1 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h1><p>事务命令</p><ol><li>multi——开启 </li><li>exec——执行  （对应commit）</li><li>discard——放弃</li></ol><p><img src="/images/image-20220222210923189.png" alt="image-20220222210923189"></p><p>=============================================================</p><p><img src="/images/image-20220222211154580.png" alt="image-20220222211154580"></p><ul><li>如果其中一句<strong>直接报错了</strong>，全部都取消了，恢复到原来的值（相当于报错了就不会提交了）（一颗老鼠屎）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; setlalala # 一句报错</span><br><span class="line">(error) ERR unknown command `setlalala`, with args beginning with:</span><br><span class="line">127.0.0.1:6379&gt; set k5 v5</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec # 队列中命令全部取消</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; keys * # 还是原来的值</span><br><span class="line">1) &quot;k2&quot;</span><br><span class="line">2) &quot;k3&quot;</span><br><span class="line">3) &quot;k1&quot;</span><br></pre></td></tr></table></figure><ul><li>如果有一个执行失败了<strong>（并不是编译的错，反而在提交前都没错，只是提交后发现执行出错）</strong>，别的依然执行，只有错的那个执行不了</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr k1 # 虽然v1不能++，但是加入队列并没有报错，类似java中的通过编译 </span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k5 v5</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (error) ERR value is not an integer or out of range # 真正执行的时候，报错</span><br><span class="line">2) OK # 成功</span><br><span class="line">3) OK # 成功</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;k5&quot;</span><br><span class="line">2) &quot;k1&quot;</span><br><span class="line">3) &quot;k3&quot;</span><br><span class="line">4) &quot;k2&quot;</span><br><span class="line">5) &quot;k4&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>watch</strong></li></ul><p>正常情况下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set in 100 # 收入100元</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set out 0 # 支出0元</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby in 20 # 收入-20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby out 20 # 支出+20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (integer) 80</span><br><span class="line">2) (integer) 20 # 结果，没问题！</span><br></pre></td></tr></table></figure><p>特殊情况，就是在exec之前，通过另一个窗口对被watch的键进行值得修改（就是一个并发场景），那么此时整个事务都会失效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch in # 监控收入in</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby in 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(nil) # 在exec之前，我开启了另一个窗口（线程），对监控的in做了修改，所以本次的事务将被打断（失效），类似于“乐观锁”</span><br></pre></td></tr></table></figure><h1 id="5-发布订阅"><a href="#5-发布订阅" class="headerlink" title="5.发布订阅"></a>5.发布订阅</h1><ul><li>subscribe    订阅</li><li>publish     推送</li></ul><p><img src="/images/image-20220222213407256.png" alt="image-20220222213407256"></p><h1 id="6-主从复制"><a href="#6-主从复制" class="headerlink" title="6. 主从复制"></a>6. 主从复制</h1><ul><li>配从不配主 ： 小弟选大哥，大哥不能选小弟</li><li>读写分离：主机写，从机读</li></ul><h2 id="1-相关特性"><a href="#1-相关特性" class="headerlink" title="1. 相关特性"></a>1. 相关特性</h2><h3 id="①"><a href="#①" class="headerlink" title="①"></a>①</h3><p>1.启动三台服务器，在一开始每台服务器的redis都是master</p><p><img src="/images/image-20220223140538117.png" alt="image-20220223140538117"></p><p>2.根据配从不配主，在101服务器上让他从属于100服务器。同时让102也从属于100</p><p><img src="/images/image-20220223141030130.png" alt="image-20220223141030130"></p><p>于是：</p><ul><li>可以通过从机得到主机的keys</li></ul><p><img src="/images/image-20220223142427238.png" alt="image-20220223142427238"></p><ul><li>主机的Keys变化立刻与从机同步</li></ul><p><img src="/images/image-20220223142610336.png" alt="image-20220223142610336"></p><ul><li>从机不能写操作</li></ul><p><img src="/images/image-20220223142648996.png" alt="image-20220223142648996"></p><ul><li><p>主机即便shutdown，从机依然是slave，而且显示主机已离线（通过info replication）</p></li><li><p>主机又启动，从机可以显示主机上线（通过info replication）</p></li><li><p>其中一个从机shudown ，然后重新启动的话，会重新变成默认的master（即不和之前的集群在一起了）</p></li></ul><h3 id="②"><a href="#②" class="headerlink" title="②"></a>②</h3><p>1.将101 slave于100, 102 slave 于101，形成“继承”的传递，效果：</p><p><img src="/images/image-20220223143628754.png" alt="image-20220223143628754"></p><p>此时他们的键，相当于从100传递给101又能传递给102</p><h2 id="2-复制原理"><a href="#2-复制原理" class="headerlink" title="2. 复制原理"></a>2. 复制原理</h2><p><img src="/images/image-20220223144837494.png" alt="image-20220223144837494"></p><ul><li><p><strong>全量复制</strong>：Slave<strong>初始化阶段</strong>，这时Slave需要将Master上的所有数据都复制一份slave接收到数据<br>文件后，存盘，并加载到内存中；（步骤1234）  </p></li><li><p><strong>增量复制</strong>：Slave<strong>初始化后</strong>，开始正常工作时主服务器发生的写操作同步到从服务器的过程；（步<br>骤56）  </p></li></ul><p><strong>Redis主从同步策略</strong>  </p><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步  </p><p>但是如果后续增量同步不成功，可以要求从机全量同步</p><h2 id="3-哨兵模式-Sentinel"><a href="#3-哨兵模式-Sentinel" class="headerlink" title="3. 哨兵模式 Sentinel"></a>3. 哨兵模式 Sentinel</h2><p><img src="/images/image-20220223151714763.png" alt="image-20220223151714763"></p><ul><li>缺点：</li></ul><p>由于所有的写操作都是在master上完成的，然后再同步到slave上，所以两台机器之间通信会有延迟  。</p><p>当系统很繁忙的时候，延迟问题会加重，slave机器数量增加，问题也会加重  </p><h1 id="7-Jedis"><a href="#7-Jedis" class="headerlink" title="7. Jedis"></a>7. Jedis</h1><p>1.连接Redis</p><p><img src="/images/image-20220223155343396.png" alt="image-20220223155343396"></p><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p><strong>其实跟前面的命令一样</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span></span>&#123;</span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.204.141&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">// string</span></span><br><span class="line">jedis.set(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;v1&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;v2&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k3&quot;</span>,<span class="string">&quot;v3&quot;</span>);</span><br><span class="line">    </span><br><span class="line">Set&lt;String&gt; set = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (set.iterator();iterator.hasNext();)&#123;</span><br><span class="line">String k = iterator.next();</span><br><span class="line">System.out.println(k+<span class="string">&quot;-&gt;&quot;</span>+jedis.get(k));</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">Boolean k2Exists = jedis.exists(<span class="string">&quot;k2&quot;</span>); <span class="comment">// 查看k2是否存在</span></span><br><span class="line">System.out.println(<span class="string">&quot;k2Exists = &quot;</span> + k2Exists);</span><br><span class="line">System.out.println( jedis.ttl(<span class="string">&quot;k1&quot;</span>) );<span class="comment">// 查看k1的过期时间</span></span><br><span class="line"></span><br><span class="line">jedis.mset(<span class="string">&quot;k4&quot;</span>,<span class="string">&quot;v4&quot;</span>,<span class="string">&quot;k5&quot;</span>,<span class="string">&quot;v5&quot;</span>);</span><br><span class="line">System.out.println( jedis.mget(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;k3&quot;</span>,<span class="string">&quot;k4&quot;</span>,<span class="string">&quot;k5&quot;</span>) );</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;--------------------------------------------------------&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span></span>&#123;</span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.204.141&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">// list</span></span><br><span class="line">jedis.lpush(<span class="string">&quot;list01&quot;</span>, <span class="string">&quot;l1&quot;</span>,<span class="string">&quot;l2&quot;</span>,<span class="string">&quot;l3&quot;</span>,<span class="string">&quot;l4&quot;</span>,<span class="string">&quot;l5&quot;</span>);</span><br><span class="line">List&lt;String&gt; list01 = jedis.lrange(<span class="string">&quot;list01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(String s : list01)&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125; </span><br><span class="line">  System.out.println(<span class="string">&quot;---------------------------------------------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">                       </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.204.141&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">jedis.sadd(<span class="string">&quot;order&quot;</span>,<span class="string">&quot;jd001&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;order&quot;</span>,<span class="string">&quot;jd002&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;order&quot;</span>,<span class="string">&quot;jd003&quot;</span>);</span><br><span class="line">    </span><br><span class="line">Set&lt;String&gt; order = jedis.smembers(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; order_iterator = order.iterator();</span><br><span class="line"><span class="keyword">while</span>(order_iterator.hasNext())&#123;</span><br><span class="line">String s = order_iterator.next();</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125; </span><br><span class="line">    jedis.srem(<span class="string">&quot;order&quot;</span>, <span class="string">&quot;jd002&quot;</span>);</span><br><span class="line">System.out.println( jedis.smembers(<span class="string">&quot;order&quot;</span>).size() );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testHash</span><span class="params">()</span></span>&#123;</span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.204.141&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">jedis.hset(<span class="string">&quot;user1&quot;</span>, <span class="string">&quot;username&quot;</span>,<span class="string">&quot;james&quot;</span>);</span><br><span class="line">System.out.println( jedis.hget(<span class="string">&quot;user1&quot;</span>, <span class="string">&quot;username&quot;</span>) );</span><br><span class="line">    </span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;boy&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;phone&quot;</span>, <span class="string">&quot;13590875543&quot;</span>);</span><br><span class="line">    </span><br><span class="line">jedis.hmset(<span class="string">&quot;user2&quot;</span>, map);</span><br><span class="line">List&lt;String&gt; list = jedis.hmget(<span class="string">&quot;user2&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;phone&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String s: list)&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testZset</span><span class="params">()</span></span>&#123;</span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.204.141&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    </span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">60d</span>, <span class="string">&quot;zs1&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">70d</span>, <span class="string">&quot;zs2&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">80d</span>, <span class="string">&quot;zs3&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">90d</span>, <span class="string">&quot;zs4&quot;</span>);</span><br><span class="line">    </span><br><span class="line">Set&lt;String&gt; zset01 = jedis.zrange(<span class="string">&quot;zset01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = zset01.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">String s = iterator.next();</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="8-Redis的分布式锁"><a href="#8-Redis的分布式锁" class="headerlink" title="8. Redis的分布式锁"></a>8. Redis的分布式锁</h1><h2 id="实现分布式锁的思路与缺陷"><a href="#实现分布式锁的思路与缺陷" class="headerlink" title="实现分布式锁的思路与缺陷"></a>实现分布式锁的思路与缺陷</h2><p>1.程序中的finnally并不是百分之百会执行</p><p>2.<strong>Redis是单线程的！！！！！！</strong> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/2021/11/20/%E9%9B%86%E5%90%88/"/>
      <url>/2021/11/20/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    &amp;---Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">*          &amp;---List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">*              &amp;---ArrayList、LinkedList、Vector</span><br><span class="line">*</span><br><span class="line">*          &amp;---Set接口：存储无序的、不可重复的数据   </span><br><span class="line">*              &amp;---HashSet、LinkedHashSet、TreeSet</span><br><span class="line">*</span><br><span class="line">*      &amp;---Map接口：双列集合，用来存储键值对   </span><br><span class="line">*          &amp;---HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-单列集合Collection"><a href="#1-单列集合Collection" class="headerlink" title="1.单列集合Collection"></a>1.单列集合Collection</h2><p><img src="/images/image-20211120184349639.png" alt="image-20211120184349639"></p><h2 id="2-双列集合Map"><a href="#2-双列集合Map" class="headerlink" title="2.双列集合Map"></a>2.双列集合Map</h2><p><img src="/images/image-20211120184431264.png" alt="image-20211120184431264"></p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><ul><li>Collection 接口是List、Set 和Queue 接口的父接口，该接口里定义的方法既可用于操作Set 集合，也可用于操作List 和Queue 集合。</li><li>JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。</li></ul><h2 id="Collection的常用方法"><a href="#Collection的常用方法" class="headerlink" title="Collection的常用方法"></a>Collection的常用方法</h2><ul><li>添加<br><strong>add</strong>(Object obj)<br><strong>addAll</strong>(Collection coll)</li></ul><p>因为add()存入的元素都是对象，所以如果存入数字，其实是存在一个自动装箱的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">      coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">      coll.add(<span class="number">123</span>);  <span class="comment">//自动装箱</span></span><br><span class="line">      coll.add(<span class="keyword">new</span> Date());</span><br><span class="line">      System.out.println(coll.get(<span class="number">1</span>).getClass());</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211128160027669.png" alt="image-20211128160027669"></p><p>addAll()是将一个集合存到另一个集合中，存入过后，例如原来的集合大小是3，另一个集合的大小是2，那么将一个集合存入另一个集合的大小就变为了5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">      coll1.add(<span class="number">456</span>);</span><br><span class="line">      coll1.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">      coll.addAll(coll1);</span><br><span class="line">      System.out.println(coll.size());    <span class="comment">//5</span></span><br></pre></td></tr></table></figure><ul><li>获取有效元素的个数<br>int <strong>size</strong>()</li><li>清空集合<br>void <strong>clear</strong>()</li><li>是否是空集合<br>boolean <strong>isEmpty</strong>()</li><li>是否包含某个元素<br>boolean <strong>contains</strong>(Object obj)：是通过元素的equals方法来判断是否是同一个对象<br>boolean <strong>containsAll</strong>(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。<br><img src="/images/image-20211128160623253.png" alt="image-20211128160623253"></li></ul><p><strong>由此，如果对对象的equals()方法进行重写，那么就可以更改contains()的判断标准</strong>。如果对自己创建的类不重写equals方法，那么他就只有向上去找equals方法直到找到的是Object的equals方法。而Object的equals方法实际上就是 ==。==的话如果对象地址不一样，即便数值一样也会返回false咯</p><p><img src="/images/image-20211128163255163.png" alt="image-20211128163255163"></p><ul><li><p>删除<br>boolean <strong>remove</strong>(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。<strong>只会删除找到的第一个元素</strong><br>boolean <strong>removeAll</strong>(Collection coll)：取当前集合的差集</p></li><li><p>取两个集合的交集<br>boolean **retainAll(**Collection c)：把交集的结果存在当前集合中，影响的是调用的那个集合而不影响c</p></li><li><p>集合是否相等<br>boolean <strong>equals</strong>(Object obj)</p><p>​    这里要想返回true,需要里面的元素相同且顺序相同</p></li><li><p>转成对象数组<br>Object[] <strong>toArray</strong>()</p></li><li><p>获取集合对象的哈希值<br><strong>hashCode</strong>()</p></li><li><p>遍历<br><strong>iterator</strong>()：返回迭代器对象，用于集合遍历</p></li></ul><h2 id="数组转集合注意事项"><a href="#数组转集合注意事项" class="headerlink" title="数组转集合注意事项"></a>数组转集合注意事项</h2><p><strong>Arrays.asList()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">      System.out.println(list.size());</span><br><span class="line"></span><br><span class="line">      List arr1 = Arrays.asList(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">      System.out.println(arr1.size());<span class="comment">//[123, 456]</span></span><br><span class="line"></span><br><span class="line">      List arr2 = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">      System.out.println(arr2.size());<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">      List arr3 = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">      System.out.println(arr3.size());<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>对于普通数据类型的数组，会把他识别为一个整体。但是如果是包装类等类对象数组，在数size时就会分开来计算了</p><h1 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h1><p><img src="/images/image-20211128173758442.png" alt="image-20211128173758442"></p><p>刚创建迭代器时，其指针的位置并非集合的第一个元素，而是在元素之上的一个位置</p><p>在遍历过程中，也注意避免如下错误的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(coll.iterator().hasNext())&#123;</span><br><span class="line">            System.out.println(coll.iterator().next());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>因为这样每次都会新得到一个迭代器，其游标指向第一个元素的前一个位置，那么输出的就一直都是第一个元素</p><p>所以，如果要用迭代器去遍历两次集合，那么第二次遍历之前必须重新得到一次迭代器，否则就遍历不到（因为此时用的是旧迭代器，指针就指向了最后一个元素）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String next =  iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">        iterator = list.iterator();<span class="comment">//必须重新获取迭代器</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String next =  iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>迭代器中有一个remove()方法，可以在遍历过程中移除集合中的元素（是真的把集合中的那个元素给删掉了），但是要注意用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">//iterator.remove();   //不能在获取next()之前调用remove,这很好理解，因为在迭代一开始，指针没有指向任何元素，此时remove就会报错</span></span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;<span class="comment">//把&quot;Tom&quot;写在前面相比于obj.equals(&quot;Tom&quot;)有更强的健壮性。因为如果obj是空的，那么后者就会抛空指针异常而前者没事而且也能正确地进行判断</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外，遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。</p><p>foreach循环地本质就是调用了迭代器。</p><h1 id="Collection子接口List"><a href="#Collection子接口List" class="headerlink" title="Collection子接口List"></a>Collection子接口List</h1><ul><li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</li><li><strong>List集合类中元素有序、且可重复</strong>，集合中的每个元素都有其对应的顺序索引。</li><li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</li></ul><h2 id="ArrayList底层"><a href="#ArrayList底层" class="headerlink" title="ArrayList底层"></a>ArrayList底层</h2><ul><li><p>ArrayList是可以add null的</p></li><li><p>线程不安全</p></li><li><p>如果使用的是ArrayList()无参构造器，则一开始elementData的容量为0，第一次添加，会自动扩容到10，后面如果满了要再扩容就会扩容到当前大小的1.5倍；如果是有参构造器，ArrayList(5)，就分配5个容量，如果满了就扩到当前大小的1.5倍，以此类推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//  底层Object[] elementData初始化为&#123;&#125;.并没有创建长度为10的数组</span></span><br><span class="line"> </span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//  第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line">.........      <span class="comment">//省略诸多添加操作</span></span><br><span class="line">list.add(<span class="number">11</span>);<span class="comment">//  如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</span></span><br></pre></td></tr></table></figure></li><li><p>建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</p></li><li><p>jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</p></li></ul><h2 id="LinkedList与Vector"><a href="#LinkedList与Vector" class="headerlink" title="LinkedList与Vector"></a>LinkedList与Vector</h2><p><strong>LinkedList</strong></p><ul><li><strong>对于频繁的插入或删除元素的操作</strong>，建议使用LinkedList类，效率较高</li><li>因为LinkedList实现了Queue也实现了List，所以在把他当Queue时的存取方法分别是offer()和poll()，当List使用时是add()和get()</li><li>LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* <span class="number">3.</span>LinkedList的源码分析：</span><br><span class="line">         LinkedList list = <span class="keyword">new</span> LinkedList(); /内部声明了Node类型的first和last属性，默认值为<span class="keyword">null</span></span><br><span class="line">         list.add(<span class="number">123</span>);<span class="comment">//将123封装到Node中，创建了Node对象。</span></span><br><span class="line">  </span><br><span class="line">         <span class="comment">//Node定义为：LinkedList的双向链表</span></span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">              E item;</span><br><span class="line">               Node&lt;E&gt; next;</span><br><span class="line">               Node&lt;E&gt; prev;</span><br><span class="line">  </span><br><span class="line">              Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">              <span class="keyword">this</span>.item = element;</span><br><span class="line">              <span class="keyword">this</span>.next = next;     <span class="comment">//next变量记录下一个元素的位置</span></span><br><span class="line">              <span class="keyword">this</span>.prev = prev;     <span class="comment">//prev变量记录前一个元素的位置</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p><strong>Vector</strong></p><ul><li>Vector是作为ArrayList的缺省选择，因为他总是<strong>比ArrayList慢</strong>，他只是<strong>线程安全</strong></li><li><strong>区别于ArrayList的创建与扩容机制(两方面)</strong><ul><li>通过Vector()构造器创建对象时，底层创建长度为10的数组     </li><li> 在扩容方面，满后默认扩容为原来的数组长度的2倍</li></ul></li></ul><h2 id="List常用方法"><a href="#List常用方法" class="headerlink" title="List常用方法"></a>List常用方法</h2><ul><li>void <strong>add</strong>(int index, Object e): 在index位置插入元素e</li><li>boolean <strong>addAll</strong>(int index, Collection e): 从index位置开始将e中的所有元素添加进来</li></ul><p>以上两个方法，如果不写index参数，那就使用的是Collection接口的add和addAll方法，即在集合的最后添加单个元素或添加另一个集合</p><ul><li><p>Object <strong>get</strong>(int index): 获取指定index位置的元素</p></li><li><p>int <strong>indexOf</strong>(Object obj): 返回obj在集合中首次出现的位置。如果不存在，返回-1</p></li><li><p>int <strong>lastIndexOf</strong>(Object obj): 返回obj在当前集合中末次出现的位置，如果不存在，返回-1</p></li><li><p>remove()</p><ul><li><p>Object <strong>remove</strong>(int index): 移除指定index位置的元素，<strong>并返回此元素</strong></p></li><li><p>Boolean <strong>remove</strong>(Object o): 移除指定对象。</p><p>关于remove要注意的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">      list.add(<span class="number">1</span>);</span><br><span class="line">      list.add(<span class="number">2</span>);</span><br><span class="line">      list.add(<span class="number">3</span>);</span><br><span class="line">list.remove(<span class="number">2</span>);<span class="comment">//如果只是放入一个整型进去，在这里就不会自动装箱了，那么就会把2识别为Index，从而把数字3给删了</span></span><br><span class="line">list.remove(<span class="keyword">new</span> Integer(<span class="number">2</span>));<span class="comment">//如果想删2，在这里就要手动装箱，他才会去找这个对象把他删掉</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Object <strong>set</strong>(int index, Object e): 设置指定index位置的元素为e</p></li><li><p>List <strong>subList</strong>(int fromIndex, int toIndex): 返回从fromIndex到toIndex位置的子集合</p></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><em>比较ArrayList、LinkedList、Vector三者的异同？（概括版）</em></p><p><strong>相同点：</strong></p><p>三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据</p><p><strong>不同点：</strong></p><ul><li>ArrayList：作为List接口的主要实现类；<strong>线程不安全，效率高</strong>；底层使用Object[] elementData存储</li></ul><ul><li><pre><code>         LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储。**线程不安全**</code></pre></li><li><pre><code>         Vector：作为List接口的古老实现类；**线程安全的，效率低**；底层使用Object[] elementData存储</code></pre></li></ul><p>*请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?*（细节版）</p><ul><li> ArrayList和LinkedList的异同二者都线程<strong>不安全但是效率高</strong>；Vector线程安全但是<strong>效率低</strong></li><li> ArrayList是实现了基于<strong>动态数组</strong>的数据结构Object[ ] elementData，LinkedList基于<strong>链表</strong></li><li> 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针</li><li> 对于新增和删除操作add(特指插入)和remove，LinkedList占优势，因为ArrayList要移动数据。</li></ul><ul><li><strong>Vector和ArrayList</strong>几乎是完全相同的。唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下使用ArrayList而不是Vector,因为<strong>同步完全可以由程序员自己来控制</strong>。<strong>Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍</strong>。<strong>调用无参构造器时</strong>，ArratyList的elementData<strong>并没有首先就给了10的空间大小</strong>，而是在添加元素时才扩容为10；Vector调用无参构造器就就<strong>直接创建了大小为10的数组</strong>（类比懒汉和饿汉）。Vector还有一个子类Stack。</li></ul><h1 id="Collection子接口Set"><a href="#Collection子接口Set" class="headerlink" title="Collection子接口Set"></a>Collection子接口Set</h1><ul><li><p>不允许重复，最多一个Null</p></li><li><p>Set其实也是键值对的存储形式[Key,Value]，只是在底层，Key就是输入的内容，<strong>而每一个Value都固定好了的是一个常量对象PRESENT（这个常量没有什么意义，就是起到一个占位的目的，就是为了使用到HashMap所以需要安排键值对）</strong>，这也就很好理解为什么HashSet的底层时HashMap了</p><p><img src="/images/image-20211129165805170.png" alt="image-20211129165805170"></p></li></ul><p><img src="/images/image-20211129170011296.png" alt="image-20211129170011296"></p><ul><li><p><strong>Set 判断两个对象是否相同不是使用 <code>==</code> 运算符，而是根据<code>equals()</code>方法</strong></p><p>所以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">&quot;邓涵文&quot;</span>));<span class="comment">//可以</span></span><br><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">&quot;邓涵文&quot;</span>));<span class="comment">//虽然是创建了新的对象，但是由于是用equals来比较，所以就加不进去了</span></span><br></pre></td></tr></table></figure></li><li><p>常用实现类</p><ul><li>HashSet：Set接口的主要实现类；<strong>线程不安全</strong>；可以存储null值</li><li>LinkedHashSet：HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</li><li>TreeSet：可以按照添加对象的指定属性，进行排序。</li></ul></li><li><p>注意！</p><p>不论是Map还是Set，对于Java自己定义的类型例如String，Integer存入集合中时，是按值传递的；而传入自定义的类例如Person，User是按引用传递的，所以会出现以下的情况</p><p>*<strong>基础类型按值传递</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; strings = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      String s = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">      strings.add(s);</span><br><span class="line">      s = <span class="string">&quot;~~&quot;</span>;</span><br><span class="line">      System.out.println(strings);<span class="comment">//最终的输出是nihao</span></span><br></pre></td></tr></table></figure><p><strong>而自定义类型按引用传递</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Person&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">       sets.add(person);</span><br><span class="line">       person.name = <span class="string">&quot;BB&quot;</span>;</span><br><span class="line">       System.out.println(sets);<span class="comment">//输出[Person&#123;id=1, name=&#x27;BB&#x27;&#125;]</span></span><br></pre></td></tr></table></figure><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ul><li>底层是HashMap（直接Debug进HashSet的构造方法就看得到）更具体一点，是数组加链表的结构。</li></ul><p><img src="/images/image-20211129165536874.png" alt="image-20211129165536874"></p><ul><li><p>无序，无索引（这个索引是指不能通过0，1，2等等来找元素。Set的索引是哈希值），不允许重复，最多一个Null，线程不安全</p></li><li><p>HashSet 集合判断两个元素相等的标准：两个对象通过<code>hashCode()</code> 方法比较相等（实际上是通过hash值比较），并且两个对象的<code>equals()</code>方法返回值也相等。</p></li></ul><p><strong>怎么理解？</strong></p><h3 id="添加步骤"><a href="#添加步骤" class="headerlink" title="添加步骤"></a>添加步骤</h3><p><strong>首先要注意一点：hash值并不直接等于hashcode，hash值是经过处理的hashcode</strong>（处理的目的是为了减少冲突）</p><p>虽然不直接等于，但是二者有映射关系，所以两个对象的hashcode不等，hash值自然也就不等</p><p><img src="/images/image-20211129170637603.png" alt="image-20211129170637603"></p><p><img src="/images/image-20211129171131901.png" alt="image-20211129171131901"></p><p>可以看到添加元素用来判断的是hash值而不是hashcode()直接返回的值</p><p>其实在向HashSet中添加元素之前，</p><p>首先将会计算添加元素的hash值来决定他放在存储数据表table的哪个位置，如果那个位置上有其他元素了，就会通过比较hash值看二者是否相等，如果哈希值不相等，就直接添加成功，如果hash值相等，那就得就通过<code>equals()</code>来比较二者是否相等，相等的话就加不进去，不相等的话就以链表形式挂在那个位子上<strong>（注意指向方向是老元素指向新元素）</strong></p><p><img src="/images/image-20211129161809410.png" alt="image-20211129161809410"></p><p>那么举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">      set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">      set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">      Iterator iterator = set.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">          System.out.println(iterator.next());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>对于这段代码，如果在User类中<strong>不重写<code>hashcode()</code>方法</strong>，由于两者的hash值不一样，所以存的位置也就不一样，那么他们就能存入这个HashSet</p><p><img src="/images/image-20211129162137173.png" alt="image-20211129162137173"></p><p>但是呢，**如果只重写<code>hashcode()</code>而不重写<code>equals()</code>**，那么两个对象用的其实就是Object的<code>equals()</code>方法也就是<code>==</code>，而因为他俩不是同一对象，所以也可以存入，只不过是挂在同一个位置上</p><p><img src="/images/image-20211129162349570.png" alt="image-20211129162349570"></p><p>只有当同时重写了<code>hashcode()</code>和<code>equals()</code>方法，底层才会因为他们在放在同一位置，而equals结果又是true，才会导致添加失败</p><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><ul><li>与之前的ArrayList的创建初始情况相同，是类似于懒汉式的，如果只是调用空参构造器，就只是创建了一个空Map</li></ul><p><img src="/images/image-20211129172640384.png" alt="image-20211129172640384"></p><ul><li><p>在第一次添加时，table就会扩容至16。但是当表中装的数量达到threshold（12）时，会继续扩容。一般加载因子时0.75，即16*0.75=12</p></li><li><p>到达临界值12时就会两倍两倍地扩，扩到32，但下次的临界值也就是32*0.75=24.</p></li><li><p><strong>只有当链表上（指的是从头节点开始数而不是被指向的第一个开始数）的元素个数超过8（等于8时没反应）且table到达64才会红黑树化</strong>。若一个表中的只是一个节点链表长度（从头节点开始数）超过8（等于8时不扩），只会选择扩容table（还是乘2）而不是树化。树化是在链表上树化而不是在整个table上树化</p></li><li><p>如果一个hashset，通过改对象的hashcode让他们堆在的一个节点上形成链表，那么。当链表长度超过8（到达9），table扩容至32，超过9（到达10），table扩容至64，超过10（到达11），table不扩容，链表变成treenode（树化）</p></li></ul><p><strong>代码验证：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Set set = new HashSet();</span><br><span class="line">      set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">      set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">      set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">      set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">      set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">      set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">      set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">      set.add(new User(&quot;Tom&quot;,12));</span><br><span class="line">      for (int i = 0; i &lt; 24; i++) &#123;</span><br><span class="line">          set.add(i);</span><br><span class="line">      &#125;</span><br><span class="line">      set.add(new User(&quot;Tom&quot;,12));//链表上增加到第九个节点后才会树化</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211129173659291.png" alt="image-20211129173659291"></p><p>table大小为64，包括头节点链表上有8个节点时一切正常</p><p><img src="/images/image-20211129173928148.png" alt="image-20211129173928148"></p><p>当在链表上添加了第九个元素后，可以看到，原来的Node就已经变为了TreeNode，说明已进行了树化</p><h3 id="关于hashCode-和equals-的重写"><a href="#关于hashCode-和equals-的重写" class="headerlink" title="关于hashCode()和equals()的重写"></a>关于hashCode()和equals()的重写</h3><ul><li><p>复写<code>equals</code>方法的时候一般都需要同时复写<code>hashCode</code>方法。</p></li><li><p>向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类要重写hashCode()和equals()</p></li><li><p>为什么IDEA里自动重写的hashCode方法有31这个数字？（了解）</p><ul><li>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。<strong>（减少冲突）</strong></li><li>并且31只占用5bits,相乘造成数据溢出的概率较小。</li><li>31可以由i<em>31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。*<em>（提高算法效率）</em></em></li><li>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！**(减少冲突)**</li></ul></li></ul><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ul><li><p>LinkedHashSet是HashSet的子类</p></li><li><p>LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，<strong>这使得元素看起来是以插入顺序保存的。</strong></p><p>所以区别与HashSet，<strong>其输出是按保存顺序输出的</strong></p></li><li><p>LinkedHashSet插入性能略低于HashSet，但在迭代访问Set 里的全部元素时有很好的性能。</p></li><li><p>LinkedHashSet不允许集合元素重复。</p></li></ul><p><img src="/images/image-20211130105954891.png" alt="image-20211130105954891"></p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul><li><p><strong>不允许重复，有序（这个有序不是指输进去的顺序就等于输出的顺序，而是元素大小有序）</strong>，查询速度比List快</p></li><li><p>TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。</p></li><li><p>TreeSet底层使用<strong>红黑树</strong>结构存储数据</p></li><li><p>TreeSet两种排序方法：<strong>自然排序（放入的类实现Comparable接口）和定制排序（自己写Comparator传入TreeSet的构造器）</strong>。默认情况下，TreeSet采用自然排序</p></li><li><p>自然排序：TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列。</p></li><li><p>如果试图把一个对象添加到TreeSet时，<strong>则该对象的类必须实现Comparable 接口</strong>，否则会报错。实现Comparable 的类必须实现compareTo(Object obj)方法，两个对象即通过compareTo(Object obj)方法的返回值来比较大小。很多包装类都是实现了Comparable的</p></li><li><p><strong>因为只有相同类的两个实例才会比较大小，所以向TreeSet中添加的应该是同一个类的对象</strong>。</p></li><li><p>对于TreeSet而言，它<strong>判断两个对象是否相等的唯一标准</strong>是：两个对象通过compareTo(Object obj)方法比较返回值。<strong>（不再是equals了！！！！）</strong></p></li><li><p>向TreeSet中添加元素时，<strong>只有第一个</strong>元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。</p></li></ul><h3 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h3><p>如果存入的对象所属的类不想去实现Comparable接口，那么也可以用定制排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Comparator com = <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="comment">//按照年龄从小到大排列</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                    User u1 = (User)o1;</span><br><span class="line">                    User u2 = (User)o2;</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        TreeSet set = <span class="keyword">new</span> TreeSet(com);<span class="comment">//此时树中的排序标准就是按这个Comparator所规定的比较方式了</span></span><br></pre></td></tr></table></figure><p>所以总结一下</p><ul><li>自然排序中，比较两个对象是否相同的标准为：compareTo()返回0。<strong>不再是equals()</strong></li><li>定制排序中，比较两个对象是否相同的标准为：compare()返回0。**不再是equals()**，并且，此时如果还是在类中实现了Comparable接口又重写了compareTo方法也没用了，他只会以Comparator的compare方法为唯一标准</li></ul><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><p>1.<em>在List内去除重复数字值，要求尽量简单</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">duplicateList</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">       HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">       set.addAll(list);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(set);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>2.已知已重写了equals()和hashCode()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">       Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">       Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line"><span class="comment">//要知道这两个对象是以1001,AA,1002,BB的hashCode()得到的hash值存到相应位置上的</span></span><br><span class="line">       set.add(p1);</span><br><span class="line">       set.add(p2);</span><br><span class="line">       System.out.println(set);</span><br><span class="line"></span><br><span class="line">       p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">       set.remove(p1);<span class="comment">//以CC去set里找equals的对象，自然找不到，所以这一步的移除是失败的</span></span><br><span class="line">       System.out.println(set);</span><br><span class="line">       set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>));<span class="comment">//以1001，CC的Hash值去找位子，所以这并不会与p1冲突，因为即使p1目前是1001,CC。但他的位置是以1001，AA算出来的，所以，连哈希冲突都没遇到，就别提用equals来判断两个对象是否相等了</span></span><br><span class="line">       System.out.println(set);</span><br><span class="line">       set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>));<span class="comment">//这次确实在1001AA的位置发生哈希冲突了，可是当两个对象进行equals，此时P1是1001CC，而要放入的是1001AA，equals是通过的，所以就把新的这个1001AA挂在P1的链s</span></span><br><span class="line">       System.out.println(set);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><img src="/images/image-20211222175035609.png" alt="image-20211222175035609"></p><ul><li>HashMap:Map的主要实现类，无序；<strong>线程不安全，效率高</strong>；存储的key<strong>可以是null</strong>。因为hashset的底层就是hashmap，所以前面也提过，其底层就是数组+链表+红黑树<ul><li>LinkedHashMap:保证在遍历map元素时，可以<strong>按照添加的顺序实现遍历</strong>。对于频繁的遍历操作，此类执行效率高于HashMap。</li></ul></li></ul><ul><li><pre><code>         TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑**key的自然排序或定制排序**，底层使用红黑树</code></pre></li><li><pre><code>      Hashtable:**线程安全，效率低；存储的key和value都不能是Null**         - Properties:常用来处理配置文件。key和value都是**String类型**</code></pre></li></ul><h2 id="Map结构"><a href="#Map结构" class="headerlink" title="Map结构"></a>Map结构</h2><ul><li>   Map中的key:<strong>无序、不可重复</strong>，其实是使用Set存储所有的key  —&gt; key所在的类要重写equals()和hashCode() （这个是以HashMap为例说的，如果是TreeMap，那就又会涉及到自然排序和定制排序的compareTo()和compare()）</li><li>   Map中的value:<strong>无序、可重复</strong>，使用Collection存储所有的value —&gt;value所在的类要重写equals()  （这是服务于containsKey()）</li><li>   一个键值对：key-value构成了一个Entry对象。所以其实每次往map中put都是在存入Entry</li><li>   Map中的entry:无序的、不可重复的，使用Set存储所有的entry</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>Set的底层就是HashMap，所以扩容机制在Set中已经写了</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JavaSE </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础</title>
      <link href="/2021/11/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/11/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="关于多线程"><a href="#关于多线程" class="headerlink" title="关于多线程"></a>关于多线程</h1><ul><li><p><strong>Java应用程序的线程</strong></p><p>一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程</p></li><li><p><strong>多线程的优点</strong></p><ol><li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验</li><li>提高计算机系统CPU的利用率</li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li></ol></li><li><p><strong>需要多线程的时机</strong></p><ol><li>程序需要同时执行两个或多个任务</li><li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等</li><li>需要一些后台运行的程序时</li></ol></li></ul><h1 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h1><h2 id="1-关于Thread类"><a href="#1-关于Thread类" class="headerlink" title="1.关于Thread类"></a>1.关于Thread类</h2><p>每个线程都是通过某特定的Thread对象的run()方法来完成操作的。但即便如此，在启动线程时是调用的Thread对象的start()方法而非run()。</p><p><strong>如何理解？</strong></p><p>虽然线程的业务逻辑都写在run()里，但如果直接调用run()，其实就没有创建线程，这就跟普通的通过对象调用普通方法没有区别，可以通过使用getThreadName()发现，如果是使用run()方法来“启动线程”，run()中的输出的线程名依然是main，这就说明run()方法也跑在了main主线程里，并没有多创建一个新线程。调用start()方法的核心在于调用本地方法start0()</p><p><img src="/images/image-20211118142140469.png" alt="image-20211118142140469"></p><p>start0()是一个本地(native)方法，线程是由他创建的，然后才会去执行run()方法里的业务逻辑</p><p>其中，通过Thread对象的start()方法后底层执行的操作顺序是：</p><p>①：启动当前线程</p><p>②：调用当前线程的run()方法</p><h2 id="2-创建线程的四种方式"><a href="#2-创建线程的四种方式" class="headerlink" title="2.创建线程的四种方式"></a>2.创建线程的四种方式</h2><p>创建线程4种方法，一是通过继承Thread类，二是实现Runnable接口，三是实现Callable，四是使用线程池。线程池的使用将在后面再说</p><p><strong>因为Java规定单继承，</strong></p><p><strong>另外，实现接口更适合处理多个线程共享数据的情况</strong></p><p>所以一般不使用方式一</p><h3 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">//重写Thread类的run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Thread类的子对象</span></span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//t1.start()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码中被注释掉的t1.start：</p><p>​        如果想再开启一个线程并不能用这种方法来启动。<img src="/images/image-20211118142207917.png" alt="image-20211118142207917"></p><p>通过看源码可知如果线程状态不等于0，就会报错。如果要新创建一个线程执行业务逻辑，需要再新new 一个t2对象，再start()。</p><h3 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h3><p>因为Runnable是函数式接口，根据Java8的特性，它可以转换为lamda表达式，由此有多种调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种，正常实现Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;这是方式一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        创建实现类的对象</span><br><span class="line">         MThread m1 = <span class="keyword">new</span> MThread();</span><br><span class="line">        将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(m1);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种，lamada</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是方式二&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;线程二&quot;</span>).start</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>为什么把Runable对象传入Thread()中就能调用到传入对象的run()方法？</strong></p><p>根据源码，也和前文所描述一样，在Thread启动start()后会启动一个新线程后调用run()方法。</p><p><img src="/images/image-20211119093832014.png" alt="image-20211119093832014"></p><p>在使用run()方法时的这个target</p><p><img src="/images/image-20211119093908775.png" alt="image-20211119093908775"></p><p>实际上就是传入Thread的那个Runnable对象，所以它可以找到Runnable对象所实现的run()方法并执行</p><h3 id="方式三：实现Callable接口"><a href="#方式三：实现Callable接口" class="headerlink" title="方式三：实现Callable接口"></a>方式三：实现Callable接口</h3><p>相较于Runnable，用Callable创建多线程的方式相对强大</p><p>其原因在于</p><ul><li>call()可以有返回值的。</li></ul><ul><li><pre><code> call()可以抛出异常，被外面的操作捕获，获取异常的信息</code></pre></li><li><pre><code> Callable是支持泛型的</code></pre></li><li><pre><code> 需要借助FutureTask类，比如获取返回结果</code></pre></li></ul><p>关于实现Callable接口会使用到的FutureTask类</p><ul><li><p>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</p></li><li><p>FutrueTask是Futrue接口的唯一的实现类</p></li><li><p>FutureTask同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;<span class="comment">//这个返回值是可以被得到的，这是实现Runnable做不到的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();<span class="comment">//能放进Thread的原因在于FutureTask实现了Runnable接口</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            Integer sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为:&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而且这里要注意的是futureTask.get()是一个阻塞方法，如果线程任务没有执行完，他就会一直等待。所以总和的值在最后才输出而不是子线程和main线程同时执行造成输出结果出现在中间。<img src="/images/image-20211120101641278.png" alt="image-20211120101641278"></p><h2 id="3-关于yield-和join"><a href="#3-关于yield-和join" class="headerlink" title="3.关于yield()和join()"></a>3.关于yield()和join()</h2><p>首先要分清楚两个方法的宾语。yield是自己主动让出CPU执行权给其他<strong>相同优先级</strong>的线程，具体是谁并不知道。所以这就便于记忆他是个静态方法了，他的调用方法就可以是这几种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.yield();<span class="comment">//当然，因为this用作对实例的引用，main方法属于静态方法，静态方法是没有任何实例的，因此不能用this</span></span><br><span class="line"><span class="keyword">yield</span>();</span><br><span class="line">Thread.currentThread().yield();</span><br></pre></td></tr></table></figure><p>而join()是让自己进入阻塞，指定一个线程来占我的坑，直到他执行完毕才结束我的阻塞状态。所以要标明对方的名字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1.join()</span><br></pre></td></tr></table></figure><h2 id="4-关于线程优先级"><a href="#4-关于线程优先级" class="headerlink" title="4.关于线程优先级"></a>4.关于线程优先级</h2><p><img src="/images/image-20211118123652363.png" alt="image-20211118123652363"></p><p>线程的优先级等级</p><ul><li><p>MAX_PRIORITY：10</p></li><li><p>MIN _PRIORITY：1</p></li><li><p>NORM_PRIORITY：5 —&gt;默认优先级</p></li></ul><p>优先级所涉及的方法</p><ul><li><p>getPriority() ：返回线程优先值</p></li><li><p>setPriority(intnewPriority) ：改变线程的优先级</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1.setPriority(Thread.MAX_PRIORITY);<span class="comment">//设置优先级的例子</span></span><br></pre></td></tr></table></figure><p><strong>这里要注意的是</strong>：这里的优先级终究是个概率问题</p><p>确实高优先级的线程要抢占低优先级线程cpu的执行权。但是这只是从概率上讲，高优先级的线程大概率被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才会被执行。</p><h2 id="5-关于守护线程与用户线程"><a href="#5-关于守护线程与用户线程" class="headerlink" title="5.关于守护线程与用户线程"></a>5.关于守护线程与用户线程</h2><ul><li>守护线程(main不是守护线程)和用户线程的区别很小，守护线程是用于服务用户线程的。垃圾回收GC就是一个典型的守护线程</li><li>当想把一个线程设置为守护线程时，在.start()之前对该线程使用.setDaemon(true)即可将其置为守护线程</li><li>当JVM中的用户线程都结束，只剩守护线程时，JVM就会退出</li></ul><h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><p><img src="/images/image-20211119101152046.png" alt="image-20211119101152046"></p><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="1-用synchronized实现线程同步的两种方式"><a href="#1-用synchronized实现线程同步的两种方式" class="headerlink" title="1.用synchronized实现线程同步的两种方式"></a>1.用synchronized实现线程同步的两种方式</h2><h3 id="方式一：同步代码块"><a href="#方式一：同步代码块" class="headerlink" title="方式一：同步代码块"></a>方式一：同步代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Windows1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Object obj = new Object();~~~</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"> <span class="comment">//synchronized (new Object)！！！</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//此时的this:唯一的windows1的对象 //方式二:synchronized (obj) &#123;</span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:卖票，票号为: &quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意三个点：</strong></p><p>1.synchronized所包围的范围是要对共享资源做操作的范围</p><p>2.synchronized()中的参数没有过多要求，只要是个对象就行，因为这个对象只是充当一个锁</p><p>3.要实现同步问题，<strong>各个线程用的锁必须是同一个</strong>。怎么理解？</p><p>如果把obj的声明放到了代码中注释~~~的位置，且将sychronized中的参数置为boj。这样的话，各个线程在执行run()方法内业务逻辑时都时新创建一个obj对象然后把他当作锁。那么很明显，四个线程执行run()就能创建4个锁出来，就保证不了线程安全。更有甚者，如果如注释！！！所示去写，那么就算是一个线程来执行，都能生成非常多不同的锁，就更别说实现线程安全了。</p><p>有关第三点，还需要多提一点</p><p>因为上面的代码用的是实现Runnable接口来做多线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Windows1 w = <span class="keyword">new</span> Windows1();</span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">      Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">      Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">      t2.start();</span><br><span class="line">      t1.start();</span><br><span class="line">      t3.start();</span><br></pre></td></tr></table></figure><p>实际上就只是创建了一个Runnable对象，所以能在run()方法外就只创建了一个obj对象，而后在run()方法里就能保证锁是同一个。可是，如果是用继承Thread类来实现同步呢？即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Windows2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">//或者synchronized(this)</span></span><br><span class="line">                <span class="comment">//业务逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样显然又会出问题，因为这种方式要创建多个线程就要new多个Thread对象出来start()。那么显然又会创建出多个obj作为锁（如果用this，那么也会有多个this，因为this所指的就是当前对象），就达到不了目的。所以如果要用这种方式来创建多线程，有两种解决方案</p><ul><li>用静态来解决因为创建多个Thread对象而造成的不同obj的问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><ul><li>使用.class，就能确保锁是同一个对象了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Windows2.class)&#123;&#125;</span><br></pre></td></tr></table></figure><p>所以综上一对比就能又一次看出Runnable对于共享数据的天然优势。</p><h3 id="方式二：同步方法"><a href="#方式二：同步方法" class="headerlink" title="方式二：同步方法"></a>方式二：同步方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Windows3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//可以循环也可以不循环</span></span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="comment">//同步监视器:this</span></span><br><span class="line"><span class="comment">//业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，与同步代码块相比，这种方法来实现同步，虽然没有写明锁是哪个对象，但是其实默认this为锁。那么这就要注意了，既然使用同步方法默认是this锁，在使用继承Thread来启动线程就要格外小心，正确的方法是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Windows4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//可以循环也可以不循环</span></span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="comment">//同步监视器:Windows4.class</span></span><br><span class="line"><span class="comment">//业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此时就能保证线程安全的问题了。因为要线程执行的代码被同一个锁锁住了，他是Window4.class</p><h2 id="2-实现懒汉式的线程安全（高效）"><a href="#2-实现懒汉式的线程安全（高效）" class="headerlink" title="2.实现懒汉式的线程安全（高效）"></a>2.实现懒汉式的线程安全（高效）</h2><p>因为普通的懒汉式是线程不安全的。如果同时有线程进来取对象，在判断if(instance==null)时会都通过，从而取了一个以上的对象，就达不到懒汉式的目的。所以可以通过线程同步实现其线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//方式一：效率稍差</span></span><br><span class="line"><span class="comment">//        synchronized (Bank.class) &#123;</span></span><br><span class="line"><span class="comment">//            if(instance == null)&#123;</span></span><br><span class="line"><span class="comment">//                instance = new Bank();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            return instance;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//方式二：效率较高</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Bank();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过加入锁，就能保证判断if (instance == null)时只有一个线程进行判断，从而达到目的。但是也可以进行一定的修改从而使程序更加高效。</p><p>对比方式一和方式二，无非使if (instance == null){}的位置进行了变更。但是要由此得到高效的思想。打个比方，有一个停车场，里面只有一个车位但是从外面是看不到这个车位的，此时的条件是这个车位已经有车了。</p><p>方式一：</p><p>一堆人准备停车，他们排着队进入停车场，当一个人进入后，进行判断，发现车位满了，然后离开，然后下一个人又进入停车场，发现车位满了…从而降低了效率</p><p>方式二：</p><p>如果停车场里的那个车位已经有人停车了，就会在停车场外立一个牌，上面标明了车位已满，那么此时外面的人看到这个牌就会直接散了，就不会一个一个排着队进入停车场去判断有没有车位了。</p><p>方式一和方式二的比较就说明了加锁的位置会影响程序的效率</p><h2 id="3-避免死锁"><a href="#3-避免死锁" class="headerlink" title="3.避免死锁"></a>3.避免死锁</h2><ul><li>专门的算法，原则</li><li>尽量减少同步资源的定义</li><li>尽量避免嵌套同步</li></ul><h2 id="4-用Lock实现同步"><a href="#4-用Lock实现同步" class="headerlink" title="4.用Lock实现同步"></a>4.用Lock实现同步</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Windows</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//这个括号里可以加参数true</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//调用锁定方法：lock()</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="comment">//业务逻辑</span></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//3.调用解锁方法：unlock()</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.在new ReetantLock()可加参数true，让锁变成一个公平锁，即线程就以先来后到的顺序去获取锁而不是线程A执行完后立马还能继续被他抢占到资源<strong>（但是我目前对公平锁的理解不够透彻</strong>）</p><p>2.对于同步的优先使用顺序</p><p>Lock  &gt; 同步代码块（已经进入了方法体，分配了相应资源）&gt; 同步方法（在方法体之外）</p><p><strong>sychronized和Lock有什么异同？</strong></p><p>相同：二者都可以解决线程安全问题     </p><p>不同： synchronized机制在执行完相应的同步代码以后，自动的释放锁   </p><p>​            Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()）（一般写在finnally里）</p><h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><h2 id="1-三个方法的组合使用实现通信"><a href="#1-三个方法的组合使用实现通信" class="headerlink" title="1.三个方法的组合使用实现通信"></a>1.三个方法的组合使用实现通信</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line">                <span class="keyword">if</span>(<span class="comment">/*终止条件*/</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//业务逻辑</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//使得调用如下wait()方法的线程进入阻塞状态</span></span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>wait():一旦执行此方法，当前线程就进入阻塞状态，并释放锁</li><li>notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个</li><li>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</li></ul><p>这里需要注意的是</p><p>1.wait()，notify()，notifyAll()三个方法必须使用在<strong>同步代码块或同步方法</strong>中。（使用Lock实现同步是不能用这三个方法的）<br>2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的锁。 否则，会出现IllegalMonitorStateException异常（例如，如果锁是别的对象，那么使用this.wait()等这三个方法就会报错）</p><h2 id="2-sleep-和wait-的异同"><a href="#2-sleep-和wait-的异同" class="headerlink" title="2.sleep()和wait()的异同"></a>2.sleep()和wait()的异同</h2><p><strong>相同点：</strong></p><p>一旦执行方法，都可以使得当前的线程进入阻塞状态。</p><p><strong>不同点：</strong></p><p>1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</p><p>2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</p><p>3）关于是否释放锁：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</p><h1 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h1><p>其实开发中，一般都不会自己手动去造线程，这样效率差，而是使用线程池来获取线程</p><p>普通方法造线程，经常创建并用完后经常销毁会非常浪费资源，影响性能</p><p>线程池是初始创建多个线程放在线程池里，使用时去线程池获取而使用完后放回线程池</p><p>其优势在于</p><ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>便于线程管理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;<span class="comment">//………………………………………………①</span></span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//        service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//        service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());  <span class="comment">//适合适用于Runable</span></span><br><span class="line"><span class="comment">//        service.submit(Callable callable);   //适合适用于Callable……………………………………………………②</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>关于注释①</strong></p><p>其实可以不做这一次强转，不做强转也可以正常运行程序。</p><p>做强转的目的是如被注释掉的代码，为线程池设置属性。因为ExecutorService是一个接口，接口中肯定没有那么多的变量去设置，所以也就调不了setCorePoolSize()，setKeepAliveTime()这些设置属性的方法。经过看源码可以发现，newFixedThreadPool()其实是造了一个ThreadPoolExecutor对象</p><p><img src="/images/image-20211120104518111.png" alt="image-20211120104518111"></p><p>这个ThreadPoolExecutor类是实现了ExecutorService接口的</p><p><img src="/images/image-20211120104643021.png" alt="image-20211120104643021"></p><p>强转过来后就可以使用他自己为线程池设置属性的方法了。</p><p><strong>关于注释②</strong></p><p><img src="/images/image-20211120104929820.png" alt="image-20211120104929820"></p><p><img src="/images/image-20211120104945676.png" alt="image-20211120104945676"></p><p>可以看到excute中只能放入Runnable对象（说一句废话，也就是可以放lamda表达式）</p><p><img src="/images/image-20211120105131291.png" alt="image-20211120105131291"></p><p>submit()方法适用于放Callable，而其实Callable也是个函数式接口，所以也可以用lamda表达式</p><p><img src="/images/image-20211120105320317.png" alt="image-20211120105320317"></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.文件上传与下载</title>
      <link href="/2021/11/11/3.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"/>
      <url>/2021/11/11/3.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传与下载"><a href="#文件上传与下载" class="headerlink" title="文件上传与下载"></a>文件上传与下载</h1><h2 id="i-上传"><a href="#i-上传" class="headerlink" title="i.上传"></a>i.上传</h2><p><strong>一般需要具备的四个步骤</strong></p><ul><li>要有一个form标签，且methon=post   （为什么不能是get?因为get请求有长度限制，上传文件一般都会超出该限制）</li><li>form标签的encType属性值必须为mutipart/form-data   (必须是这个值)</li><li>在form标签中使用input标签，其属性type =”file”来添加上传文件</li><li>编写服务器代码用于接收并处理上传的数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enctype=&quot;multipart/form-data&quot; //表示提交的数据以多段的形式拼接，然后以二进制流的形式发送给服务器</span><br></pre></td></tr></table></figure><h3 id="文件上传，HTTP的协议说明"><a href="#文件上传，HTTP的协议说明" class="headerlink" title="文件上传，HTTP的协议说明"></a>文件上传，HTTP的协议说明</h3><p><img src="/images/image-20211125165824975.png" alt="image-20211125165824975"></p><h3 id="commons-fileupload-jar-介绍以及使用"><a href="#commons-fileupload-jar-介绍以及使用" class="headerlink" title="commons-fileupload.jar 介绍以及使用"></a>commons-fileupload.jar 介绍以及使用</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>为了解析上传文件的数据，要用到第三方库。</p><p><img src="/images/image-20211125165844307.png" alt="image-20211125165844307"></p><p><img src="/images/image-20211125165855054.png" alt="image-20211125165855054"></p><h4 id="fileupload实现文件上传的代码实现"><a href="#fileupload实现文件上传的代码实现" class="headerlink" title="fileupload实现文件上传的代码实现"></a>fileupload实现文件上传的代码实现</h4><p>这里就是前面所说的文件上传的第四步，在服务器端编写代码来处理传来的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       <span class="comment">//首先要判断上传的数据是不是多段数据（只有多段数据才是文件上传的）</span></span><br><span class="line">       <span class="keyword">if</span>(ServletFileUpload.isMultipartContent(request))&#123;</span><br><span class="line">           <span class="comment">//创建FileItemFactory的实现类（因为他本身是个接口）</span></span><br><span class="line">           FileItemFactory fileItemFactory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">           <span class="comment">//创建用于解析上传数据的工具类ServletFileUpload</span></span><br><span class="line">           ServletFileUpload servletFileUpload = <span class="keyword">new</span> ServletFileUpload(fileItemFactory);</span><br><span class="line">           <span class="comment">//只需要用这个类进行解析，就能得到请求的表单项的每一项即FileItem</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               List&lt;FileItem&gt; list = servletFileUpload.parseRequest(request);</span><br><span class="line">               <span class="comment">//拿到了很多表单项，就可以循环遍历他们，用于判断他们是普通的类型，还是文件类型</span></span><br><span class="line">               <span class="keyword">for</span> (FileItem fileItem :list) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (fileItem.isFormField())&#123;<span class="comment">//如果为true那就说明是普通的表单项</span></span><br><span class="line">                       System.out.println(<span class="string">&quot;表单项的name属性值：&quot;</span>+ fileItem.getFieldName());</span><br><span class="line">                       <span class="comment">//这里设置UTF-8参数是为了避免中文出现的乱码问题</span></span><br><span class="line">                       System.out.println(<span class="string">&quot;表单项的value值&quot;</span> + fileItem.getString(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果是false那就说明现在这个表单项是上传的文件了</span></span><br><span class="line">                       System.out.println(<span class="string">&quot;表单项的name属性值：&quot;</span>+ fileItem.getFieldName());</span><br><span class="line">                       System.out.println(<span class="string">&quot;上传的文件名：&quot;</span>+ fileItem.getName());</span><br><span class="line"></span><br><span class="line">                       fileItem.write(<span class="keyword">new</span> File(<span class="string">&quot;f:\\&quot;</span> + fileItem.getName()));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里就是将客户的post请求的表单接收并进行了处理，将表单信息打印并将客户上传的文件保存在己方本地</p><p>这是客户所填信息：</p><p><img src="/images/image-20211125165905103.png" alt="image-20211125165905103"></p><p>服务器打印结果：</p><p><img src="/images/image-20211125165914241.png" alt="image-20211125165914241"></p><p>并且将上传的图片保存在了指定的路径中</p><p><img src="/images/image-20211125165925237.png" alt="image-20211125165925237"></p><h2 id="ii-下载"><a href="#ii-下载" class="headerlink" title="ii.下载"></a>ii.下载</h2><p><strong>整体步骤</strong></p><p><img src="/images/image-20211125165943955.png" alt="image-20211125165943955"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取要下载的文件名</span></span><br><span class="line">        String downloadFileName = <span class="string">&quot;image.jpg&quot;</span>;<span class="comment">//当然应该是可以不写死，然后通过传入的参数去判断要调哪个文件</span></span><br><span class="line">        <span class="comment">//2.因为需要ServletContext对象才可以读取要下载的文件内容，所以创建一个ServletContext对象</span></span><br><span class="line">        ServletContext servletContext = getServletContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.因为要在回传之前通过响应头告诉客户端返回数据的类型，所以要获取下载文件的类型</span></span><br><span class="line">        String mimeType = servletContext.getMimeType(<span class="string">&quot;/file/&quot;</span> + downloadFileName);</span><br><span class="line">        <span class="comment">//然后就可以回传数据类型的</span></span><br><span class="line">        response.setContentType(mimeType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.在回传之前还得告诉（使用响应头来告诉）客户端：“你即将收到的数据是用于下载的”</span></span><br><span class="line">        <span class="comment">//如果不进行交代使用方法这一步，经过实验，会默认把文件（这个实验用的是图片）显示在页面上</span></span><br><span class="line">        <span class="comment">//关于这几个参数</span></span><br><span class="line">        <span class="comment">//Content-Disposition这个响应头（键），意思是：收到的数据处理的方式  （方式就是后面跟的值）</span></span><br><span class="line">        <span class="comment">//attachment表示附件，就是告诉说这是要下载一个文件</span></span><br><span class="line">        <span class="comment">//filename表示下载的文件名(是下载下来的文件名的意思，可以随便指定，跟要下载的那个文件名无关，</span></span><br><span class="line">        <span class="comment">// 因为路径那之类的东西都是由下面输入流来指定的)</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment; filename=&quot;</span> + downloadFileName);<span class="comment">//~~~~~~~~~~</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        /斜杠在服务器端解析表示的地址是http://ip:port/工程名/ ，这映射到webapp目录下</span></span><br><span class="line"><span class="comment">        通过getResourseAsStream读取文件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//5.读取要下载的文件内容</span></span><br><span class="line">        InputStream inputStream = servletContext.getResourceAsStream(<span class="string">&quot;/file/&quot;</span> + downloadFileName);</span><br><span class="line">        <span class="comment">//获取响应的输出流,输出流的数据是给客户端的</span></span><br><span class="line">        ServletOutputStream outputStream = response.getOutputStream();</span><br><span class="line">        <span class="comment">//将输入流中的全部数据复制给输出流(就是这一步能让前面获取到的数据得到输出的)</span></span><br><span class="line">        IOUtils.copy(inputStream,outputStream);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>要注意的是，有关~~~注释的那一行，如果想指定下载文件名是中文的话不能直接把downloadFileName中的信息改成中文就罢了，如果是用chrome来下载，就会是乱码，其中的根本原因能从响应头中看到，就是编码不出来</p><p><img src="/images/image-20211125170005291.png" alt="image-20211125170005291"></p><p>如果想指定中文，就应该这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment; filename=&quot;</span>+ URLEncoder.encode(<span class="string">&quot;你好.jpg&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure><p>对于这个setHeader，我一开始以为是两个键值对，分别是Content-Disposition和filename。所以我做了个实验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment);</span></span><br><span class="line"><span class="string">response.setHeader(&quot;</span>filename=<span class="string">&quot;+ URLEncoder.encode(&quot;</span>你好.jpg<span class="string">&quot;,&quot;</span>UTF-<span class="number">8</span><span class="string">&quot;));</span></span><br></pre></td></tr></table></figure><p>但是这样其实是不行的，可以在网上查到，这个方法的在处理下载文件问题时的设置方式的标准形式就是</p><p><img src="/images/image-20211125170015258.png" alt="image-20211125170015258"></p><p>他并不是两组键值对</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.jsp学习笔记</title>
      <link href="/2021/11/10/2.jsp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/10/2.jsp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>是java的服务器页面</p><p>主要作用是代替Servlet程序回传Html页面的数据</p><p>（Servlet程序回传html页面数据的开发成本和维护成本都高）</p><h1 id="1-jsp的访问方式"><a href="#1-jsp的访问方式" class="headerlink" title="1.jsp的访问方式"></a>1.jsp的访问方式</h1><p><img src="/images/image-20211112145133829.png" alt="image-20211112145133829"></p><h1 id="2-jsp的本质"><a href="#2-jsp的本质" class="headerlink" title="2.jsp的本质"></a>2.jsp的本质</h1><p>*<strong>jsp页面本质上是servlet程序</strong></p><p>第一次访问jsp页面时，Tomcat服务器回把jsp翻译成为一个java源文件并将它编译，生成.class的字节码文件。而打开该java文件后看到的类直接继承了HttpJspBase类</p><p>HttpJspBase类继承了HttpServlet</p><p>被翻译出来的java源文件实际上也是通过HttpServletResponse的输出流回传html页面数据</p><p><img src="/images/image-20211112145148165.png" alt="image-20211112145148165"></p><h1 id="3-jsp语法"><a href="#3-jsp语法" class="headerlink" title="3.jsp语法"></a>3.jsp语法</h1><h2 id="1-头部page指令及属性"><a href="#1-头部page指令及属性" class="headerlink" title="1.头部page指令及属性"></a>1.头部page指令及属性</h2><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211112145200115.png" alt="image-20211112145200115"></p><p>关于第ii点，可以通过查看.java源文件得到证明</p><p><img src="/images/image-20211112145224101.png" alt="image-20211112145224101"></p><p>当把autoFlash设定为false并把buffer属性改小，若此时jsp页面的数据过多就会报如上的缓冲区溢出错误。所以，没事不要去改autoFlash和buffer属性。</p><p><img src="/images/image-20211112145237297.png" alt="image-20211112145237297"></p><p><strong>关于erropage的路径一定要注意</strong>。前面提到过，浏览器和服务器对于斜杠/的解析结果时不一样的。而jsp本质是servlet程序，所以erropage里若要写斜杠/打头，他标识的是hrrp://localhost:8080/工程路径/。<strong>这个路径的映射到IDEA代码的webapp目录下</strong></p><p><img src="/images/image-20211112145243412.png" alt="image-20211112145243412"></p><p>这三项一般都不会去改，就让他默认就好了</p><h2 id="2-jsp脚本"><a href="#2-jsp脚本" class="headerlink" title="2.jsp脚本"></a>2.jsp脚本</h2><h3 id="a-声明脚本（用的少）"><a href="#a-声明脚本（用的少）" class="headerlink" title="a.声明脚本（用的少）"></a>a.声明脚本（用的少）</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! 声明java代码 %&gt;</span><br></pre></td></tr></table></figure><p>作用：给jsp翻译出来的Java类定义属性和方法，甚至是静态代码块，内部类等等</p><p>他是放在<strong>jsp名_jsp类</strong>中的</p><p>例如：<img src="/images/image-20211112145258063.png" alt="image-20211112145258063"></p><p>在.java文件中可以查看到</p><p><img src="/images/image-20211112145308565.png" alt="image-20211112145308565"></p><h3 id="b-表达式脚本（较常用）"><a href="#b-表达式脚本（较常用）" class="headerlink" title="b.表达式脚本（较常用）"></a>b.表达式脚本（较常用）</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= 表达式 %&gt;</span><br></pre></td></tr></table></figure><p>作用：在jsp页面上输出数据。其输出方式本质上（即在.java文件 中是以out.print()来输出的）</p><p>就比如上例的map </p><p>如果在jsp上写&lt;%=map%&gt;，调用界面时显示的不是map这三个字母而是System.out.println(map)的结果。</p><p>概括起来就是，表达式脚本里可以写对象</p><p><strong>表达式脚本的特点</strong></p><p>1.所有表达式脚本都会被翻译到jsp对应的.java文件中的_jspService()方法中</p><p>2.都会作为out.write()的参数输出到页面上</p><p>3.由于所有表达式脚本都会被翻译到_jspService()中，所以__jspService()方法中的对象都可以直接使用</p><p>4.表达式脚本的末尾不能加分号;</p><p><strong>如何理解第三点？</strong></p><p>即便在jsp代码没有定义HttpServletRequest request，但是依然可以在jsp中写</p><p><img src="/images/image-20211112145319993.png" alt="image-20211112145319993"></p><p>然后在浏览器上用?加上参数，就可以在jsp页面上显示参数中username的值</p><p><strong>第四点的原因？</strong></p><p>表达式脚本的内容最终是一整个放到out.print()中，如果我在表达式参数中因为习惯加了一个;例如</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= map; %&gt;</span><br></pre></td></tr></table></figure><p>那他实际上就是out.print(map;)，妥妥的语法错误</p><h3 id="c-代码脚本"><a href="#c-代码脚本" class="headerlink" title="c.代码脚本"></a>c.代码脚本</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%  正常的java语句 %</span><br></pre></td></tr></table></figure><p>作用：可以在Jsp中编写需要的功能。</p><p>*代码脚本中的内容就是纯天然的不加别的东西地放在_jspService()里，它并不像表达式脚本一样，翻译后的内容是由out.print()包起来的</p><p>*能写的例如有if语句，for循环</p><p>*要注意如果是写方法啥的要用声明脚本</p><p>*虽然很明显，但是还是要区分以下，因为表达式脚本是放在out.print()中输出的，out是作为response存在的，所以他输出的内容是显示在浏览器页面中的。但是在代码脚本中，习惯性还是写的System.out.println()，所以输出的内容是在控制台并非页面上</p><p>*和表达式脚本相似，因为大家都是被翻译后放到_jspService()中，所以_jspService()方法中传进来的参数，定义过的变量啥的都能直接用</p><p><strong>代码脚本特点：</strong></p><p>1.被翻译后都放在_jspService()中</p><p>2.由1，_jspService()中的现有对象都可以直接使用</p><p>3.代码脚本可以由多个代码脚本块组合完成一个完整的java语句</p><p>4.代码脚本和表达式脚本组合使用可以将结果往页面上输入</p><p><strong>第三点举例</strong></p><p><img src="/images/image-20211112145333627.png" alt="image-20211112145333627"></p><p>两个残缺的代码块可以放进去组成一句完整的代码</p><p><strong>第四点举例</strong></p><p><img src="/images/image-20211112145342356.png" alt="image-20211112145342356"></p><p>这就把0~10输出到了页面上，而不是控制台。</p><p>由此衍生出做表格的妙用，不需要像之前一样复制好几行<tr></p><p><img src="/images/image-20211112145357205.png" alt="image-20211112145357205"></p><p><img src="/images/image-20211112145405461.png" alt="image-20211112145405461"></p><h2 id="3-jsp注释"><a href="#3-jsp注释" class="headerlink" title="3.jsp注释"></a>3.jsp注释</h2><p>在jsp中可以写三种注释</p><p>1.html注释<!--注释 --></p><p>会被翻译到java源代码中在_jspService()方法中，以out.write()输出</p><p>2.java注释/*   */  //</p><p>会被翻译到java源代码中</p><p>3.jsp注释&lt;%– –%&gt;</p><p>可以注释掉jsp页面中所有代码包括以上两个</p><h2 id="4-jsp九大内置对象"><a href="#4-jsp九大内置对象" class="headerlink" title="4.jsp九大内置对象"></a>4.jsp九大内置对象</h2><p>指Tomcat在翻译jsp页面成为Servlet源码后，内部提供的九大对象</p><p><img src="/images/image-20211112145418768.png" alt="image-20211112145418768"></p><p>其中，exception对象需要在头部page指令中将isErrorPage的值设定为true，才会出现。</p><h2 id="5-jsp四大域对象"><a href="#5-jsp四大域对象" class="headerlink" title="5.jsp四大域对象"></a>5.jsp四大域对象</h2><p>在以上内置对象中，有四个是域对象</p><p><img src="/images/image-20211112145426300.png" alt="image-20211112145426300"></p><h2 id="6-out输出和response-getWriter输出的区别"><a href="#6-out输出和response-getWriter输出的区别" class="headerlink" title="6.out输出和response.getWriter输出的区别"></a>6.out输出和response.getWriter输出的区别</h2><p><img src="/images/image-20211112145524558.png" alt="image-20211112145524558"></p><p>由此可以得到，如果代码是</p><p><img src="/images/image-20211112145533771.png" alt="image-20211112145533771"></p><p>out1会先加到response缓冲区，然后out2放到out缓冲区，然后两个response紧接着放在out1之后，最后由于jsp所有代码执行完毕，out.flush又执行一次，out2由out缓冲区加载到response缓冲区末尾。最终结果就是</p><p><img src="/images/image-20211112145541344.png" alt="image-20211112145541344"></p><p>由于jsp翻译后，底层源码都是用out来输出，所以一般统一使用out来输出避免打乱页面输出内容顺序</p><h2 id="7-out的print和write方法区别"><a href="#7-out的print和write方法区别" class="headerlink" title="7.out的print和write方法区别"></a>7.out的print和write方法区别</h2><p><strong>先说结论：在jsp页面中可以统一使用out.print()进行输出</strong></p><p>由实验结果表明</p><p>out.write和out.print输出字符串类型数据都没有任何问题</p><p>对于print，通过源码看看到</p><p><img src="/images/image-20211112145553199.png" alt="image-20211112145553199"></p><p>输出任意数据都没问题，因为底层，print都将数据转化成字符串然后调用write进行输出</p><p>而为什么write输出其他类型的数据就会出问题，根据源码</p><p><img src="/images/image-20211112145600912.png" alt="image-20211112145600912"></p><p>向write传递的参数会被强转为char存储在输出的缓冲数组中，<strong>而用char强转就是他只能输出字符串的关键所在</strong>，用char强转所得到的是参数c所对应的ascii码字符，就与原值相悖了</p><h2 id="8-jsp常用标签"><a href="#8-jsp常用标签" class="headerlink" title="8.jsp常用标签"></a>8.jsp常用标签</h2><p>随着Java EE技术的革新，现在对jsp的使用已经多了，jsp的作用基本只剩下输出数据，jsp中不会包含多复杂的代码，所以一搬用静态包含就够了（当然知识还是都要学）</p><h3 id="a-静态包含"><a href="#a-静态包含" class="headerlink" title="a.静态包含"></a>a.静态包含</h3><p><img src="/images/image-20211112145608932.png" alt="image-20211112145608932"></p><p>依然是要注意这个斜杠/。（但是好像不加斜杠，默认是帮忙加了，因为不加斜杠的初始路径也是webapp）</p><p><img src="/images/image-20211112145616884.png" alt="image-20211112145616884"></p><p><img src="/images/image-20211112145626428.png" alt="image-20211112145626428"></p><p>可以看到，静态包含的特点</p><p>1.静态包含不会翻译被包含的jsp页面</p><p>2.静态包含是把被包含地jsp页面代码拷贝到包含的位置，用write包起来进行输出</p><h3 id="b-动态包含"><a href="#b-动态包含" class="headerlink" title="b.动态包含"></a>b.动态包含</h3><p><img src="/images/image-20211112145640288.png" alt="image-20211112145640288"></p><p>动态包含也可以和静态包含一样把被包含的内容输出到包含的位置</p><p>不过</p><p><strong>动态包含特点：</strong></p><p>1.动态包含会把被包含的jsp页面翻译出来成为.java</p><p><img src="/images/image-20211112145653981.png" alt="image-20211112145653981"></p><p>2.在使用包含的那个jsp（这里把他称为也理解为<strong>main.jsp</strong>）被翻译出来的.java文件中，被包含的jsp文件不同于静态包含，静态包含是直接拷贝过去用write包起来，而动态包含是使用代码去调用被包含的jsp页面（即<strong>footer2.jsp</strong>）</p><p><img src="/images/image-20211112145701596.png" alt="image-20211112145701596"></p><p>3.动态包含还可以传递参数</p><p><img src="/images/image-20211112145711363.png" alt="image-20211112145711363"></p><p><img src="/images/image-20211112145719800.png" alt="image-20211112145719800"></p><p><img src="/images/image-20211112145728262.png" alt="image-20211112145728262"></p><p><strong>第二第三点的底层原理</strong></p><p><img src="/images/image-20211112145736660.png" alt="image-20211112145736660"></p><p>可以通过看第二点中的图，看出，main.jsp是把自己的response和request内置对象传给footer2.jsp。即footer2的内置对象是对main的内置对象的引用。所以他俩的request和response都指向的是同一个out缓冲区。所以当main的out.write()执行后（注意图上的write写错了），开始调用footer2的out.write()。等代码全部结束后，out缓冲区自行进行flush操作，最终就得到了显示的正常结果。（个人觉得很像在一个方法里调用另一个方法，当主方法调用子方法时是把子方法压栈，然后主方法等到子方法执行完后才恢复执行，最终统一flush）</p><h3 id="c-请求转发"><a href="#c-请求转发" class="headerlink" title="c.请求转发"></a>c.请求转发</h3><p><img src="/images/image-20211112145752046.png" alt="image-20211112145752046"></p><p>都是请求转发，这两句代码没啥区别（两个路径按理说都应在前面加上/，但是不加也没问题，默认是从webapp开始的）</p><p><img src="/images/image-20211112145809067.png" alt="image-20211112145809067"></p><p>在提示中，加了/是可以往java文件夹里索引的，但是通过实验，同时就单单通过这个IDEA提示也可以看到，不加/也能索引到</p><h1 id="4-Listener监听器"><a href="#4-Listener监听器" class="headerlink" title="4.Listener监听器"></a>4.Listener监听器</h1><p>1.是Java EE的规范，是一个接口</p><p>2.作用是，监听某种事务的变化。然后通过回调函数，回馈给客户（程序）去做响应处理</p><p>随着技术变革，很多监听器都不用了，唯独</p><h2 id="1-ServletContextListener"><a href="#1-ServletContextListener" class="headerlink" title="1.ServletContextListener"></a>1.ServletContextListener</h2><p>*ServletContextListener可以监听ServletContext对象的创建和销毁</p><p>*由前面所学可知，ServletContext对象随着web工程的创建而创建，web工程停止时销毁</p><p>*该监听器监听到创建和销毁后都会调用其方法反馈，分别是</p><p><img src="/images/image-20211112145828040.png" alt="image-20211112145828040"></p><p>使用步骤：</p><p>1.编写类实现ServletContextListener接口</p><p>2.实现以上两个回调方法</p><p>3.到web.xml中配置监听器</p><p><img src="/images/image-20211112144229478.png" alt="image-20211112144229478"></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JavaWeb </tag>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习笔记</title>
      <link href="/2021/11/10/JVM/"/>
      <url>/2021/11/10/JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1.类文件结构"></a>1.类文件结构</h1><h2 id="1-Class文件结构"><a href="#1-Class文件结构" class="headerlink" title="1.Class文件结构"></a>1.Class文件结构</h2><p>*只有两种数据类型：无符号数，表</p><p>*前四个字节（一个字节放两个十六进制位）是魔数，判定该class是否能被虚拟机接受，0xCAFEBABE</p><p>*紧接着四个字节的前两个是次版本号，后两个是主版本号</p><h3 id="1-常量池"><a href="#1-常量池" class="headerlink" title="1.常量池"></a>1.常量池</h3><p>*从第九个字节开始是常量池，而第九个字节标记了常量池的大小。在class文件中，只有常量池的容量是从1开始计数，其余都是0开始。如第九个字节是0x16 -&gt; 22 -&gt; 即常量池有21项常量1~21</p><p>*每一项常量都是一个表</p><p><em>CONSTANT_Utf8_info型的常量的最大长度就是JAVA中方法或字段的最大长度。*<em>CONSTANT_Utf8_info中length是u2类型，所以如果JAVA程序中定义了超过65535，即64KB的字符变量或者方法名就无法编译</em></em></p><p>*查看字节码内容 javap -verbose</p><h3 id="2-访问标志"><a href="#2-访问标志" class="headerlink" title="2.访问标志"></a>2.访问标志</h3><p>*常量池结束后紧接着的2个字节代表访问标志，用于识别这个Class是接口？abstract？public？等等</p><h3 id="3-类索引，父类索引，接口索引集合"><a href="#3-类索引，父类索引，接口索引集合" class="headerlink" title="3.类索引，父类索引，接口索引集合"></a>3.类索引，父类索引，接口索引集合</h3><p>*因为JAVA中除了Object，都有父类，所以除了Object的JAVA类的父类索引都不为0</p><h1 id="2-类加载机制"><a href="#2-类加载机制" class="headerlink" title="2.类加载机制"></a>2.类加载机制</h1><h2 id="1-类加载时机"><a href="#1-类加载时机" class="headerlink" title="1.类加载时机"></a>1.类加载时机</h2><p>1.加载，验证，准备，初始化，卸载的顺序是固定的，而解析则不一定</p><p>2.六种情况必须立即对类进行初始化：</p><p>​    （1）遇到new,getstatic,putstatic, invokestatic四条指令时，而会生成这四条指令的典型场景有</p><p>​        1.用new实例化对象时<strong>（静态加载）</strong></p><p>​        <strong>2.除被final修饰的静态字段被读取或设置</strong></p><p>​        3.调用静态方法<strong>（静态加载）</strong></p><p>​    （2）对类型进行反射调用时<strong>（动态加载）</strong></p><p>​    <strong>（3）初始化类时，如果他的父类还没初始化，必须先初始化他的父类（接口的这一点和类不同，接口在初始化时，并不要求他的父接口全部完成初始化，只有真的用到父接口时（如引用了父接口内定义的常量）时才会初始化）</strong>  <strong>（属于静态加载）</strong></p><p>​    （4）JVM启动时，用户需指定一个要执行的主类（包含Main的那个类），JVM会对其初始化</p><p>​    （5）对一个MethodHandle实例解析结果为REF_newInvokeSpecial, REF_getStatic, REF_putStatic,  REF_invokeStatic时</p><p>​    （6）默认方法（被default修饰的接口方法）的实现类发生初始化时，必须先初始化这个接口</p><p>3.P264 265 266的被动引用例子，要作为JAVA笔记中代码块调用顺序的补充</p><p>​    （1）通过子类直接引用父类的静态字段，不会触发子类的初始化</p><p>​    （2）通过数组定义来所引用的类，不会触发此类的初始化</p><p>​    （3）与上面第二点呼应。常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，不会触发初始化</p><h2 id="2-类的加载过程"><a href="#2-类的加载过程" class="headerlink" title="2.类的加载过程"></a>2.类的加载过程</h2><p><strong>（验证+准备+解析属于连接过程）</strong></p><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p>1.完成三件事</p><p>（1）通过类名定义此类的二进制流</p><p>（2）将此字节流代表的的静态存储结构转化为方法区运行时数据结构</p><p>（3）在内存中生成代表此<strong>类的java.lang.Class对象</strong>作为方法区这个类的各种数据访问入口</p><p>2.加载尚未完成，链接可能就开始了。但是这俩的开始时间的先后顺序时固定的</p><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><p><img src="/images/image-20211110215400270.png" alt="image-20211110215400270"></p><p>1.如果不通过验证就会抛出java.lang.VerifyError或其子类异常</p><p>验证内容</p><p>1.文件格式验证（CAFEBABE等）</p><p>2.元数据验证（这个类是否有父类（除Object都有父类），有没有继承不允许被继承的类等）</p><p>3.字节码验证（确保程序语义是否合法，符合逻辑）</p><p>4.符号引用验证（确保解析正常）</p><h3 id="3-准备（针对静态）"><a href="#3-准备（针对静态）" class="headerlink" title="3.准备（针对静态）"></a>3.准备（针对静态）</h3><p>1.为静态变量分配内存并设置默认初始值</p><p><strong>注意，如果一个静态变量被final修饰就不适用了，因为final在编译的时候就已经分配了，所以在此阶段会直接给这个常量编译时赋的值而不是默认值了</strong></p><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><p>此阶段将符号引用转化为直接引用</p><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><p><strong>（准备是赋默认值，初始化是赋程序员给的值如num=2，准备只会让num=0）静态代码块，就是在这个时候被调用的（还有静态变量的显式赋值）</strong></p><p>1.初始化阶段就是执行类构造器<client>()的过程,他<strong>只操作静态变量，方法</strong>。因为它是编译器自动收集类中所有对静态变量赋值动作和静态代码块中的语句合并来的</p><p>2.<code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</p><p>理解：</p><p><img src="/images/image-20211110215414618.png" alt="image-20211110215414618"></p><p>这段代码number=20那里初始化不会报错的原因就是因为在准备阶段，静态的number已经被赋值为0了，所以即便是先执行静态代码块中的内容，程序也知道number是已经被声明过的。所以在初始化阶段，会那顺序来初始化，就把Number=0覆盖掉，变成20，然后再覆盖，变成10。 为什么后面会报错呢？因为这种形式的代码只能赋值，不能调用（这叫非法前向调用）</p><p>3.<clinit>()与类的构造器不同。在虚拟机的视角下，类的构造器是<init>()。父类的clinit是优先于自己的</p><p>4.<strong>虚拟机在加载类时只会调用一次clinit()，然后就把它放在方法区</strong>。对于多线程，如果有很多个线程要初始化一个类，<strong>只会有一个线程去执行这个类的clinit() （即执行静态代码块等等），其他线程都会被阻塞在外面直到clinit进行完毕。</strong></p><h2 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3.类加载器"></a>3.类加载器</h2><p><img src="/images/image-20211117144739527.png" alt="image-20211117144739527"></p><p>1.Java的核心类库例如String类库都是由引导加载器加载的，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sout(String.class.getClassLoader())</span><br></pre></td></tr></table></figure><p>输出null值，因为BootStrapClassLoader对象是拿不到的</p><p>对于用户自定义类来说使用的是系统类加载器加载即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sout(A.class.getClassLoader())</span><br></pre></td></tr></table></figure><p>输出的是一个AppClassLoader的对象信息</p><h4 id="1-启动类加载器"><a href="#1-启动类加载器" class="headerlink" title="1.启动类加载器"></a>1.启动类加载器</h4><p><strong>（引导类加载器BootStrapClassLoader）（C/C++写的）</strong></p><p>1.是JVM的一部分，用来加载JAVA的核心类库</p><p>2.没有父加载器<strong>（就他没继承ClassLoader）</strong></p><p>3.<strong>加载包名为java,javax,sun等开头的类</strong></p><h4 id="2-扩展类加载器"><a href="#2-扩展类加载器" class="headerlink" title="2.扩展类加载器"></a>2.扩展类加载器</h4><p>1.派生于ClassLoader</p><p>2**.加载jre/lib/ext中**的字节码文件，如果用户创建的JAR包放在了jre/lib/ext中，那么也会由扩展类加载器来加载</p><h4 id="3-系统类加载器AppClassLoader"><a href="#3-系统类加载器AppClassLoader" class="headerlink" title="3.系统类加载器AppClassLoader"></a>3.系统类加载器AppClassLoader</h4><p>1.是一个内部类</p><p>2.派生于ClassLoader</p><p>3.父类加载器是扩展类加载器</p><p><img src="/images/image-20211110215805077.png" alt="image-20211110215805077"></p><h4 id="4-用户自定义加载器"><a href="#4-用户自定义加载器" class="headerlink" title="4.用户自定义加载器"></a>4.用户自定义加载器</h4><p>后面会讲，使用情况</p><p>1.隔离加载类</p><p>2.修改类加载的方式</p><p>3.扩展加载源</p><p>4.防止源码泄露（因为JAVA可以反编译所以会泄露）</p><h4 id="5-关于ClassLoader"><a href="#5-关于ClassLoader" class="headerlink" title="5.关于ClassLoader"></a>5.关于ClassLoader</h4><p><strong>（凡是ClassLoader下的都是JAVA写的）</strong></p><p>1.是一个抽象类</p><p>2.除BootStraop都的类加载器都继承于他</p><p><img src="/images/image-20211110215814731.png" alt="image-20211110215814731"></p><h2 id="4-双亲委派机制"><a href="#4-双亲委派机制" class="headerlink" title="4.双亲委派机制"></a>4.双亲委派机制</h2><p>1.（跟类的加载比较像，自己是在父类加载完后才进行），如果一个类加载器收到了加载请求，不会自己先去加载而是向父类加载去委托，如果他的父类加载器还存在父类，就一直网上找到达顶层加载器。如果父类的那些加载器可以完成对该类的加载就成功返回，如果不行才会自己去加载<strong>（这就是为什么自己写一个java.lang.String类，然后在自己另一个类中去执行调用，调用不到的原因。因为首先被父类加载器判断是可以由父类加载的，就没自定义加载器什么事了）</strong>（如果顶层（bootstrap）发现这个类不该由我加载，就会给第二层（扩展类加载器）问他行不行，以此类推到子加载器（一般默认是系统加载器APPClassLoader，或者是用户自定义类加载器）发现由他管，就加载） <strong>（蛇形）</strong></p><p><img src="/images/image-20211110215823127.png" alt="image-20211110215823127"></p><h3 id="这就是沙箱安全机制"><a href="#这就是沙箱安全机制" class="headerlink" title="这就是沙箱安全机制"></a>这就是沙箱安全机制</h3><p><strong>一个好的例子（前面是在别的类中执行，现在这里是直接在自定义String类中运行）</strong></p><p><img src="/images/image-20211110215848022.png" alt="image-20211110215848022"></p><p>如果在自己定义的java.lang.String里加一个Main函数，会报错。因为此时就是想去执行对自己定义的String类的加载，由于是java开头的包，就会交由引导类加载器来加载。而引导类加载器要加载的核心类库是没有main方法的，所以报错<strong>（这里体现的就是沙箱安全机制）</strong></p><p>2.优势</p><p>避免重复加载</p><p>保护程序安全，防止核心API被篡改</p><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h2><p>1.判断两个Class是不是同一个</p><p>类的完整名（包括包名要一致）</p><p><strong>加载这个Class的ClassLoader要相同（这个就与双亲委派呼应起来了）</strong></p><p>2.JVM必须只要加载一个类是由引导类（启动类）加载器加载的还是用户类加载器加载的。如果是用户类加载器加载的话，JVM就会将这个类加载器的引用作为类型的信息的一部分放在方法区中<strong>（这就是为什么去获取BootStrapClassLoader的时候返回的是null，而其他调用是能看到类型的）</strong></p><p>3.<img src="/images/image-20211110215909818.png" alt="image-20211110215909818"></p><h1 id="3-运行时数据区"><a href="#3-运行时数据区" class="headerlink" title="3.运行时数据区"></a>3.运行时数据区</h1><p><strong>（重点是虚拟机栈，堆，方法区）</strong></p><p><img src="/images/image-20211110215921594.png" alt="image-20211110215921594"></p><p>红色区域（两个一组）是一个进程，一个虚拟机对应一组（一个虚拟机就会对应一个进程），灰色区域（三个一组）是一个线程对应一组</p><p>假设一个进程有五个线程，那么就会有五组灰色区域，5个线程共用一组红色区域</p><h2 id="1-运行时数据区及线程"><a href="#1-运行时数据区及线程" class="headerlink" title="1.运行时数据区及线程"></a>1.运行时数据区及线程</h2><p><img src="/images/image-20211110215932992.png" alt="image-20211110215932992"></p><p>类比一下也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品。</p><p>每个JVM只有一个Runtime实例</p><p>*<strong>运行时数据区内部图</strong></p><p><img src="/images/image-20211110215945958.png" alt="image-20211110215945958"></p><h3 id="2-程序计数器（PC寄存器）"><a href="#2-程序计数器（PC寄存器）" class="headerlink" title="2.程序计数器（PC寄存器）"></a>2.程序计数器（PC寄存器）</h3><p>1.用于存储下一条指令的地址</p><p>2.每个线程都有自己的程序计数器，是线程私有的，生命周期与线程一致</p><p>3.任何时间，线程都只有一个方法在运行</p><p><img src="/images/image-20211110215955929.png" alt="image-20211110215955929"></p><h4 id="两个常见的面试问题"><a href="#两个常见的面试问题" class="headerlink" title="*两个常见的面试问题"></a>*两个常见的面试问题</h4><p>1.</p><p><img src="/images/image-20211110220003405.png" alt="image-20211110220003405"></p><p>2.</p><p><img src="/images/image-20211110220017045.png" alt="image-20211110220017045"></p><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈*"></a>2.虚拟机栈*</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>优点：跨平台，指令集小</p><p>缺点：性能低（不是指速度慢）</p><p>*对于栈来说没有垃圾回收问题，因为栈只有入栈和出栈两种操作。但是会存在异常的情况</p><p><strong>==============面试题======================</strong></p><p><strong>开发中遇到的异常有哪些？</strong></p><p>首先，在JAVA虚拟机中，java栈的大小可以是动态也可以是静态</p><p>1.如果采用静态的，那么每个线程的java虚拟机栈容量在线程创建的时候就定好了。如果线程请求分配的容量大于原本的容量，就会抛出StackOverFlowError</p><p>2.如果采用动态的，（1）在尝试扩展的时候无法申请到足够内存，（2）或在创建新线程时没有足够内存区创建对应的虚拟机栈，就会抛出OutOfMemoryError</p><p><strong>================================================</strong></p><p>*栈是运行时的单位，堆是存储的单位</p><p>*<strong>每个线程都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应着一次次的JAVA方法调用</strong>。虚拟机栈是线程私有的</p><p>虚拟机栈的作用：</p><p>管程序运行，它保存方法的局部变量（8种基本数据类型，对象的<strong>引用地址</strong>（对象本身在堆中）），部分结果，并参与方法的调用和返回</p><h3 id="2-栈帧（栈的存储单位）"><a href="#2-栈帧（栈的存储单位）" class="headerlink" title="2.栈帧（栈的存储单位）"></a>2.栈帧（栈的存储单位）</h3><p>1.每个线程都有自己的栈，里面的数据的基本单位是栈帧</p><p>2.每个方法对应一个栈帧</p><p>3.一个时间点上只会有一个活动的栈帧</p><p>4.不同线程中的栈帧是不能相互引用的（很好理解，因为每个线程本来就是相对独立的，他们只是可以共享他们所在的那个进程的资源）</p><p>5.Java中有两种返回方式（1）正常的return（void函数其实在结束的时候也会return）（2）抛出异常（指的是未捕获的异常，抛给调用自己的方法）。 两种方式都将导致当前栈帧弹出</p><h4 id="1-栈帧的内部结构"><a href="#1-栈帧的内部结构" class="headerlink" title="1.栈帧的内部结构"></a>1.栈帧的内部结构</h4><p><img src="/images/image-20211110220040997.png" alt="image-20211110220040997"></p><h4 id="2-局部变量表"><a href="#2-局部变量表" class="headerlink" title="2.局部变量表*"></a>2.局部变量表*</h4><p>1.是一个数组，用于存储方法参数和在方法体内的局部变量（即各类基本数据类型，对象的引用，以及returnAddress类型）</p><p>2.由于是建立在线程的栈上，是线程的私有数据，所以不存在安全问题</p><p>3.所需要的容量大小在编译器就已经确定了，在运行期间不会更改</p><p><img src="/images/image-20211110220049940.png" alt="image-20211110220049940"></p><p><strong>注意一下成员变量和局部变量的区别</strong></p><p>*<strong>局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></p><h5 id="关于slot的理解"><a href="#关于slot的理解" class="headerlink" title="关于slot的理解"></a>关于slot的理解</h5><p>1.是局部变量表里最基本单元</p><p>2.用于存储基本数据类型，引用类型以及returnAddress类型</p><p><strong>3.32位数据占一个槽，64位的占两个（long，double）</strong></p><p>4.<strong>如果当前帧是由构造方法或者普通实例方法（即非静态的方法）创建的，那么对于这个对象的引用this就会放在index为0的slot处</strong>（每个方法或这个构造方法其实都隐含着this的）  <strong>（这也是为什么static方法中是不能用this的（因为this不存在于静态方法的局部变量表中））</strong></p><p><img src="/images/image-20211110220102629.png" alt="image-20211110220102629"></p><p>5.slot是可以重复利用的，当局部变量表里的变量被回收时（就比如</p><p><img src="/images/image-20211110220111037.png" alt="image-20211110220111037"></p><p>b会被回收，所以b的位子就被回收给c用了，所以这个局部变量表的长度是3而不是4</p><h4 id="1-操作数栈"><a href="#1-操作数栈" class="headerlink" title="1.操作数栈*"></a>1.操作数栈*</h4><p>1.主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</p><p>2.如果调用的方法有返回值，那么它结束后，返回值会被压入当前栈帧的<strong>操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令</p><p>=================<strong>操作过程</strong>==========================</p><p><img src="/images/image-20211110220119360.png" alt="image-20211110220119360"></p><p>要注意，局部变量表的0位置在图中没画出来，0位置就是这个类的this</p><p><img src="/images/image-20211110220128014.png" alt="image-20211110220128014"></p><p><img src="/images/image-20211110220136348.png" alt="image-20211110220136348"></p><p><img src="/images/image-20211110220145729.png" alt="image-20211110220145729"></p><p><img src="/images/image-20211110220153944.png" alt="image-20211110220153944"></p><p><strong>===================================================</strong></p><h4 id="2-帧数据区（一些附加信息，动态链接，方法返回地址）"><a href="#2-帧数据区（一些附加信息，动态链接，方法返回地址）" class="headerlink" title="2.帧数据区（一些附加信息，动态链接，方法返回地址）"></a>2.帧数据区（一些附加信息，动态链接，方法返回地址）</h4><h5 id="1-动态链接（指向运行时常量池的方法引用）"><a href="#1-动态链接（指向运行时常量池的方法引用）" class="headerlink" title="1.动态链接（指向运行时常量池的方法引用）"></a>1.动态链接（指向运行时常量池的方法引用）</h5><p>*在Java源文件被编译到字节码文件中后，所有变量和方法都会作为<strong>符号引用</strong>保存在class文件的常量池里</p><p>*描述一个方法（一个方法对应一个栈帧）调用另一个其他方法时，就是通过常量池中指向方法的符号引用来表示的。<strong>动态链接的作用就是把符号引用转化为直接引用</strong>（在类加载的解析阶段进行）（符转直其实就是看着符号标的位置去方法区找对应的方法）</p><p><img src="/images/image-20211110220206569.png" alt="image-20211110220206569"></p><p>//常量池中的符号引用</p><p><img src="/images/image-20211110220214214.png" alt="image-20211110220214214"></p><p>//代码中指向常量池的引用  ‘’#’’（也就是动态链接）</p><p><img src="/images/image-20211110220221206.png" alt="image-20211110220221206"></p><p>目前的结构图</p><p><img src="/images/image-20211110220229211.png" alt="image-20211110220229211"></p><h6 id="为什么需要常量池呢？"><a href="#为什么需要常量池呢？" class="headerlink" title="为什么需要常量池呢？"></a>为什么需要常量池呢？</h6><p>常量池提供一些符号和常量，便于指令识别。这样做也就不会让class文件因为装了太多方法和常量而变得很大，引用就好了。</p><h5 id="2-方法的调用"><a href="#2-方法的调用" class="headerlink" title="2.方法的调用**"></a>2.方法的调用**</h5><p>静态链接：当一个字节码文件被装载进JVM内部时，<strong>目标方法在编译期可知且运行期保持不变</strong>。这种情况的符号引用转直接引用叫静态链接</p><p>（早期绑定）</p><p>动态链接：<strong>被调方法在编译器无法被确定下来</strong>，只有在程序运行期才能将符号引用转化为直接引用，叫动态链接</p><p>（晚期绑定）</p><p>非虚方法：</p><p>编译器就确定了具体调用版本且在运行时不改变</p><p>静态，<strong>私有</strong>，final(用invokevirtue调但他不是虚方法)，实例构造器，<strong>父类方法</strong>都是非虚方法</p><p>其他的方法就都是虚的</p><p>非虚方法在编译时是非常确定会去哪里调哪个方法</p><p><img src="/images/image-20211110220240259.png" alt="image-20211110220240259"></p><p>lamda表达式就是用invokedynamic来调的，因为只有运行的时候才知道lamda表达式中的类型</p><p>JAVA是静态类型语言，Python是动态类型语言</p><p><img src="/images/image-20211110220248687.png" alt="image-20211110220248687"></p><p>静态和动态的区别在于，静态类型语言判断变量自身的类型信息，动态语言通过变量的值来判断类型（变量没有类型，而变量值有）</p><h6 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h6><p>*为了提高性能，不每次都在调用时向上找找找，于是JVM在方法区建立虚方法表（因为非虚方法都很确定在哪里调，所以不需要在这个表里）表中存放着各个方法的入口（就不需要向上向上找了）</p><p>*虚方法表何时创建？</p><p>在类加载链接阶段创建，当类准备阶段完成后，类的方法表也初始化完毕</p><p><strong>虚方法表示例</strong></p><p><img src="/images/image-20211110220302162.png" alt="image-20211110220302162"></p><h5 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h5><p>*存储该方法在pc寄存器（存储下一条要执行的指令的值）中的值</p><p>*无论目前的方法所调用的那个方法是正常退出还是出现未处理异常而非正常退出，都会返回到被调用的位置。</p><p><strong>方法的退出本质就是当前栈帧出栈的过程</strong></p><p>正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法指令的下一条指令的地址</strong></p><p>异常退出时，返回地址通过异常表确定，栈帧一般不会保存这部分信息</p><p><strong>这也是为什么异常退出不会给调用者返回任何值</strong></p><h5 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h5><p>栈帧允许携带与JVM实现相关的一些附加信息，不能保证每个栈帧都有</p><h3 id="3-虚拟机栈的相关面试题"><a href="#3-虚拟机栈的相关面试题" class="headerlink" title="3.虚拟机栈的相关面试题**"></a>3.虚拟机栈的相关面试题**</h3><p><strong>1.举例栈溢出的情况</strong></p><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM（OutOfMemoryError）</p><p>（可通过-Xss来设置栈的大小）</p><p><strong>2.调整栈大小，就能保证不出现溢出吗</strong></p><p>可以视情况做到，但是不能保证</p><p>死循环的话不管栈有多大都会溢出（栈小很快溢出，栈大慢点溢出罢了）</p><p><strong>3.分配的栈内存越大越好吗？</strong></p><p>理论上越大，能降低出现SOF的概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p><p><strong>4.垃圾回收是否会涉及到虚拟机栈</strong></p><p>不会</p><p><img src="/images/image-20211110220318887.png" alt="image-20211110220318887"></p><p><img src="/images/image-20211110220326382.png" alt="image-20211110220326382"></p><p><strong>5.方法中定义的局部变量是否线程安全</strong></p><p><a href="https://youthlql.gitee.io/post/5b1b6560.html">https://youthlql.gitee.io/post/5b1b6560.html</a></p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p><img src="/images/image-20211110220344355.png" alt="image-20211110220344355"></p><p>用来装native修饰的本地方法</p><p><img src="/images/image-20211110220353140.png" alt="image-20211110220353140"></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆*"></a>堆*</h2><p>*每一个JVM实例（也就是每一个进程）都对应一个堆内存</p><p>*可处于物理上不连续的空间中，但是逻辑上是连续的</p><p>*<strong>线程共享堆，但不是绝对的共享。里面也可以划分线程线程私有的缓冲区</strong>TLAB</p><p>*所有的对象实例（几乎所有）（注意是实例，引用在虚拟机栈里）和数组，都在堆里</p><p>*</p><p><img src="/images/image-20211110220400965.png" alt="image-20211110220400965"></p><p>*设置堆空间大小（年轻代+老年代，不包括元空间）</p><p><img src="/images/image-20211110220411446.png" alt="image-20211110220411446"></p><p>ms: memory start</p><h1 id="没分章节的内容"><a href="#没分章节的内容" class="headerlink" title="*没分章节的内容"></a>*没分章节的内容</h1><h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><p><strong>为什么要用本地方法？</strong></p><p>1.C , C++盛行，需要交互</p><p>2.要与操作系统交互，因为操作系统是C/C++写的，所以需要本地方法</p><p>3.Sun的解释器是C实现的</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射与动态代理</title>
      <link href="/2021/11/10/%E6%B5%85%E8%B0%88%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/11/10/%E6%B5%85%E8%B0%88%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h1><h2 id="1-动态语言-amp-静态语言"><a href="#1-动态语言-amp-静态语言" class="headerlink" title="1.动态语言&amp;静态语言"></a>1.动态语言&amp;静态语言</h2><p>从声明变量方式看动态与静态语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String author = <span class="string">&quot;CoderKled&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dream <span class="operator">=</span> <span class="string">&quot;Tencet&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distance = <span class="string">&quot;far&quot;</span></span><br></pre></td></tr></table></figure><p>可以看出动态语言与静态语言的区别之一在于：</p><p>静态语言判断变量自身的类型信息需要靠声明</p><p>动态语言的变量的类型信息则是根据其值来判断</p><p>Java不是动态语言，但是可以被称为是“准动态”，其原因在于Java具有一定的动态性，它是由反射机制等所赋予的。</p><h2 id="2-反射功能"><a href="#2-反射功能" class="headerlink" title="2.反射功能"></a>2.反射功能</h2><ul><li><strong>在运行时</strong>分析类的能力（如判断对象所属类，获取类的所有成员变量与方法信息等）</li><li>在运行时检查对象（例如，编写一个适用于所有类的toString方法）</li><li>实现泛型数组操作代码</li><li>利用Method对象</li><li>生成动态代理</li></ul><p>*反射可以在不通过修改源码的情况下控制程序</p><p>*在反射中，方法也是对象，可以用方法对象来调用方法</p><h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><h2 id="1-获取Class对象"><a href="#1-获取Class对象" class="headerlink" title="1.获取Class对象"></a>1.获取Class对象</h2><ul><li>方式一：通过一个类的对象getClass()  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Coder kled = <span class="keyword">new</span> Coder();</span><br><span class="line">Class c = kled.getClass();</span><br></pre></td></tr></table></figure><p>此处呼应5所讲，系统维护的是一个运行时类型标识，所以getClass得到的是运行类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line">System.out.println(cat.getClass());</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211110210804735.png" alt="image-20211110210804735"></p><ul><li>方式二：静态方法forName()  注意里面最好写全路径”com.string_.Cat”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;Coder&quot;</span>;</span><br><span class="line">Class c = Class.forName(name);</span><br></pre></td></tr></table></figure><ul><li>方式三：类型.class（可以是基本数据类型或void关键字）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = <span class="keyword">int</span>.class;</span><br><span class="line">Class c2 = String.class;</span><br><span class="line">Class c3 = Double[].class;</span><br><span class="line">Class c4 = Animal.class</span><br></pre></td></tr></table></figure><ul><li>方式四：ClassLoader，要注意loadClass中的的参数可不是路径，是类的全类名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = ReflectionTest.class.getClassLoader();<span class="comment">//ReflectionTest是本类类名</span></span><br><span class="line">Class c = classLoader.loadClass(<span class="string">&quot;Coder&quot;</span>);</span><br></pre></td></tr></table></figure><p>由于虚拟机只为每个类型管理<strong>唯一一个</strong>Class对象，所以是可以用==来对两个Class进行对比的。</p><h2 id="2-与instanceof"><a href="#2-与instanceof" class="headerlink" title="2.==与instanceof"></a>2.==与instanceof</h2><p>判断对象是否是这个特定类或者是它的子类的一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(cat.getClass() == Cat.class);</span><br><span class="line">System.out.println(cat.getClass() == Animal.class);</span><br><span class="line">System.out.println(cat <span class="keyword">instanceof</span>  Animal);</span><br><span class="line">System.out.println(cat <span class="keyword">instanceof</span>  Cat);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211110210732793.png" alt="image-20211110210732793"></p><p>此处要关注第一行代码正确的理由。因为一个运行时类只会对应一个Class实例。例如，一个Cat类，不论他new 多少个cat1 cat2 cat3对象。这些catx.getClass()得到的结果都是相同的（第5会细说）</p><h2 id="3-getConstructor"><a href="#3-getConstructor" class="headerlink" title="3.getConstructor()"></a>3.getConstructor()</h2><p>若有一个Class类型的对象，可以通过getConstructor()来获取他的构造器对象，但是要根据以下代码注意区分</p><p><img src="/images/image-20211110212258605.png" alt="image-20211110212258605"></p><p><img src="/images/image-20211110212309805.png" alt="image-20211110212309805"></p><p>综上所述，就可以通过反射来创建一个对象</p><p>//Animal类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> age, String category)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.category = category;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;wu~~~~&quot;</span>+content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Animal&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, category=&#x27;&quot;</span> + category + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;com.string_.Animal&quot;</span>);</span><br><span class="line">Constructor constructor = clazz.getConstructor(<span class="keyword">int</span>.class, String.class);</span><br><span class="line">Animal dog = (Animal) constructor.newInstance(<span class="number">3</span>, <span class="string">&quot;dog&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211116191532510.png" alt="image-20211116191532510"></p><h2 id="4-反射调用属性和方法"><a href="#4-反射调用属性和方法" class="headerlink" title="4.反射调用属性和方法"></a>4.反射调用属性和方法</h2><p><strong>即便是private的成员（前提是调用setAccessible()并赋值为true），依然可以通过反射来调用</strong></p><p>通过反射获取的属性是Field类，方法是Method类，构造器是Constructor类</p><ul><li>下面是调用私有字段的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);<span class="comment">//这也是调用私有所必须的，若使用getField()就不能获取私有的字段了</span></span><br><span class="line">age.setAccessible(<span class="keyword">true</span>);<span class="comment">//若要调用private的字段就必须这一步，否则会报IllegalAccessException异常</span></span><br><span class="line">age.set(dog,<span class="number">5</span>);</span><br><span class="line">System.out.println(dog.toString());</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211116192817954.png" alt="image-20211116192817954"></p><ul><li>调用公有方法，可前面调用私有形成对比</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method shout = clazz.getMethod(<span class="string">&quot;shout&quot;</span>,String.class);</span><br><span class="line">shout.invoke(dog,<span class="string">&quot;hello~~~~&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211116193532296.png" alt="image-20211116193532296"></p><p>invoke方法就可以类比于普通对象的直接调用例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Animal(<span class="number">5</span>,<span class="string">&quot;dog&quot;</span>).shout(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>所以如果用反射调用的方法有返回值，那是可以直接接收的，假设此时shout()方法是一个返回值类型为int的方法，那么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = (<span class="keyword">int</span>) shout.invoke(dog,<span class="string">&quot;hello~~~~&quot;</span>);<span class="comment">//这样调用是正确的</span></span><br><span class="line">Object res = shout.invoke(dog,<span class="string">&quot;hello~~~~&quot;</span>);<span class="comment">//这样也是可以的</span></span><br></pre></td></tr></table></figure><h2 id="5-Class类的理解"><a href="#5-Class类的理解" class="headerlink" title="5.Class类的理解"></a>5.Class类的理解</h2><p><strong>反射机制和封装性有矛盾？</strong></p><p>反射机制解决能不能调用的问题，但是封装性是对程序员的建议，二者并不矛盾。例如单例模式就建议不用再去new一个对象，直接用他造好的就可以了。private也是告诉程序员这个成员你用不着，所以不建议使用。</p><p><strong>类的加载过程</strong></p><p>程序经过Javac.exe命令后，会生成一个或多个.class字节码文件，接着用Java.exe命令对字节码文件进行解释运行，这就是将字节码文件加载到内存中。加载完之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。就像一面镜子，透过它就能看到该对象所属类的信息。</p><p>Java运行时系统始终会为所有对象维护一个<strong>运行时类型标识</strong>，这个信息会跟踪每个对象所属的类。虚拟机利用运行时类型信息选择要执行的方法。要注意，<strong>一个运行时类只对应一个Class实例</strong>，不过JVM的垃圾回收机制是可以回收这些Class对象的</p><p><strong>那么呼应1中获取Class对象，哪些类型可以有Class对象？</strong></p><p>（1）普遍认为的class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类<br>（2）interface：接口<br>（3）[]：数组（包括多维数组 ）<br>（4）enum：枚举<br>（5）注解<code>@interface -&gt; Override.class</code><br>（6）基本数据类型<br>（7）void</p><p>而且提一点，对于<strong>相同数据类型</strong>（如果一个数组是char类型一个是int类型那肯定就不一样了）的数组，是要数组的维度一样，那他们的Class就是同一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">Class aclazz = a.getClass();</span><br><span class="line">Class bclazz = b.getClass();</span><br><span class="line">System.out.println(s10 == s11);   <span class="comment">//输出为true</span></span><br></pre></td></tr></table></figure><h2 id="6-用ClassLoader加载Properties"><a href="#6-用ClassLoader加载Properties" class="headerlink" title="6.用ClassLoader加载Properties"></a>6.用ClassLoader加载Properties</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">pros.load(is);</span><br></pre></td></tr></table></figure><p>要注意的是，对于getResourseAsStream方法的参数，其默认路径是当前module下的src文件下。而对于web工程文件，默认是resourse文件夹。</p><h2 id="7-获取类对象"><a href="#7-获取类对象" class="headerlink" title="7.获取类对象"></a>7.获取类对象</h2><p>首先，根据前面提到的四种获取Class对象的方法获取。要注意的是，这里也是可以使用泛型的，当明确标注了类名后，后面的代码就可以直接标注具体类类型了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Animal&gt; animalClass = Animal.class;</span><br><span class="line">Animal animal = animalClass.newInstance();<span class="comment">//这是调用Animal的公有空参构造器（如果没有空参构造器或对构造器访问权限不够会报异常）</span></span><br></pre></td></tr></table></figure><p>所以在javabean中要求提供一个public的空参构造器。</p><p>原因：</p><p>1.便于通过反射，创建运行时类的对象         </p><p>2.便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.Servlet学习笔记</title>
      <link href="/2021/11/09/1.Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/09/1.Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Web中的路径！"><a href="#Web中的路径！" class="headerlink" title="Web中的路径！"></a>Web中的路径！</h1><p><img src="/images/image-20211113142534772.png" alt="image-20211113142534772"></p><h2 id="Web中的斜杠-区分"><a href="#Web中的斜杠-区分" class="headerlink" title="Web中的斜杠/区分"></a>Web中的斜杠/区分</h2><p><img src="/images/image-20211113142542326.png" alt="image-20211113142542326"></p><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="通过Dom4j读取XML文件"><a href="#通过Dom4j读取XML文件" class="headerlink" title="通过Dom4j读取XML文件"></a>通过Dom4j读取XML文件</h2><p>*.步骤</p><p>1.读取???.xml文件（程序读的是books.xml）</p><p>通过SAXReader获取到Document对象</p><p><img src="/images/image-20211113142550286.png" alt="image-20211113142550286"></p><p>2.通过Document对象获取到XML文件里的根元素</p><p><img src="/images/image-20211113142556819.png" alt="image-20211113142556819"></p><p>这个rootElement通过打印显示的结果就是books，即</p><p><img src="/images/image-20211113142606549.png" alt="image-20211113142606549"></p><p>3.通过根元素对象获取XML文件中的标签对象</p><p><img src="/images/image-20211113142615869.png" alt="image-20211113142615869"></p><p>4.遍历，并把标签对象通过asXML转化为标签字符串</p><p><img src="/images/image-20211113142623609.png" alt="image-20211113142623609"></p><p>（可以一级一级地向下获取子标签对象）</p><p><img src="/images/image-20211113142712885.png" alt="image-20211113142712885"></p><p>就是再通过一次.element（“要获取的子标签名”）</p><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="Web资源的分类"><a href="#Web资源的分类" class="headerlink" title="Web资源的分类"></a>Web资源的分类</h2><p>1.静态资源：html ,css, js, txt, mp4, jpg 等</p><p>2.动态资源：jsp页面，Servlet程序 等</p><h2 id="关于Tomcat"><a href="#关于Tomcat" class="headerlink" title="关于Tomcat"></a>关于Tomcat</h2><p>在网页上敲<a href="http://localhost:8080实际上是访问到了Tomcat文件夹中的webapps目录下的ROOT。">http://localhost:8080实际上是访问到了Tomcat文件夹中的webapps目录下的ROOT。</a></p><p>但是如果加了<a href="http://localhost:8080/%E5%B7%A5%E7%A8%8B%E5%90%8D">http://localhost:8080/工程名</a> 等等其他的工程名时，就是以webapps为起始点，去访问webapps目录下这个工程的index.html</p><p>所以综上，如果只敲<a href="http://localhost:8080，相当于默认是访问http://localhost:8080/ROOT">http://localhost:8080，相当于默认是访问http://localhost:8080/ROOT</a></p><h2 id="Servlet技术"><a href="#Servlet技术" class="headerlink" title="Servlet技术"></a>Servlet技术</h2><p>*就是个规范，即接口。</p><p>*是三大组件之一：Servlet程序，Filter过滤器，Listener监听器</p><p>*是运行在服务器上的一个java程序，用来接收客户端的请求并响应数据</p><h3 id="实现Servlet程序（通常不用）"><a href="#实现Servlet程序（通常不用）" class="headerlink" title="实现Servlet程序（通常不用）"></a>实现Servlet程序（通常不用）</h3><p>1.编写类实现Servlet接口</p><p><img src="/images/image-20211113142720892.png" alt="image-20211113142720892"></p><p>2.实现service方法，处理请求并响应数据</p><p><img src="/images/image-20211113142741495.png" alt="image-20211113142741495"></p><p>3.在web.xml中配置servlet程序的访问地址</p><p><img src="/images/image-20211113142750684.png" alt="image-20211113142750684"></p><h3 id="定位servlet程序的方式"><a href="#定位servlet程序的方式" class="headerlink" title="定位servlet程序的方式"></a><strong>定位servlet程序的方式</strong></h3><p><img src="/images/image-20211113142802767.png" alt="image-20211113142802767"></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/images/image-20211113142811285.png" alt="image-20211113142811285"></p><p>初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，将ServletConfig作为参数来调用init()方法。</p><p>1.执行init初始化方法，仅执行一次，负责在装载Servlet时初始化Servlet对象。</p><p>2.执行service方法（每次访问都会调用）</p><p>3.执行destroy方法（web工程停止时才调用）</p><h3 id="请求的分发处理"><a href="#请求的分发处理" class="headerlink" title="请求的分发处理"></a>请求的分发处理</h3><p>service对于页面中的get请求和post请求要分开处理</p><p><img src="/images/image-20211113142819278.png" alt="image-20211113142819278"></p><p>可以使用getMethod方法对请求类型进行判断，然而servletRequest没有getMethod方法，需要将他转为其子类HttpServletRequest才能调用</p><p><img src="/images/image-20211113142826329.png" alt="image-20211113142826329"></p><p>为避免代码臃肿，通常会专门为get方法所处理的事建一个方法，Post一个方法</p><p><img src="/images/image-20211113142833913.png" alt="image-20211113142833913"></p><h3 id="通过继承HttpServlet实现servlet程序"><a href="#通过继承HttpServlet实现servlet程序" class="headerlink" title="通过继承HttpServlet实现servlet程序"></a>通过继承HttpServlet实现servlet程序</h3><p>*一般实际开发都是继承HttpServlet来实现Servelt程序</p><p>*步骤</p><p>1.继承HttpServlet</p><p>2.根据业务逻辑写doPost或doGet</p><p>3.在web.xml配置访问地址</p><p>*在HttpServlet底层的service()方法已经会对get请求或post请求进行判断，所以直接重写doPost或doGet方法，不需要人工对请求类型进行判断</p><h3 id="Servlet的继承体系"><a href="#Servlet的继承体系" class="headerlink" title="Servlet的继承体系"></a>Servlet的继承体系</h3><p><img src="/images/image-20211113142847130.png" alt="image-20211113142847130"></p><h2 id="ServletConfig类"><a href="#ServletConfig类" class="headerlink" title="ServletConfig类"></a>ServletConfig类</h2><p>是一个接口</p><p>*Servlet程序和ServletConfig对象都是由Tomcat创建的（初始化阶段）。Servlet程序默认是第一次访问时创建（生命周期有提过），ServletConfig对象是当Servlet程序创建时，就创建一个对象。</p><p>*<strong>即一个Servlet程序对应一个ServletConfig对象，Servlet A 的config对象获取不了Servlet B的配置信息</strong></p><p>*<strong>ServletConfig对象可以获取Servlet的初始化配置信息，这些信息理所应当的是存储在.xml文件中而被获取了出来</strong></p><h3 id="ServletConfig的三大作用"><a href="#ServletConfig的三大作用" class="headerlink" title="ServletConfig的三大作用"></a>ServletConfig的三大作用</h3><p>1.获取servlet程序的别名servlet-name的值</p><p>2.获取初始化参数init-param</p><p>3.获取ServletContext对象（虽然有直接的getServletContext()方法，但是其底层还是用的ServletConfig来获取Context对象）</p><p><img src="/images/image-20211113143430000.png" alt="image-20211113143430000"></p><h3 id="关于重写init类"><a href="#关于重写init类" class="headerlink" title="关于重写init类"></a>关于重写init类</h3><p><img src="/images/image-20211113142510855.png" alt="image-20211113142510855"></p><p>一定要写上super.init(config)</p><p>因为在父类中，init方法将config对象保存了起来这样才可以让子类中getServletConfig方法拿到ServletConfig对象。</p><p>如果子类把init重写了，那就相当于在调用时把父类的init方法覆盖了，如果不写super.init(config)，父类中就不会保存config对象，从而使子类的getServletConfig方法报空指针异常</p><h2 id="ServletContext类"><a href="#ServletContext类" class="headerlink" title="ServletContext类"></a>ServletContext类</h2><p>是一个接口</p><p>*是一个域对象</p><p>域对象：可以像Map一样存取数据的对象</p><p>这里的域指的是存取数据的操作范围，范围是整个web工程</p><p><img src="/images/image-20211113143243188.png" alt="image-20211113143243188"></p><p>*<strong>一个web工程只有一个ServletContext实例</strong></p><p>*<strong>ServletContext在web工程部署启动的时候就创建了，web停止时销毁</strong></p><p><strong>所以，在同一工程下，一个Servlet向ServletContext对象存入的键值对，可以由其他Servlet取到</strong>（类比一下，感觉有点像静态，web是一个类，各个Servlet是对象，而ServletContext就是里面的静态成员）</p><h3 id="四个作用"><a href="#四个作用" class="headerlink" title="四个作用"></a>四个作用</h3><p><img src="/images/image-20211113143518163.png" alt="image-20211113143518163"></p><p>*获取方式：通过ServletConfig对象获取（也可以直接getServletContext()  </p><p>但是其实底层都是（刚刚才提到了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getServletConfig().getServletContext()</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211113143646124.png" alt="image-20211113143646124"></p><p><img src="/images/image-20211113143655390.png" alt="image-20211113143655390"></p><p>关于最后一条的/，前面提过，/会被服务器解析为<a href="http://localhost:8080/%E5%B7%A5%E7%A8%8B%E5%90%8D/">http://localhost:8080/工程名/</a></p><p><img src="/images/image-20211113143703291.png" alt="image-20211113143703291"></p><p>工程的绝对路径实际上是映射到了IDEA中的webapp文件夹</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="请求HTTP"><a href="#请求HTTP" class="headerlink" title="请求HTTP"></a>请求HTTP</h3><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><p><img src="/images/image-20211113143730986.png" alt="image-20211113143730986"></p><p><img src="/images/image-20211113143803457.png" alt="image-20211113143803457"></p><h4 id="2-POST请求"><a href="#2-POST请求" class="headerlink" title="2.POST请求"></a>2.POST请求</h4><p><img src="/images/image-20211113143821496.png" alt="image-20211113143821496"></p><h4 id="总结以上两个请求的请求头"><a href="#总结以上两个请求的请求头" class="headerlink" title="总结以上两个请求的请求头"></a>总结以上两个请求的请求头</h4><p>常用请求头有</p><p>Accept：告诉服务器客户端可以接收的数据类型</p><p>Accept-Language：客户端可以接受的语言类型</p><p>User-Agent：浏览器的信息</p><p>Host：表示请求的服务器的ip和端口号</p><h4 id="区分GET-POST请求"><a href="#区分GET-POST请求" class="headerlink" title="区分GET,POST请求"></a>区分GET,POST请求</h4><p>*GET</p><p><img src="/images/image-20211113143848105.png" alt="image-20211113143848105"></p><p>*POST</p><p>form标签 method=”post”</p><h3 id="响应HTTP"><a href="#响应HTTP" class="headerlink" title="响应HTTP"></a>响应HTTP</h3><p><img src="/images/image-20211113143900071.png" alt="image-20211113143900071"></p><h4 id="常见响应码"><a href="#常见响应码" class="headerlink" title="常见响应码"></a>常见响应码</h4><p>200            请求成功</p><p>302            请求重定向</p><p>404            服务器已收到请求，但是数据不存在（或请求地址错误）</p><p>500            服务器已收到请求，但是服务器内部错误（代码错误）</p><h2 id="HttpServletRequest类"><a href="#HttpServletRequest类" class="headerlink" title="HttpServletRequest类"></a>HttpServletRequest类</h2><p>*只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好，封装到HttpServletRequest对象中。然后传递给service()方法</p><p><img src="/images/image-20211113143911607.png" alt="image-20211113143911607"></p><p>service方法就可以根据过来的请求的类型，把对象又给对应的doPost,doGet之类方法</p><p>*可以通过HttpServletRequest对象获取到所有请求信息</p><h3 id="类中常用方法"><a href="#类中常用方法" class="headerlink" title="类中常用方法"></a>类中常用方法</h3><p><img src="/images/image-20211113144003770.png" alt="image-20211113144003770"></p><p>在用post发送请求时，如果参数里有中文会有乱码</p><p>可以在doPost方法中使用（注意要在获取参数之前使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.setCharacterEncoding(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure><h3 id="请求的转发"><a href="#请求的转发" class="headerlink" title="请求的转发"></a>请求的转发</h3><p>服务器收到请求后从一个资源跳转到另一个资源的操作</p><p><img src="/images/image-20211113144029950.png" alt="image-20211113144029950"></p><p>*<strong>请求转发的地址必须要以/为开头，再次复习，/表示的地址为<a href="http://localhosr:8080/%E5%B7%A5%E7%A8%8B%E5%90%8D/%EF%BC%8C%E6%AD%A4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%88%B0IDEA%E4%BB%A3%E7%A0%81%E7%9A%84webapp%E7%9B%AE%E5%BD%95">http://localhosr:8080/工程名/，此地址映射到IDEA代码的webapp目录</a></strong></p><p>*<strong>对于一个Servlet程序，HttpServletRequest.getParameter()可以得到请求参数，而请求参数就是问号后的内容，可以自己写问号并添加键值对</strong></p><p><img src="/images/image-20211113144037847.png" alt="image-20211113144037847"></p><h4 id="请求转发的行为"><a href="#请求转发的行为" class="headerlink" title="请求转发的行为"></a>请求转发的行为</h4><p>1.<strong>获取参数（接收客户递交的材料）</strong></p><p><img src="/images/image-20211113144100509.png" alt="image-20211113144100509"></p><p>参数可以自己改，这个参数代表的就是请求键值对中的键，取到的Info就是键对应的值，如上例，括号里填username那么info得到的就是wzg168</p><p>2.<strong>处理完业务后，加盖一个章，也是一个键值对</strong></p><p><img src="/images/image-20211113144107929.png" alt="image-20211113144107929"></p><p><strong>3.获取下一步转发路径（问路）</strong></p><p><img src="/images/image-20211113144116498.png" alt="image-20211113144116498"></p><p>注意path要以/打头（但是实际测试下来发现可以把打头的/省略）</p><p><strong>4.转发（向柜台2走去）</strong></p><p><img src="/images/image-20211113144124618.png" alt="image-20211113144124618"></p><p><strong>5.接受（柜台二接受那张客户已在柜台一办好业务的材料）</strong></p><p><img src="/images/image-20211113144133242.png" alt="image-20211113144133242"></p><p><strong>6.可以获取转发方的“章”</strong></p><p><img src="/images/image-20211113144140953.png" alt="image-20211113144140953"></p><p><strong>7.办自己的业务</strong></p><h4 id="请求转发的特点"><a href="#请求转发的特点" class="headerlink" title="请求转发的特点"></a>请求转发的特点</h4><p>1.由servlet1转发到servlet2，<strong>浏览器地址栏是没有变化的</strong></p><p>2.虽然是访问了多个servlet资源，但是于客户端和服务器的宏观上来看，<strong>整个行为只是一个请求</strong></p><p>3.由2，所以请求的与数据都是一样的，<strong>他们共享request中的数据</strong></p><p>4.对于WEB-INF目录，虽然众所周知/被解析到<a href="http://localhosr:8080/%E5%B7%A5%E7%A8%8B%E5%90%8D/%EF%BC%8C%E4%B8%94%E8%BF%99%E4%B8%AA%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84%E5%88%B0%E4%BA%86IDEA%E7%9A%84webapp%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C**%E4%BD%86%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87%E5%9C%A8/%E5%90%8E%E5%8A%A0WEB-INF%E6%9D%A5%E8%AE%BF%E9%97%AE%E5%88%B0%E4%BB%96**%E3%80%82%E4%BD%86%E6%98%AF%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E6%9D%A5%E8%AE%BF%E9%97%AE%E5%88%B0%E4%BB%96%EF%BC%8C%E5%8D%B3%E5%9C%A8%E8%8E%B7%E5%8F%96%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%BD%AC%E5%8F%91%E8%B7%AF%E5%BE%84%EF%BC%88%E9%97%AE%E8%B7%AF%EF%BC%89%E7%9A%84%E6%AD%A5%E9%AA%A4%E4%B8%AD%E6%8A%8A%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E6%94%B9%E4%B8%BA&quot;/WEB-INF/%E6%83%B3%E8%A6%81%E8%AE%BF%E9%97%AE%E7%9A%84html%E7%AD%89%E6%96%87%E4%BB%B6&quot;%EF%BC%8C%E5%B0%B1%E8%83%BD%E5%9C%A8%E8%AE%BF%E9%97%AEservlet1%E5%AE%8C%E6%AF%95%E5%90%8E%E8%B7%B3%E8%BD%AC%E8%BF%87%E5%8E%BB">http://localhosr:8080/工程名/，且这个路径映射到了IDEA的webapp文件夹，**但是浏览器是无法直接通过在/后加WEB-INF来访问到他**。但是！！！！可以通过请求转发来访问到他，即在获取下一步转发路径（问路）的步骤中把括号中的内容改为&quot;/WEB-INF/想要访问的html等文件&quot;，就能在访问servlet1完毕后跳转过去</a></p><p>​    <strong>总结一下，是可以请求转发到WEB-INF目录下的，但是浏览器不能直接访问</strong></p><p>5.由于在问路步骤时填的参数都是要以/打头，意思就是他只能以<a href="http://localhost:8080/%E5%B7%A5%E7%A8%8B%E5%90%8D/%E4%BD%9C%E4%B8%BA%E5%85%B6%E5%AE%9E%E8%B7%AF%E5%BE%84">http://localhost:8080/工程名/作为其实路径</a></p><p>（实际测试发现，path中的打头的/其实可以省略，但是在运行过程中，会默认一个/作为开头，指向<a href="http://ipport/%E5%B7%A5%E7%A8%8B%E5%90%8D%EF%BC%89">http://ipport/工程名）</a></p><p>​    <strong>所以，通过请求转发时访问不到工程以外的资源的</strong></p><h2 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h2><p><strong>用于设置页面相对路径的参照地址</strong></p><p>怎么理解？</p><p>如果不用base，设置的相对路径就是以当前目录作为起始，去找寻。</p><p>但是如果用了base，在base标签里href值就作为了相对路径的起始地址。也就是把当前目录作为起始地址这个默认值给覆盖掉了</p><p><img src="/images/image-20211113144323458.png" alt="image-20211113144323458"></p><p>另外base标签中的资源名是可以省略的，因为资源名的存在对于路径而言本来就没什么意义。以图上的为例，c.html是可有可无的，因为他本来代表的是以b目录下为起始路径<strong>（但是b后的斜杠不能省略哈，如果把/省略了就相当于把b当作一个可有可无的资源了，就是以a目录下为起始地址了）</strong></p><h2 id="HttpServletResponse类"><a href="#HttpServletResponse类" class="headerlink" title="HttpServletResponse类"></a>HttpServletResponse类</h2><p>和HttpServletRequest一样，每次请求进到tomcat服务器，tomcat就会把信息封装到HttpServletResponse对象中，给Servlet程序去使用。</p><p>若要设置返回给客户端的信息，就可以通过HttpServletResponse对象来进行设置</p><h3 id="两个响应流"><a href="#两个响应流" class="headerlink" title="两个响应流"></a>两个响应流</h3><p><img src="/images/image-20211113144415380.png" alt="image-20211113144415380"></p><h3 id="向客户端回传数据"><a href="#向客户端回传数据" class="headerlink" title="向客户端回传数据"></a>向客户端回传数据</h3><p>*设置编码方式一</p><p><img src="/images/image-20211113144512409.png" alt="image-20211113144512409"></p><p>*方式二更加方便</p><p><img src="/images/image-20211124165125416.png" alt="image-20211124165125416"></p><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><p><img src="/images/image-20211124165033080.png" alt="image-20211124165033080"></p><p><strong>重定向图解</strong></p><p><img src="/images/image-20211113144526510.png" alt="image-20211113144526510"></p><h4 id="重定向示例"><a href="#重定向示例" class="headerlink" title="重定向示例"></a><strong>重定向示例</strong></h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="*方式一"></a>*方式一</h5><p><img src="/images/image-20211113144539395.png" alt="image-20211113144539395"></p><p>结果</p><p><img src="/images/image-20211113144610131.png" alt="image-20211113144610131"></p><h5 id="方式二（推荐使用）"><a href="#方式二（推荐使用）" class="headerlink" title="*方式二（推荐使用）"></a>*方式二（推荐使用）</h5><p>由于发生重定向的情况本来就是响应码302所描述的情况，所以302状态码压根就不需要setStatus设置</p><p>一行代码sendRedirect()，告诉重定向的位置，就能搞定</p><p><img src="/images/image-20211113144616900.png" alt="image-20211113144616900"></p><h4 id="重定向特点"><a href="#重定向特点" class="headerlink" title="重定向特点"></a>重定向特点</h4><p><img src="/images/image-20211113144623582.png" alt="image-20211113144623582"></p><p><strong>怎么理解第3点？</strong></p><p>正如Request的性质，对于发给tomcat的每一次请求，他都会把信息封装到HttpServletRequest对象中。第一次请求的被重定向了，然后需要向Location中的地址发起第二次请求。<strong>两次请求是不一样的了，自然HttpServletRequest对象也就不是同一个对象了</strong>，所以并不共享数据。</p><p><strong>对比请求转发，怎么理解第5点？</strong></p><p>请求转发中填的路径path必须以/打头，就把路径定死了只能在<a href="http://localhosr:8080/%E5%B7%A5%E7%A8%8B%E5%90%8D/">http://localhosr:8080/工程名/</a> 的路径下再往深处访问。<strong>而重定向发回给客户端的Location地址并没有限制</strong>，所以可以访问工程外的资源例如百度网站等</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JavaWeb </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
