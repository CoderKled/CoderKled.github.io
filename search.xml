<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多线程学习笔记与理解</title>
      <link href="/2021/11/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/11/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="关于多线程"><a href="#关于多线程" class="headerlink" title="关于多线程"></a>关于多线程</h1><ul><li><p><strong>Java应用程序的线程</strong></p><p>一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程</p></li><li><p><strong>多线程的优点</strong></p><ol><li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验</li><li>提高计算机系统CPU的利用率</li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li></ol></li><li><p><strong>需要多线程的时机</strong></p><ol><li>程序需要同时执行两个或多个任务</li><li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等</li><li>需要一些后台运行的程序时</li></ol></li></ul><h1 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h1><h2 id="1-关于Thread类"><a href="#1-关于Thread类" class="headerlink" title="1.关于Thread类"></a>1.关于Thread类</h2><p>每个线程都是通过某特定的Thread对象的run()方法来完成操作的。但即便如此，在启动线程时是调用的Thread对象的start()方法而非run()。</p><p><strong>如何理解？</strong></p><p>虽然线程的业务逻辑都写在run()里，但如果直接调用run()，其实就没有创建线程，这就跟普通的通过对象调用普通方法没有区别，可以通过使用getThreadName()发现，如果是使用run()方法来“启动线程”，run()中的输出的线程名依然是main，这就说明run()方法也跑在了main主线程里，并没有多创建一个新线程。调用start()方法的核心在于调用本地方法start0()</p><p><img src="/images/image-20211118142140469.png" alt="image-20211118142140469"></p><p>start0()是一个本地(native)方法，线程是由他创建的，然后才会去执行run()方法里的业务逻辑</p><p>其中，通过Thread对象的start()方法后底层执行的操作顺序是：</p><p>①：启动当前线程</p><p>②：调用当前线程的run()方法</p><h2 id="2-创建线程的两种方式"><a href="#2-创建线程的两种方式" class="headerlink" title="2.创建线程的两种方式"></a>2.创建线程的两种方式</h2><p>创建线程两种方法，一是通过继承Thread类，二是实现Runnable接口。</p><p><strong>因为Java规定单继承，</strong></p><p><strong>另外，实现接口更适合处理多个线程共享数据的情况</strong></p><p>所以一般使用方式二</p><h3 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">//重写Thread类的run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Thread类的子对象</span></span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//t1.start()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码中被注释掉的t1.start：</p><p>​        如果想再开启一个线程并不能用这种方法来启动。<img src="/images/image-20211118142207917.png" alt="image-20211118142207917"></p><p>通过看源码可知如果线程状态不等于0，就会报错。如果要新创建一个线程执行业务逻辑，需要再新new 一个t2对象，再start()。</p><h3 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h3><p>因为Runnable是函数式接口，根据Java8的特性，它可以转换为lamda表达式，由此有多种调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种，正常实现Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;这是方式一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        创建实现类的对象</span><br><span class="line">         MThread m1 = <span class="keyword">new</span> MThread();</span><br><span class="line">        将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(m1);</span><br><span class="line">        t1.start();<span class="comment">//根据源码，start方法里是调用了tagert.run()。target是一个Runnable类型的变量，就是传入的要执行的Mthread1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种，lamada</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是方式二&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;线程二&quot;</span>).start</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-关于yield-和join"><a href="#3-关于yield-和join" class="headerlink" title="3.关于yield()和join()"></a>3.关于yield()和join()</h2><p>首先要分清楚两个方法的宾语。yield是自己主动让出CPU执行权给其他<strong>相同优先级</strong>的线程，具体是谁并不知道。所以这就便于记忆他是个静态方法了，他的调用方法就可以是这几种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.yield();<span class="comment">//当然，因为this用作对实例的引用，main方法属于静态方法，静态方法是没有任何实例的，因此不能用this</span></span><br><span class="line"><span class="keyword">yield</span>();</span><br><span class="line">Thread.currentThread().yield();</span><br></pre></td></tr></table></figure><p>而join()是让自己进入阻塞，指定一个线程来占我的坑，直到他执行完毕才结束我的阻塞状态。所以要标明对方的名字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1.join()</span><br></pre></td></tr></table></figure><h2 id="4-关于线程优先级"><a href="#4-关于线程优先级" class="headerlink" title="4.关于线程优先级"></a>4.关于线程优先级</h2><p><img src="/images/image-20211118123652363.png" alt="image-20211118123652363"></p><p>线程的优先级等级</p><ul><li><p>MAX_PRIORITY：10</p></li><li><p>MIN _PRIORITY：1</p></li><li><p>NORM_PRIORITY：5 —&gt;默认优先级</p></li></ul><p>优先级所涉及的方法</p><ul><li><p>getPriority() ：返回线程优先值</p></li><li><p>setPriority(intnewPriority) ：改变线程的优先级</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1.setPriority(Thread.MAX_PRIORITY);<span class="comment">//设置优先级的例子</span></span><br></pre></td></tr></table></figure><p><strong>这里要注意的是</strong>：这里的优先级终究是个概率问题</p><p>确实高优先级的线程要抢占低优先级线程cpu的执行权。但是这只是从概率上讲，高优先级的线程大概率被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才会被执行。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习笔记</title>
      <link href="/2021/11/10/JVM/"/>
      <url>/2021/11/10/JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1.类文件结构"></a>1.类文件结构</h1><h2 id="1-Class文件结构"><a href="#1-Class文件结构" class="headerlink" title="1.Class文件结构"></a>1.Class文件结构</h2><p>*只有两种数据类型：无符号数，表</p><p>*前四个字节（一个字节放两个十六进制位）是魔数，判定该class是否能被虚拟机接受，0xCAFEBABE</p><p>*紧接着四个字节的前两个是次版本号，后两个是主版本号</p><h3 id="1-常量池"><a href="#1-常量池" class="headerlink" title="1.常量池"></a>1.常量池</h3><p>*从第九个字节开始是常量池，而第九个字节标记了常量池的大小。在class文件中，只有常量池的容量是从1开始计数，其余都是0开始。如第九个字节是0x16 -&gt; 22 -&gt; 即常量池有21项常量1~21</p><p>*每一项常量都是一个表</p><p><em>CONSTANT_Utf8_info型的常量的最大长度就是JAVA中方法或字段的最大长度。*<em>CONSTANT_Utf8_info中length是u2类型，所以如果JAVA程序中定义了超过65535，即64KB的字符变量或者方法名就无法编译</em></em></p><p>*查看字节码内容 javap -verbose</p><h3 id="2-访问标志"><a href="#2-访问标志" class="headerlink" title="2.访问标志"></a>2.访问标志</h3><p>*常量池结束后紧接着的2个字节代表访问标志，用于识别这个Class是接口？abstract？public？等等</p><h3 id="3-类索引，父类索引，接口索引集合"><a href="#3-类索引，父类索引，接口索引集合" class="headerlink" title="3.类索引，父类索引，接口索引集合"></a>3.类索引，父类索引，接口索引集合</h3><p>*因为JAVA中除了Object，都有父类，所以除了Object的JAVA类的父类索引都不为0</p><h1 id="2-类加载机制"><a href="#2-类加载机制" class="headerlink" title="2.类加载机制"></a>2.类加载机制</h1><h2 id="1-类加载时机"><a href="#1-类加载时机" class="headerlink" title="1.类加载时机"></a>1.类加载时机</h2><p>1.加载，验证，准备，初始化，卸载的顺序是固定的，而解析则不一定</p><p>2.六种情况必须立即对类进行初始化：</p><p>​    （1）遇到new,getstatic,putstatic, invokestatic四条指令时，而会生成这四条指令的典型场景有</p><p>​        1.用new实例化对象时<strong>（静态加载）</strong></p><p>​        <strong>2.除被final修饰的静态字段被读取或设置</strong></p><p>​        3.调用静态方法<strong>（静态加载）</strong></p><p>​    （2）对类型进行反射调用时<strong>（动态加载）</strong></p><p>​    <strong>（3）初始化类时，如果他的父类还没初始化，必须先初始化他的父类（接口的这一点和类不同，接口在初始化时，并不要求他的父接口全部完成初始化，只有真的用到父接口时（如引用了父接口内定义的常量）时才会初始化）</strong>  <strong>（属于静态加载）</strong></p><p>​    （4）JVM启动时，用户需指定一个要执行的主类（包含Main的那个类），JVM会对其初始化</p><p>​    （5）对一个MethodHandle实例解析结果为REF_newInvokeSpecial, REF_getStatic, REF_putStatic,  REF_invokeStatic时</p><p>​    （6）默认方法（被default修饰的接口方法）的实现类发生初始化时，必须先初始化这个接口</p><p>3.P264 265 266的被动引用例子，要作为JAVA笔记中代码块调用顺序的补充</p><p>​    （1）通过子类直接引用父类的静态字段，不会触发子类的初始化</p><p>​    （2）通过数组定义来所引用的类，不会触发此类的初始化</p><p>​    （3）与上面第二点呼应。常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，不会触发初始化</p><h2 id="2-类的加载过程"><a href="#2-类的加载过程" class="headerlink" title="2.类的加载过程"></a>2.类的加载过程</h2><p><strong>（验证+准备+解析属于连接过程）</strong></p><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p>1.完成三件事</p><p>（1）通过类名定义此类的二进制流</p><p>（2）将此字节流代表的的静态存储结构转化为方法区运行时数据结构</p><p>（3）在内存中生成代表此<strong>类的java.lang.Class对象</strong>作为方法区这个类的各种数据访问入口</p><p>2.加载尚未完成，链接可能就开始了。但是这俩的开始时间的先后顺序时固定的</p><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><p><img src="/images/image-20211110215400270.png" alt="image-20211110215400270"></p><p>1.如果不通过验证就会抛出java.lang.VerifyError或其子类异常</p><p>验证内容</p><p>1.文件格式验证（CAFEBABE等）</p><p>2.元数据验证（这个类是否有父类（除Object都有父类），有没有继承不允许被继承的类等）</p><p>3.字节码验证（确保程序语义是否合法，符合逻辑）</p><p>4.符号引用验证（确保解析正常）</p><h3 id="3-准备（针对静态）"><a href="#3-准备（针对静态）" class="headerlink" title="3.准备（针对静态）"></a>3.准备（针对静态）</h3><p>1.为静态变量分配内存并设置默认初始值</p><p><strong>注意，如果一个静态变量被final修饰就不适用了，因为final在编译的时候就已经分配了，所以在此阶段会直接给这个常量编译时赋的值而不是默认值了</strong></p><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><p>此阶段将符号引用转化为直接引用</p><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><p><strong>（准备是赋默认值，初始化是赋程序员给的值如num=2，准备只会让num=0）静态代码块，就是在这个时候被调用的（还有静态变量的显式赋值）</strong></p><p>1.初始化阶段就是执行类构造器<client>()的过程,他<strong>只操作静态变量，方法</strong>。因为它是编译器自动收集类中所有对静态变量赋值动作和静态代码块中的语句合并来的</p><p>2.<code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</p><p>理解：</p><p><img src="/images/image-20211110215414618.png" alt="image-20211110215414618"></p><p>这段代码number=20那里初始化不会报错的原因就是因为在准备阶段，静态的number已经被赋值为0了，所以即便是先执行静态代码块中的内容，程序也知道number是已经被声明过的。所以在初始化阶段，会那顺序来初始化，就把Number=0覆盖掉，变成20，然后再覆盖，变成10。 为什么后面会报错呢？因为这种形式的代码只能赋值，不能调用（这叫非法前向调用）</p><p>3.<clinit>()与类的构造器不同。在虚拟机的视角下，类的构造器是<init>()。父类的clinit是优先于自己的</p><p>4.<strong>虚拟机在加载类时只会调用一次clinit()，然后就把它放在方法区</strong>。对于多线程，如果有很多个线程要初始化一个类，<strong>只会有一个线程去执行这个类的clinit() （即执行静态代码块等等），其他线程都会被阻塞在外面直到clinit进行完毕。</strong></p><h2 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3.类加载器"></a>3.类加载器</h2><p><img src="/images/image-20211117144739527.png" alt="image-20211117144739527"></p><p>1.Java的核心类库例如String类库都是由引导加载器加载的，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sout(String.class.getClassLoader())</span><br></pre></td></tr></table></figure><p>输出null值，因为BootStrapClassLoader对象是拿不到的</p><p>对于用户自定义类来说使用的是系统类加载器加载即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sout(A.class.getClassLoader())</span><br></pre></td></tr></table></figure><p>输出的是一个AppClassLoader的对象信息</p><h4 id="1-启动类加载器"><a href="#1-启动类加载器" class="headerlink" title="1.启动类加载器"></a>1.启动类加载器</h4><p><strong>（引导类加载器BootStrapClassLoader）（C/C++写的）</strong></p><p>1.是JVM的一部分，用来加载JAVA的核心类库</p><p>2.没有父加载器<strong>（就他没继承ClassLoader）</strong></p><p>3.<strong>加载包名为java,javax,sun等开头的类</strong></p><h4 id="2-扩展类加载器"><a href="#2-扩展类加载器" class="headerlink" title="2.扩展类加载器"></a>2.扩展类加载器</h4><p>1.派生于ClassLoader</p><p>2**.加载jre/lib/ext中**的字节码文件，如果用户创建的JAR包放在了jre/lib/ext中，那么也会由扩展类加载器来加载</p><h4 id="3-系统类加载器AppClassLoader"><a href="#3-系统类加载器AppClassLoader" class="headerlink" title="3.系统类加载器AppClassLoader"></a>3.系统类加载器AppClassLoader</h4><p>1.是一个内部类</p><p>2.派生于ClassLoader</p><p>3.父类加载器是扩展类加载器</p><p><img src="/images/image-20211110215805077.png" alt="image-20211110215805077"></p><h4 id="4-用户自定义加载器"><a href="#4-用户自定义加载器" class="headerlink" title="4.用户自定义加载器"></a>4.用户自定义加载器</h4><p>后面会讲，使用情况</p><p>1.隔离加载类</p><p>2.修改类加载的方式</p><p>3.扩展加载源</p><p>4.防止源码泄露（因为JAVA可以反编译所以会泄露）</p><h4 id="5-关于ClassLoader"><a href="#5-关于ClassLoader" class="headerlink" title="5.关于ClassLoader"></a>5.关于ClassLoader</h4><p><strong>（凡是ClassLoader下的都是JAVA写的）</strong></p><p>1.是一个抽象类</p><p>2.除BootStraop都的类加载器都继承于他</p><p><img src="/images/image-20211110215814731.png" alt="image-20211110215814731"></p><h2 id="4-双亲委派机制"><a href="#4-双亲委派机制" class="headerlink" title="4.双亲委派机制"></a>4.双亲委派机制</h2><p>1.（跟类的加载比较像，自己是在父类加载完后才进行），如果一个类加载器收到了加载请求，不会自己先去加载而是向父类加载去委托，如果他的父类加载器还存在父类，就一直网上找到达顶层加载器。如果父类的那些加载器可以完成对该类的加载就成功返回，如果不行才会自己去加载<strong>（这就是为什么自己写一个java.lang.String类，然后在自己另一个类中去执行调用，调用不到的原因。因为首先被父类加载器判断是可以由父类加载的，就没自定义加载器什么事了）</strong>（如果顶层（bootstrap）发现这个类不该由我加载，就会给第二层（扩展类加载器）问他行不行，以此类推到子加载器（一般默认是系统加载器APPClassLoader，或者是用户自定义类加载器）发现由他管，就加载） <strong>（蛇形）</strong></p><p><img src="/images/image-20211110215823127.png" alt="image-20211110215823127"></p><h3 id="这就是沙箱安全机制"><a href="#这就是沙箱安全机制" class="headerlink" title="这就是沙箱安全机制"></a>这就是沙箱安全机制</h3><p><strong>一个好的例子（前面是在别的类中执行，现在这里是直接在自定义String类中运行）</strong></p><p><img src="/images/image-20211110215848022.png" alt="image-20211110215848022"></p><p>如果在自己定义的java.lang.String里加一个Main函数，会报错。因为此时就是想去执行对自己定义的String类的加载，由于是java开头的包，就会交由引导类加载器来加载。而引导类加载器要加载的核心类库是没有main方法的，所以报错<strong>（这里体现的就是沙箱安全机制）</strong></p><p>2.优势</p><p>避免重复加载</p><p>保护程序安全，防止核心API被篡改</p><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h2><p>1.判断两个Class是不是同一个</p><p>类的完整名（包括包名要一致）</p><p><strong>加载这个Class的ClassLoader要相同（这个就与双亲委派呼应起来了）</strong></p><p>2.JVM必须只要加载一个类是由引导类（启动类）加载器加载的还是用户类加载器加载的。如果是用户类加载器加载的话，JVM就会将这个类加载器的引用作为类型的信息的一部分放在方法区中<strong>（这就是为什么去获取BootStrapClassLoader的时候返回的是null，而其他调用是能看到类型的）</strong></p><p>3.<img src="/images/image-20211110215909818.png" alt="image-20211110215909818"></p><h1 id="3-运行时数据区"><a href="#3-运行时数据区" class="headerlink" title="3.运行时数据区"></a>3.运行时数据区</h1><p><strong>（重点是虚拟机栈，堆，方法区）</strong></p><p><img src="/images/image-20211110215921594.png" alt="image-20211110215921594"></p><p>红色区域（两个一组）是一个进程，一个虚拟机对应一组（一个虚拟机就会对应一个进程），灰色区域（三个一组）是一个线程对应一组</p><p>假设一个进程有五个线程，那么就会有五组灰色区域，5个线程共用一组红色区域</p><h2 id="1-运行时数据区及线程"><a href="#1-运行时数据区及线程" class="headerlink" title="1.运行时数据区及线程"></a>1.运行时数据区及线程</h2><p><img src="/images/image-20211110215932992.png" alt="image-20211110215932992"></p><p>类比一下也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品。</p><p>每个JVM只有一个Runtime实例</p><p>*<strong>运行时数据区内部图</strong></p><p><img src="/images/image-20211110215945958.png" alt="image-20211110215945958"></p><h3 id="2-程序计数器（PC寄存器）"><a href="#2-程序计数器（PC寄存器）" class="headerlink" title="2.程序计数器（PC寄存器）"></a>2.程序计数器（PC寄存器）</h3><p>1.用于存储下一条指令的地址</p><p>2.每个线程都有自己的程序计数器，是线程私有的，生命周期与线程一致</p><p>3.任何时间，线程都只有一个方法在运行</p><p><img src="/images/image-20211110215955929.png" alt="image-20211110215955929"></p><h4 id="两个常见的面试问题"><a href="#两个常见的面试问题" class="headerlink" title="*两个常见的面试问题"></a>*两个常见的面试问题</h4><p>1.</p><p><img src="/images/image-20211110220003405.png" alt="image-20211110220003405"></p><p>2.</p><p><img src="/images/image-20211110220017045.png" alt="image-20211110220017045"></p><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈*"></a>2.虚拟机栈*</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>优点：跨平台，指令集小</p><p>缺点：性能低（不是指速度慢）</p><p>*对于栈来说没有垃圾回收问题，因为栈只有入栈和出栈两种操作。但是会存在异常的情况</p><p><strong>==============面试题======================</strong></p><p><strong>开发中遇到的异常有哪些？</strong></p><p>首先，在JAVA虚拟机中，java栈的大小可以是动态也可以是静态</p><p>1.如果采用静态的，那么每个线程的java虚拟机栈容量在线程创建的时候就定好了。如果线程请求分配的容量大于原本的容量，就会抛出StackOverFlowError</p><p>2.如果采用动态的，（1）在尝试扩展的时候无法申请到足够内存，（2）或在创建新线程时没有足够内存区创建对应的虚拟机栈，就会抛出OutOfMemoryError</p><p><strong>================================================</strong></p><p>*栈是运行时的单位，堆是存储的单位</p><p>*<strong>每个线程都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应着一次次的JAVA方法调用</strong>。虚拟机栈是线程私有的</p><p>虚拟机栈的作用：</p><p>管程序运行，它保存方法的局部变量（8种基本数据类型，对象的<strong>引用地址</strong>（对象本身在堆中）），部分结果，并参与方法的调用和返回</p><h3 id="2-栈帧（栈的存储单位）"><a href="#2-栈帧（栈的存储单位）" class="headerlink" title="2.栈帧（栈的存储单位）"></a>2.栈帧（栈的存储单位）</h3><p>1.每个线程都有自己的栈，里面的数据的基本单位是栈帧</p><p>2.每个方法对应一个栈帧</p><p>3.一个时间点上只会有一个活动的栈帧</p><p>4.不同线程中的栈帧是不能相互引用的（很好理解，因为每个线程本来就是相对独立的，他们只是可以共享他们所在的那个进程的资源）</p><p>5.Java中有两种返回方式（1）正常的return（void函数其实在结束的时候也会return）（2）抛出异常（指的是未捕获的异常，抛给调用自己的方法）。 两种方式都将导致当前栈帧弹出</p><h4 id="1-栈帧的内部结构"><a href="#1-栈帧的内部结构" class="headerlink" title="1.栈帧的内部结构"></a>1.栈帧的内部结构</h4><p><img src="/images/image-20211110220040997.png" alt="image-20211110220040997"></p><h4 id="2-局部变量表"><a href="#2-局部变量表" class="headerlink" title="2.局部变量表*"></a>2.局部变量表*</h4><p>1.是一个数组，用于存储方法参数和在方法体内的局部变量（即各类基本数据类型，对象的引用，以及returnAddress类型）</p><p>2.由于是建立在线程的栈上，是线程的私有数据，所以不存在安全问题</p><p>3.所需要的容量大小在编译器就已经确定了，在运行期间不会更改</p><p><img src="/images/image-20211110220049940.png" alt="image-20211110220049940"></p><p><strong>注意一下成员变量和局部变量的区别</strong></p><p>*<strong>局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></p><h5 id="关于slot的理解"><a href="#关于slot的理解" class="headerlink" title="关于slot的理解"></a>关于slot的理解</h5><p>1.是局部变量表里最基本单元</p><p>2.用于存储基本数据类型，引用类型以及returnAddress类型</p><p><strong>3.32位数据占一个槽，64位的占两个（long，double）</strong></p><p>4.<strong>如果当前帧是由构造方法或者普通实例方法（即非静态的方法）创建的，那么对于这个对象的引用this就会放在index为0的slot处</strong>（每个方法或这个构造方法其实都隐含着this的）  <strong>（这也是为什么static方法中是不能用this的（因为this不存在于静态方法的局部变量表中））</strong></p><p><img src="/images/image-20211110220102629.png" alt="image-20211110220102629"></p><p>5.slot是可以重复利用的，当局部变量表里的变量被回收时（就比如</p><p><img src="/images/image-20211110220111037.png" alt="image-20211110220111037"></p><p>b会被回收，所以b的位子就被回收给c用了，所以这个局部变量表的长度是3而不是4</p><h4 id="1-操作数栈"><a href="#1-操作数栈" class="headerlink" title="1.操作数栈*"></a>1.操作数栈*</h4><p>1.主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</p><p>2.如果调用的方法有返回值，那么它结束后，返回值会被压入当前栈帧的<strong>操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令</p><p>=================<strong>操作过程</strong>==========================</p><p><img src="/images/image-20211110220119360.png" alt="image-20211110220119360"></p><p>要注意，局部变量表的0位置在图中没画出来，0位置就是这个类的this</p><p><img src="/images/image-20211110220128014.png" alt="image-20211110220128014"></p><p><img src="/images/image-20211110220136348.png" alt="image-20211110220136348"></p><p><img src="/images/image-20211110220145729.png" alt="image-20211110220145729"></p><p><img src="/images/image-20211110220153944.png" alt="image-20211110220153944"></p><p><strong>===================================================</strong></p><h4 id="2-帧数据区（一些附加信息，动态链接，方法返回地址）"><a href="#2-帧数据区（一些附加信息，动态链接，方法返回地址）" class="headerlink" title="2.帧数据区（一些附加信息，动态链接，方法返回地址）"></a>2.帧数据区（一些附加信息，动态链接，方法返回地址）</h4><h5 id="1-动态链接（指向运行时常量池的方法引用）"><a href="#1-动态链接（指向运行时常量池的方法引用）" class="headerlink" title="1.动态链接（指向运行时常量池的方法引用）"></a>1.动态链接（指向运行时常量池的方法引用）</h5><p>*在Java源文件被编译到字节码文件中后，所有变量和方法都会作为<strong>符号引用</strong>保存在class文件的常量池里</p><p>*描述一个方法（一个方法对应一个栈帧）调用另一个其他方法时，就是通过常量池中指向方法的符号引用来表示的。<strong>动态链接的作用就是把符号引用转化为直接引用</strong>（在类加载的解析阶段进行）（符转直其实就是看着符号标的位置去方法区找对应的方法）</p><p><img src="/images/image-20211110220206569.png" alt="image-20211110220206569"></p><p>//常量池中的符号引用</p><p><img src="/images/image-20211110220214214.png" alt="image-20211110220214214"></p><p>//代码中指向常量池的引用  ‘’#’’（也就是动态链接）</p><p><img src="/images/image-20211110220221206.png" alt="image-20211110220221206"></p><p>目前的结构图</p><p><img src="/images/image-20211110220229211.png" alt="image-20211110220229211"></p><h6 id="为什么需要常量池呢？"><a href="#为什么需要常量池呢？" class="headerlink" title="为什么需要常量池呢？"></a>为什么需要常量池呢？</h6><p>常量池提供一些符号和常量，便于指令识别。这样做也就不会让class文件因为装了太多方法和常量而变得很大，引用就好了。</p><h5 id="2-方法的调用"><a href="#2-方法的调用" class="headerlink" title="2.方法的调用**"></a>2.方法的调用**</h5><p>静态链接：当一个字节码文件被装载进JVM内部时，<strong>目标方法在编译期可知且运行期保持不变</strong>。这种情况的符号引用转直接引用叫静态链接</p><p>（早期绑定）</p><p>动态链接：<strong>被调方法在编译器无法被确定下来</strong>，只有在程序运行期才能将符号引用转化为直接引用，叫动态链接</p><p>（晚期绑定）</p><p>非虚方法：</p><p>编译器就确定了具体调用版本且在运行时不改变</p><p>静态，<strong>私有</strong>，final(用invokevirtue调但他不是虚方法)，实例构造器，<strong>父类方法</strong>都是非虚方法</p><p>其他的方法就都是虚的</p><p>非虚方法在编译时是非常确定会去哪里调哪个方法</p><p><img src="/images/image-20211110220240259.png" alt="image-20211110220240259"></p><p>lamda表达式就是用invokedynamic来调的，因为只有运行的时候才知道lamda表达式中的类型</p><p>JAVA是静态类型语言，Python是动态类型语言</p><p><img src="/images/image-20211110220248687.png" alt="image-20211110220248687"></p><p>静态和动态的区别在于，静态类型语言判断变量自身的类型信息，动态语言通过变量的值来判断类型（变量没有类型，而变量值有）</p><h6 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h6><p>*为了提高性能，不每次都在调用时向上找找找，于是JVM在方法区建立虚方法表（因为非虚方法都很确定在哪里调，所以不需要在这个表里）表中存放着各个方法的入口（就不需要向上向上找了）</p><p>*虚方法表何时创建？</p><p>在类加载链接阶段创建，当类准备阶段完成后，类的方法表也初始化完毕</p><p><strong>虚方法表示例</strong></p><p><img src="/images/image-20211110220302162.png" alt="image-20211110220302162"></p><h5 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h5><p>*存储该方法在pc寄存器（存储下一条要执行的指令的值）中的值</p><p>*无论目前的方法所调用的那个方法是正常退出还是出现未处理异常而非正常退出，都会返回到被调用的位置。</p><p><strong>方法的退出本质就是当前栈帧出栈的过程</strong></p><p>正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法指令的下一条指令的地址</strong></p><p>异常退出时，返回地址通过异常表确定，栈帧一般不会保存这部分信息</p><p><strong>这也是为什么异常退出不会给调用者返回任何值</strong></p><h5 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h5><p>栈帧允许携带与JVM实现相关的一些附加信息，不能保证每个栈帧都有</p><h3 id="3-虚拟机栈的相关面试题"><a href="#3-虚拟机栈的相关面试题" class="headerlink" title="3.虚拟机栈的相关面试题**"></a>3.虚拟机栈的相关面试题**</h3><p><strong>1.举例栈溢出的情况</strong></p><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM（OutOfMemoryError）</p><p>（可通过-Xss来设置栈的大小）</p><p><strong>2.调整栈大小，就能保证不出现溢出吗</strong></p><p>可以视情况做到，但是不能保证</p><p>死循环的话不管栈有多大都会溢出（栈小很快溢出，栈大慢点溢出罢了）</p><p><strong>3.分配的栈内存越大越好吗？</strong></p><p>理论上越大，能降低出现SOF的概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p><p><strong>4.垃圾回收是否会涉及到虚拟机栈</strong></p><p>不会</p><p><img src="/images/image-20211110220318887.png" alt="image-20211110220318887"></p><p><img src="/images/image-20211110220326382.png" alt="image-20211110220326382"></p><p><strong>5.方法中定义的局部变量是否线程安全</strong></p><p><a href="https://youthlql.gitee.io/post/5b1b6560.html">https://youthlql.gitee.io/post/5b1b6560.html</a></p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p><img src="/images/image-20211110220344355.png" alt="image-20211110220344355"></p><p>用来装native修饰的本地方法</p><p><img src="/images/image-20211110220353140.png" alt="image-20211110220353140"></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆*"></a>堆*</h2><p>*每一个JVM实例（也就是每一个进程）都对应一个堆内存</p><p>*可处于物理上不连续的空间中，但是逻辑上是连续的</p><p>*<strong>线程共享堆，但不是绝对的共享。里面也可以划分线程线程私有的缓冲区</strong>TLAB</p><p>*所有的对象实例（几乎所有）（注意是实例，引用在虚拟机栈里）和数组，都在堆里</p><p>*</p><p><img src="/images/image-20211110220400965.png" alt="image-20211110220400965"></p><p>*设置堆空间大小（年轻代+老年代，不包括元空间）</p><p><img src="/images/image-20211110220411446.png" alt="image-20211110220411446"></p><p>ms: memory start</p><h1 id="没分章节的内容"><a href="#没分章节的内容" class="headerlink" title="*没分章节的内容"></a>*没分章节的内容</h1><h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><p><strong>为什么要用本地方法？</strong></p><p>1.C , C++盛行，需要交互</p><p>2.要与操作系统交互，因为操作系统是C/C++写的，所以需要本地方法</p><p>3.Sun的解释器是C实现的</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.jsp学习笔记</title>
      <link href="/2021/11/10/2.jsp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/10/2.jsp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>是java的服务器页面</p><p>主要作用是代替Servlet程序回传Html页面的数据</p><p>（Servlet程序回传html页面数据的开发成本和维护成本都高）</p><h1 id="1-jsp的访问方式"><a href="#1-jsp的访问方式" class="headerlink" title="1.jsp的访问方式"></a>1.jsp的访问方式</h1><p><img src="/images/image-20211112145133829.png" alt="image-20211112145133829"></p><h1 id="2-jsp的本质"><a href="#2-jsp的本质" class="headerlink" title="2.jsp的本质"></a>2.jsp的本质</h1><p>*<strong>jsp页面本质上是servlet程序</strong></p><p>第一次访问jsp页面时，Tomcat服务器回把jsp翻译成为一个java源文件并将它编译，生成.class的字节码文件。而打开该java文件后看到的类直接继承了HttpJspBase类</p><p>HttpJspBase类继承了HttpServlet</p><p>被翻译出来的java源文件实际上也是通过HttpServletResponse的输出流回传html页面数据</p><p><img src="/images/image-20211112145148165.png" alt="image-20211112145148165"></p><h1 id="3-jsp语法"><a href="#3-jsp语法" class="headerlink" title="3.jsp语法"></a>3.jsp语法</h1><h2 id="1-头部page指令及属性"><a href="#1-头部page指令及属性" class="headerlink" title="1.头部page指令及属性"></a>1.头部page指令及属性</h2><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211112145200115.png" alt="image-20211112145200115"></p><p>关于第ii点，可以通过查看.java源文件得到证明</p><p><img src="/images/image-20211112145224101.png" alt="image-20211112145224101"></p><p>当把autoFlash设定为false并把buffer属性改小，若此时jsp页面的数据过多就会报如上的缓冲区溢出错误。所以，没事不要去改autoFlash和buffer属性。</p><p><img src="/images/image-20211112145237297.png" alt="image-20211112145237297"></p><p><strong>关于erropage的路径一定要注意</strong>。前面提到过，浏览器和服务器对于斜杠/的解析结果时不一样的。而jsp本质是servlet程序，所以erropage里若要写斜杠/打头，他标识的是hrrp://localhost:8080/工程路径/。<strong>这个路径的映射到IDEA代码的webapp目录下</strong></p><p><img src="/images/image-20211112145243412.png" alt="image-20211112145243412"></p><p>这三项一般都不会去改，就让他默认就好了</p><h2 id="2-jsp脚本"><a href="#2-jsp脚本" class="headerlink" title="2.jsp脚本"></a>2.jsp脚本</h2><h3 id="a-声明脚本（用的少）"><a href="#a-声明脚本（用的少）" class="headerlink" title="a.声明脚本（用的少）"></a>a.声明脚本（用的少）</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! 声明java代码 %&gt;</span><br></pre></td></tr></table></figure><p>作用：给jsp翻译出来的Java类定义属性和方法，甚至是静态代码块，内部类等等</p><p>他是放在<strong>jsp名_jsp类</strong>中的</p><p>例如：<img src="/images/image-20211112145258063.png" alt="image-20211112145258063"></p><p>在.java文件中可以查看到</p><p><img src="/images/image-20211112145308565.png" alt="image-20211112145308565"></p><h3 id="b-表达式脚本（较常用）"><a href="#b-表达式脚本（较常用）" class="headerlink" title="b.表达式脚本（较常用）"></a>b.表达式脚本（较常用）</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= 表达式 %&gt;</span><br></pre></td></tr></table></figure><p>作用：在jsp页面上输出数据。其输出方式本质上（即在.java文件 中是以out.print()来输出的）</p><p>就比如上例的map </p><p>如果在jsp上写&lt;%=map%&gt;，调用界面时显示的不是map这三个字母而是System.out.println(map)的结果。</p><p>概括起来就是，表达式脚本里可以写对象</p><p><strong>表达式脚本的特点</strong></p><p>1.所有表达式脚本都会被翻译到jsp对应的.java文件中的_jspService()方法中</p><p>2.都会作为out.write()的参数输出到页面上</p><p>3.由于所有表达式脚本都会被翻译到_jspService()中，所以__jspService()方法中的对象都可以直接使用</p><p>4.表达式脚本的末尾不能加分号;</p><p><strong>如何理解第三点？</strong></p><p>即便在jsp代码没有定义HttpServletRequest request，但是依然可以在jsp中写</p><p><img src="/images/image-20211112145319993.png" alt="image-20211112145319993"></p><p>然后在浏览器上用?加上参数，就可以在jsp页面上显示参数中username的值</p><p><strong>第四点的原因？</strong></p><p>表达式脚本的内容最终是一整个放到out.print()中，如果我在表达式参数中因为习惯加了一个;例如</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= map; %&gt;</span><br></pre></td></tr></table></figure><p>那他实际上就是out.print(map;)，妥妥的语法错误</p><h3 id="c-代码脚本"><a href="#c-代码脚本" class="headerlink" title="c.代码脚本"></a>c.代码脚本</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%  正常的java语句 %</span><br></pre></td></tr></table></figure><p>作用：可以在Jsp中编写需要的功能。</p><p>*代码脚本中的内容就是纯天然的不加别的东西地放在_jspService()里，它并不像表达式脚本一样，翻译后的内容是由out.print()包起来的</p><p>*能写的例如有if语句，for循环</p><p>*要注意如果是写方法啥的要用声明脚本</p><p>*虽然很明显，但是还是要区分以下，因为表达式脚本是放在out.print()中输出的，out是作为response存在的，所以他输出的内容是显示在浏览器页面中的。但是在代码脚本中，习惯性还是写的System.out.println()，所以输出的内容是在控制台并非页面上</p><p>*和表达式脚本相似，因为大家都是被翻译后放到_jspService()中，所以_jspService()方法中传进来的参数，定义过的变量啥的都能直接用</p><p><strong>代码脚本特点：</strong></p><p>1.被翻译后都放在_jspService()中</p><p>2.由1，_jspService()中的现有对象都可以直接使用</p><p>3.代码脚本可以由多个代码脚本块组合完成一个完整的java语句</p><p>4.代码脚本和表达式脚本组合使用可以将结果往页面上输入</p><p><strong>第三点举例</strong></p><p><img src="/images/image-20211112145333627.png" alt="image-20211112145333627"></p><p>两个残缺的代码块可以放进去组成一句完整的代码</p><p><strong>第四点举例</strong></p><p><img src="/images/image-20211112145342356.png" alt="image-20211112145342356"></p><p>这就把0~10输出到了页面上，而不是控制台。</p><p>由此衍生出做表格的妙用，不需要像之前一样复制好几行<tr></p><p><img src="/images/image-20211112145357205.png" alt="image-20211112145357205"></p><p><img src="/images/image-20211112145405461.png" alt="image-20211112145405461"></p><h2 id="3-jsp注释"><a href="#3-jsp注释" class="headerlink" title="3.jsp注释"></a>3.jsp注释</h2><p>在jsp中可以写三种注释</p><p>1.html注释<!--注释 --></p><p>会被翻译到java源代码中在_jspService()方法中，以out.write()输出</p><p>2.java注释/*   */  //</p><p>会被翻译到java源代码中</p><p>3.jsp注释&lt;%– –%&gt;</p><p>可以注释掉jsp页面中所有代码包括以上两个</p><h2 id="4-jsp九大内置对象"><a href="#4-jsp九大内置对象" class="headerlink" title="4.jsp九大内置对象"></a>4.jsp九大内置对象</h2><p>指Tomcat在翻译jsp页面成为Servlet源码后，内部提供的九大对象</p><p><img src="/images/image-20211112145418768.png" alt="image-20211112145418768"></p><p>其中，exception对象需要在头部page指令中将isErrorPage的值设定为true，才会出现。</p><h2 id="5-jsp四大域对象"><a href="#5-jsp四大域对象" class="headerlink" title="5.jsp四大域对象"></a>5.jsp四大域对象</h2><p>在以上内置对象中，有四个是域对象</p><p><img src="/images/image-20211112145426300.png" alt="image-20211112145426300"></p><h2 id="6-out输出和response-getWriter输出的区别"><a href="#6-out输出和response-getWriter输出的区别" class="headerlink" title="6.out输出和response.getWriter输出的区别"></a>6.out输出和response.getWriter输出的区别</h2><p><img src="/images/image-20211112145524558.png" alt="image-20211112145524558"></p><p>由此可以得到，如果代码是</p><p><img src="/images/image-20211112145533771.png" alt="image-20211112145533771"></p><p>out1会先加到response缓冲区，然后out2放到out缓冲区，然后两个response紧接着放在out1之后，最后由于jsp所有代码执行完毕，out.flush又执行一次，out2由out缓冲区加载到response缓冲区末尾。最终结果就是</p><p><img src="/images/image-20211112145541344.png" alt="image-20211112145541344"></p><p>由于jsp翻译后，底层源码都是用out来输出，所以一般统一使用out来输出避免打乱页面输出内容顺序</p><h2 id="7-out的print和write方法区别"><a href="#7-out的print和write方法区别" class="headerlink" title="7.out的print和write方法区别"></a>7.out的print和write方法区别</h2><p><strong>先说结论：在jsp页面中可以统一使用out.print()进行输出</strong></p><p>由实验结果表明</p><p>out.write和out.print输出字符串类型数据都没有任何问题</p><p>对于print，通过源码看看到</p><p><img src="/images/image-20211112145553199.png" alt="image-20211112145553199"></p><p>输出任意数据都没问题，因为底层，print都将数据转化成字符串然后调用write进行输出</p><p>而为什么write输出其他类型的数据就会出问题，根据源码</p><p><img src="/images/image-20211112145600912.png" alt="image-20211112145600912"></p><p>向write传递的参数会被强转为char存储在输出的缓冲数组中，<strong>而用char强转就是他只能输出字符串的关键所在</strong>，用char强转所得到的是参数c所对应的ascii码字符，就与原值相悖了</p><h2 id="8-jsp常用标签"><a href="#8-jsp常用标签" class="headerlink" title="8.jsp常用标签"></a>8.jsp常用标签</h2><p>随着Java EE技术的革新，现在对jsp的使用已经多了，jsp的作用基本只剩下输出数据，jsp中不会包含多复杂的代码，所以一搬用静态包含就够了（当然知识还是都要学）</p><h3 id="a-静态包含"><a href="#a-静态包含" class="headerlink" title="a.静态包含"></a>a.静态包含</h3><p><img src="/images/image-20211112145608932.png" alt="image-20211112145608932"></p><p>依然是要注意这个斜杠/。（但是好像不加斜杠，默认是帮忙加了，因为不加斜杠的初始路径也是webapp）</p><p><img src="/images/image-20211112145616884.png" alt="image-20211112145616884"></p><p><img src="/images/image-20211112145626428.png" alt="image-20211112145626428"></p><p>可以看到，静态包含的特点</p><p>1.静态包含不会翻译被包含的jsp页面</p><p>2.静态包含是把被包含地jsp页面代码拷贝到包含的位置，用write包起来进行输出</p><h3 id="b-动态包含"><a href="#b-动态包含" class="headerlink" title="b.动态包含"></a>b.动态包含</h3><p><img src="/images/image-20211112145640288.png" alt="image-20211112145640288"></p><p>动态包含也可以和静态包含一样把被包含的内容输出到包含的位置</p><p>不过</p><p><strong>动态包含特点：</strong></p><p>1.动态包含会把被包含的jsp页面翻译出来成为.java</p><p><img src="/images/image-20211112145653981.png" alt="image-20211112145653981"></p><p>2.在使用包含的那个jsp（这里把他称为也理解为<strong>main.jsp</strong>）被翻译出来的.java文件中，被包含的jsp文件不同于静态包含，静态包含是直接拷贝过去用write包起来，而动态包含是使用代码去调用被包含的jsp页面（即<strong>footer2.jsp</strong>）</p><p><img src="/images/image-20211112145701596.png" alt="image-20211112145701596"></p><p>3.动态包含还可以传递参数</p><p><img src="/images/image-20211112145711363.png" alt="image-20211112145711363"></p><p><img src="/images/image-20211112145719800.png" alt="image-20211112145719800"></p><p><img src="/images/image-20211112145728262.png" alt="image-20211112145728262"></p><p><strong>第二第三点的底层原理</strong></p><p><img src="/images/image-20211112145736660.png" alt="image-20211112145736660"></p><p>可以通过看第二点中的图，看出，main.jsp是把自己的response和request内置对象传给footer2.jsp。即footer2的内置对象是对main的内置对象的引用。所以他俩的request和response都指向的是同一个out缓冲区。所以当main的out.write()执行后（注意图上的write写错了），开始调用footer2的out.write()。等代码全部结束后，out缓冲区自行进行flush操作，最终就得到了显示的正常结果。（个人觉得很像在一个方法里调用另一个方法，当主方法调用子方法时是把子方法压栈，然后主方法等到子方法执行完后才恢复执行，最终统一flush）</p><h3 id="c-请求转发"><a href="#c-请求转发" class="headerlink" title="c.请求转发"></a>c.请求转发</h3><p><img src="/images/image-20211112145752046.png" alt="image-20211112145752046"></p><p>都是请求转发，这两句代码没啥区别（两个路径按理说都应在前面加上/，但是不加也没问题，默认是从webapp开始的）</p><p><img src="/images/image-20211112145809067.png" alt="image-20211112145809067"></p><p>在提示中，加了/是可以往java文件夹里索引的，但是通过实验，同时就单单通过这个IDEA提示也可以看到，不加/也能索引到</p><h1 id="4-Listener监听器"><a href="#4-Listener监听器" class="headerlink" title="4.Listener监听器"></a>4.Listener监听器</h1><p>1.是Java EE的规范，是一个接口</p><p>2.作用是，监听某种事务的变化。然后通过回调函数，回馈给客户（程序）去做响应处理</p><p>随着技术变革，很多监听器都不用了，唯独</p><h2 id="1-ServletContextListener"><a href="#1-ServletContextListener" class="headerlink" title="1.ServletContextListener"></a>1.ServletContextListener</h2><p>*ServletContextListener可以监听ServletContext对象的创建和销毁</p><p>*由前面所学可知，ServletContext对象随着web工程的创建而创建，web工程停止时销毁</p><p>*该监听器监听到创建和销毁后都会调用其方法反馈，分别是</p><p><img src="/images/image-20211112145828040.png" alt="image-20211112145828040"></p><p>使用步骤：</p><p>1.编写类实现ServletContextListener接口</p><p>2.实现以上两个回调方法</p><p>3.到web.xml中配置监听器</p><p><img src="/images/image-20211112144229478.png" alt="image-20211112144229478"></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JavaWeb </tag>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射与动态代理</title>
      <link href="/2021/11/10/%E6%B5%85%E8%B0%88%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/11/10/%E6%B5%85%E8%B0%88%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h1><h2 id="1-动态语言-amp-静态语言"><a href="#1-动态语言-amp-静态语言" class="headerlink" title="1.动态语言&amp;静态语言"></a>1.动态语言&amp;静态语言</h2><p>从声明变量方式看动态与静态语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String author = <span class="string">&quot;CoderKled&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dream <span class="operator">=</span> <span class="string">&quot;Tencet&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distance = <span class="string">&quot;far&quot;</span></span><br></pre></td></tr></table></figure><p>可以看出动态语言与静态语言的区别之一在于：</p><p>静态语言判断变量自身的类型信息需要靠声明</p><p>动态语言的变量的类型信息则是根据其值来判断</p><p>Java不是动态语言，但是可以被称为是“准动态”，其原因在于Java具有一定的动态性，它是由反射机制等所赋予的。</p><h2 id="2-反射功能"><a href="#2-反射功能" class="headerlink" title="2.反射功能"></a>2.反射功能</h2><ul><li><strong>在运行时</strong>分析类的能力（如判断对象所属类，获取类的所有成员变量与方法信息等）</li><li>在运行时检查对象（例如，编写一个适用于所有类的toString方法）</li><li>实现泛型数组操作代码</li><li>利用Method对象</li><li>生成动态代理</li></ul><p>*反射可以在不通过修改源码的情况下控制程序</p><p>*在反射中，方法也是对象，可以用方法对象来调用方法</p><h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><h2 id="1-获取Class对象"><a href="#1-获取Class对象" class="headerlink" title="1.获取Class对象"></a>1.获取Class对象</h2><ul><li>方式一：通过一个类的对象getClass()  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Coder kled = <span class="keyword">new</span> Coder();</span><br><span class="line">Class c = kled.getClass();</span><br></pre></td></tr></table></figure><p>此处呼应5所讲，系统维护的是一个运行时类型标识，所以getClass得到的是运行类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line">System.out.println(cat.getClass());</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211110210804735.png" alt="image-20211110210804735"></p><ul><li>方式二：静态方法forName()  注意里面最好写全路径”com.string_.Cat”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;Coder&quot;</span>;</span><br><span class="line">Class c = Class.forName(name);</span><br></pre></td></tr></table></figure><ul><li>方式三：类型.class（可以是基本数据类型或void关键字）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = <span class="keyword">int</span>.class;</span><br><span class="line">Class c2 = String.class;</span><br><span class="line">Class c3 = Double[].class;</span><br><span class="line">Class c4 = Animal.class</span><br></pre></td></tr></table></figure><ul><li>方式四：ClassLoader，要注意loadClass中的的参数可不是路径，是类的全类名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = ReflectionTest.class.getClassLoader();<span class="comment">//ReflectionTest是本类类名</span></span><br><span class="line">Class c = classLoader.loadClass(<span class="string">&quot;Coder&quot;</span>);</span><br></pre></td></tr></table></figure><p>由于虚拟机只为每个类型管理<strong>唯一一个</strong>Class对象，所以是可以用==来对两个Class进行对比的。</p><h2 id="2-与instanceof"><a href="#2-与instanceof" class="headerlink" title="2.==与instanceof"></a>2.==与instanceof</h2><p>判断对象是否是这个特定类或者是它的子类的一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(cat.getClass() == Cat.class);</span><br><span class="line">System.out.println(cat.getClass() == Animal.class);</span><br><span class="line">System.out.println(cat <span class="keyword">instanceof</span>  Animal);</span><br><span class="line">System.out.println(cat <span class="keyword">instanceof</span>  Cat);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211110210732793.png" alt="image-20211110210732793"></p><p>此处要关注第一行代码正确的理由。因为一个运行时类只会对应一个Class实例。例如，一个Cat类，不论他new 多少个cat1 cat2 cat3对象。这些catx.getClass()得到的结果都是相同的（第5会细说）</p><h2 id="3-getConstructor"><a href="#3-getConstructor" class="headerlink" title="3.getConstructor()"></a>3.getConstructor()</h2><p>若有一个Class类型的对象，可以通过getConstructor()来获取他的构造器对象，但是要根据以下代码注意区分</p><p><img src="/images/image-20211110212258605.png" alt="image-20211110212258605"></p><p><img src="/images/image-20211110212309805.png" alt="image-20211110212309805"></p><p>综上所述，就可以通过反射来创建一个对象</p><p>//Animal类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> age, String category)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.category = category;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;wu~~~~&quot;</span>+content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Animal&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, category=&#x27;&quot;</span> + category + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;com.string_.Animal&quot;</span>);</span><br><span class="line">Constructor constructor = clazz.getConstructor(<span class="keyword">int</span>.class, String.class);</span><br><span class="line">Animal dog = (Animal) constructor.newInstance(<span class="number">3</span>, <span class="string">&quot;dog&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211116191532510.png" alt="image-20211116191532510"></p><h2 id="4-反射调用属性和方法"><a href="#4-反射调用属性和方法" class="headerlink" title="4.反射调用属性和方法"></a>4.反射调用属性和方法</h2><p><strong>即便是private的成员（前提是调用setAccessible()并赋值为true），依然可以通过反射来调用</strong></p><p>通过反射获取的属性是Field类，方法是Method类，构造器是Constructor类</p><ul><li>下面是调用私有字段的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);<span class="comment">//这也是调用私有所必须的，若使用getField()就不能获取私有的字段了</span></span><br><span class="line">age.setAccessible(<span class="keyword">true</span>);<span class="comment">//若要调用private的字段就必须这一步，否则会报IllegalAccessException异常</span></span><br><span class="line">age.set(dog,<span class="number">5</span>);</span><br><span class="line">System.out.println(dog.toString());</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211116192817954.png" alt="image-20211116192817954"></p><ul><li>调用公有方法，可前面调用私有形成对比</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method shout = clazz.getMethod(<span class="string">&quot;shout&quot;</span>,String.class);</span><br><span class="line">shout.invoke(dog,<span class="string">&quot;hello~~~~&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211116193532296.png" alt="image-20211116193532296"></p><p>invoke方法就可以类比于普通对象的直接调用例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Animal(<span class="number">5</span>,<span class="string">&quot;dog&quot;</span>).shout(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>所以如果用反射调用的方法有返回值，那是可以直接接收的，假设此时shout()方法是一个返回值类型为int的方法，那么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = (<span class="keyword">int</span>) shout.invoke(dog,<span class="string">&quot;hello~~~~&quot;</span>);<span class="comment">//这样调用是正确的</span></span><br><span class="line">Object res = shout.invoke(dog,<span class="string">&quot;hello~~~~&quot;</span>);<span class="comment">//这样也是可以的</span></span><br></pre></td></tr></table></figure><h2 id="5-Class类的理解"><a href="#5-Class类的理解" class="headerlink" title="5.Class类的理解"></a>5.Class类的理解</h2><p><strong>反射机制和封装性有矛盾？</strong></p><p>反射机制解决能不能调用的问题，但是封装性是对程序员的建议，二者并不矛盾。例如单例模式就建议不用再去new一个对象，直接用他造好的就可以了。private也是告诉程序员这个成员你用不着，所以不建议使用。</p><p><strong>类的加载过程</strong></p><p>程序经过Javac.exe命令后，会生成一个或多个.class字节码文件，接着用Java.exe命令对字节码文件进行解释运行，这就是将字节码文件加载到内存中。加载完之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。就像一面镜子，透过它就能看到该对象所属类的信息。</p><p>Java运行时系统始终会为所有对象维护一个<strong>运行时类型标识</strong>，这个信息会跟踪每个对象所属的类。虚拟机利用运行时类型信息选择要执行的方法。要注意，<strong>一个运行时类只对应一个Class实例</strong>，不过JVM的垃圾回收机制是可以回收这些Class对象的</p><p><strong>那么呼应1中获取Class对象，哪些类型可以有Class对象？</strong></p><p>（1）普遍认为的class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类<br>（2）interface：接口<br>（3）[]：数组（包括多维数组 ）<br>（4）enum：枚举<br>（5）注解<code>@interface -&gt; Override.class</code><br>（6）基本数据类型<br>（7）void</p><p>而且提一点，对于<strong>相同数据类型</strong>（如果一个数组是char类型一个是int类型那肯定就不一样了）的数组，是要数组的维度一样，那他们的Class就是同一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">Class aclazz = a.getClass();</span><br><span class="line">Class bclazz = b.getClass();</span><br><span class="line">System.out.println(s10 == s11);   <span class="comment">//输出为true</span></span><br></pre></td></tr></table></figure><h2 id="6-用ClassLoader加载Properties"><a href="#6-用ClassLoader加载Properties" class="headerlink" title="6.用ClassLoader加载Properties"></a>6.用ClassLoader加载Properties</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">pros.load(is);</span><br></pre></td></tr></table></figure><p>要注意的是，对于getResourseAsStream方法的参数，其默认路径是当前module下的src文件下。而对于web工程文件，默认是resourse文件夹。</p><h2 id="7-获取类对象"><a href="#7-获取类对象" class="headerlink" title="7.获取类对象"></a>7.获取类对象</h2><p>首先，根据前面提到的四种获取Class对象的方法获取。要注意的是，这里也是可以使用泛型的，当明确标注了类名后，后面的代码就可以直接标注具体类类型了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Animal&gt; animalClass = Animal.class;</span><br><span class="line">Animal animal = animalClass.newInstance();<span class="comment">//这是调用Animal的公有空参构造器（如果没有空参构造器或对构造器访问权限不够会报异常）</span></span><br></pre></td></tr></table></figure><p>所以在javabean中要求提供一个public的空参构造器。</p><p>原因：</p><p>1.便于通过反射，创建运行时类的对象         </p><p>2.便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.Servlet学习笔记</title>
      <link href="/2021/11/09/1.Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/09/1.Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Web中的路径！"><a href="#Web中的路径！" class="headerlink" title="Web中的路径！"></a>Web中的路径！</h1><p><img src="/images/image-20211113142534772.png" alt="image-20211113142534772"></p><h2 id="Web中的斜杠-区分"><a href="#Web中的斜杠-区分" class="headerlink" title="Web中的斜杠/区分"></a>Web中的斜杠/区分</h2><p><img src="/images/image-20211113142542326.png" alt="image-20211113142542326"></p><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="通过Dom4j读取XML文件"><a href="#通过Dom4j读取XML文件" class="headerlink" title="通过Dom4j读取XML文件"></a>通过Dom4j读取XML文件</h2><p>*.步骤</p><p>1.读取???.xml文件（程序读的是books.xml）</p><p>通过SAXReader获取到Document对象</p><p><img src="/images/image-20211113142550286.png" alt="image-20211113142550286"></p><p>2.通过Document对象获取到XML文件里的根元素</p><p><img src="/images/image-20211113142556819.png" alt="image-20211113142556819"></p><p>这个rootElement通过打印显示的结果就是books，即</p><p><img src="/images/image-20211113142606549.png" alt="image-20211113142606549"></p><p>3.通过根元素对象获取XML文件中的标签对象</p><p><img src="/images/image-20211113142615869.png" alt="image-20211113142615869"></p><p>4.遍历，并把标签对象通过asXML转化为标签字符串</p><p><img src="/images/image-20211113142623609.png" alt="image-20211113142623609"></p><p>（可以一级一级地向下获取子标签对象）</p><p><img src="/images/image-20211113142712885.png" alt="image-20211113142712885"></p><p>就是再通过一次.element（“要获取的子标签名”）</p><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="Web资源的分类"><a href="#Web资源的分类" class="headerlink" title="Web资源的分类"></a>Web资源的分类</h2><p>1.静态资源：html ,css, js, txt, mp4, jpg 等</p><p>2.动态资源：jsp页面，Servlet程序 等</p><h2 id="关于Tomcat"><a href="#关于Tomcat" class="headerlink" title="关于Tomcat"></a>关于Tomcat</h2><p>在网页上敲<a href="http://localhost:8080实际上是访问到了Tomcat文件夹中的webapps目录下的ROOT。">http://localhost:8080实际上是访问到了Tomcat文件夹中的webapps目录下的ROOT。</a></p><p>但是如果加了<a href="http://localhost:8080/%E5%B7%A5%E7%A8%8B%E5%90%8D">http://localhost:8080/工程名</a> 等等其他的工程名时，就是以webapps为起始点，去访问webapps目录下这个工程的index.html</p><p>所以综上，如果只敲<a href="http://localhost:8080，相当于默认是访问http://localhost:8080/ROOT">http://localhost:8080，相当于默认是访问http://localhost:8080/ROOT</a></p><h2 id="Servlet技术"><a href="#Servlet技术" class="headerlink" title="Servlet技术"></a>Servlet技术</h2><p>*就是个规范，即接口。</p><p>*是三大组件之一：Servlet程序，Filter过滤器，Listener监听器</p><p>*是运行在服务器上的一个java程序，用来接收客户端的请求并响应数据</p><h3 id="实现Servlet程序（通常不用）"><a href="#实现Servlet程序（通常不用）" class="headerlink" title="实现Servlet程序（通常不用）"></a>实现Servlet程序（通常不用）</h3><p>1.编写类实现Servlet接口</p><p><img src="/images/image-20211113142720892.png" alt="image-20211113142720892"></p><p>2.实现service方法，处理请求并响应数据</p><p><img src="/images/image-20211113142741495.png" alt="image-20211113142741495"></p><p>3.在web.xml中配置servlet程序的访问地址</p><p><img src="/images/image-20211113142750684.png" alt="image-20211113142750684"></p><h3 id="定位servlet程序的方式"><a href="#定位servlet程序的方式" class="headerlink" title="定位servlet程序的方式"></a><strong>定位servlet程序的方式</strong></h3><p><img src="/images/image-20211113142802767.png" alt="image-20211113142802767"></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/images/image-20211113142811285.png" alt="image-20211113142811285"></p><p>初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，将ServletConfig作为参数来调用init()方法。</p><p>1.执行init初始化方法，仅执行一次，负责在装载Servlet时初始化Servlet对象。</p><p>2.执行service方法（每次访问都会调用）</p><p>3.执行destroy方法（web工程停止时才调用）</p><h3 id="请求的分发处理"><a href="#请求的分发处理" class="headerlink" title="请求的分发处理"></a>请求的分发处理</h3><p>service对于页面中的get请求和post请求要分开处理</p><p><img src="/images/image-20211113142819278.png" alt="image-20211113142819278"></p><p>可以使用getMethod方法对请求类型进行判断，然而servletRequest没有getMethod方法，需要将他转为其子类HttpServletRequest才能调用</p><p><img src="/images/image-20211113142826329.png" alt="image-20211113142826329"></p><p>为避免代码臃肿，通常会专门为get方法所处理的事建一个方法，Post一个方法</p><p><img src="/images/image-20211113142833913.png" alt="image-20211113142833913"></p><h3 id="通过继承HttpServlet实现servlet程序"><a href="#通过继承HttpServlet实现servlet程序" class="headerlink" title="通过继承HttpServlet实现servlet程序"></a>通过继承HttpServlet实现servlet程序</h3><p>*一般实际开发都是继承HttpServlet来实现Servelt程序</p><p>*步骤</p><p>1.继承HttpServlet</p><p>2.根据业务逻辑写doPost或doGet</p><p>3.在web.xml配置访问地址</p><p>*在HttpServlet底层的service()方法已经会对get请求或post请求进行判断，所以直接重写doPost或doGet方法，不需要人工对请求类型进行判断</p><h3 id="Servlet的继承体系"><a href="#Servlet的继承体系" class="headerlink" title="Servlet的继承体系"></a>Servlet的继承体系</h3><p><img src="/images/image-20211113142847130.png" alt="image-20211113142847130"></p><h2 id="ServletConfig类"><a href="#ServletConfig类" class="headerlink" title="ServletConfig类"></a>ServletConfig类</h2><p>是一个接口</p><p>*Servlet程序和ServletConfig对象都是由Tomcat创建的（初始化阶段）。Servlet程序默认是第一次访问时创建（生命周期有提过），ServletConfig对象是当Servlet程序创建时，就创建一个对象。</p><p>*<strong>即一个Servlet程序对应一个ServletConfig对象，Servlet A 的config对象获取不了Servlet B的配置信息</strong></p><p>*<strong>ServletConfig对象可以获取Servlet的初始化配置信息，这些信息理所应当的是存储在.xml文件中而被获取了出来</strong></p><h3 id="ServletConfig的三大作用"><a href="#ServletConfig的三大作用" class="headerlink" title="ServletConfig的三大作用"></a>ServletConfig的三大作用</h3><p>1.获取servlet程序的别名servlet-name的值</p><p>2.获取初始化参数init-param</p><p>3.获取ServletContext对象（虽然有直接的getServletContext()方法，但是其底层还是用的ServletConfig来获取Context对象）</p><p><img src="/images/image-20211113143430000.png" alt="image-20211113143430000"></p><h3 id="关于重写init类"><a href="#关于重写init类" class="headerlink" title="关于重写init类"></a>关于重写init类</h3><p><img src="/images/image-20211113142510855.png" alt="image-20211113142510855"></p><p>一定要写上super.init(config)</p><p>因为在父类中，init方法将config对象保存了起来这样才可以让子类中getServletConfig方法拿到ServletConfig对象。</p><p>如果子类把init重写了，那就相当于在调用时把父类的init方法覆盖了，如果不写super.init(config)，父类中就不会保存config对象，从而使子类的getServletConfig方法报空指针异常</p><h2 id="ServletContext类"><a href="#ServletContext类" class="headerlink" title="ServletContext类"></a>ServletContext类</h2><p>是一个接口</p><p>*是一个域对象</p><p>域对象：可以像Map一样存取数据的对象</p><p>这里的域指的是存取数据的操作范围，范围是整个web工程</p><p><img src="/images/image-20211113143243188.png" alt="image-20211113143243188"></p><p>*<strong>一个web工程只有一个ServletContext实例</strong></p><p>*<strong>ServletContext在web工程部署启动的时候就创建了，web停止时销毁</strong></p><p><strong>所以，在同一工程下，一个Servlet向ServletContext对象存入的键值对，可以由其他Servlet取到</strong>（类比一下，感觉有点像静态，web是一个类，各个Servlet是对象，而ServletContext就是里面的静态成员）</p><h3 id="四个作用"><a href="#四个作用" class="headerlink" title="四个作用"></a>四个作用</h3><p><img src="/images/image-20211113143518163.png" alt="image-20211113143518163"></p><p>*获取方式：通过ServletConfig对象获取（也可以直接getServletContext()  </p><p>但是其实底层都是（刚刚才提到了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getServletConfig().getServletContext()</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211113143646124.png" alt="image-20211113143646124"></p><p><img src="/images/image-20211113143655390.png" alt="image-20211113143655390"></p><p>关于最后一条的/，前面提过，/会被服务器解析为<a href="http://localhost:8080/%E5%B7%A5%E7%A8%8B%E5%90%8D/">http://localhost:8080/工程名/</a></p><p><img src="/images/image-20211113143703291.png" alt="image-20211113143703291"></p><p>工程的绝对路径实际上是映射到了IDEA中的webapp文件夹</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="请求HTTP"><a href="#请求HTTP" class="headerlink" title="请求HTTP"></a>请求HTTP</h3><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><p><img src="/images/image-20211113143730986.png" alt="image-20211113143730986"></p><p><img src="/images/image-20211113143803457.png" alt="image-20211113143803457"></p><h4 id="2-POST请求"><a href="#2-POST请求" class="headerlink" title="2.POST请求"></a>2.POST请求</h4><p><img src="/images/image-20211113143821496.png" alt="image-20211113143821496"></p><h4 id="总结以上两个请求的请求头"><a href="#总结以上两个请求的请求头" class="headerlink" title="总结以上两个请求的请求头"></a>总结以上两个请求的请求头</h4><p>常用请求头有</p><p>Accept：告诉服务器客户端可以接收的数据类型</p><p>Accept-Language：客户端可以接受的语言类型</p><p>User-Agent：浏览器的信息</p><p>Host：表示请求的服务器的ip和端口号</p><h4 id="区分GET-POST请求"><a href="#区分GET-POST请求" class="headerlink" title="区分GET,POST请求"></a>区分GET,POST请求</h4><p>*GET</p><p><img src="/images/image-20211113143848105.png" alt="image-20211113143848105"></p><p>*POST</p><p>form标签 method=”post”</p><h3 id="响应HTTP"><a href="#响应HTTP" class="headerlink" title="响应HTTP"></a>响应HTTP</h3><p><img src="/images/image-20211113143900071.png" alt="image-20211113143900071"></p><h4 id="常见响应码"><a href="#常见响应码" class="headerlink" title="常见响应码"></a>常见响应码</h4><p>200            请求成功</p><p>302            请求重定向</p><p>404            服务器已收到请求，但是数据不存在（或请求地址错误）</p><p>500            服务器已收到请求，但是服务器内部错误（代码错误）</p><h2 id="HttpServletRequest类"><a href="#HttpServletRequest类" class="headerlink" title="HttpServletRequest类"></a>HttpServletRequest类</h2><p>*只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好，封装到HttpServletRequest对象中。然后传递给service()方法</p><p><img src="/images/image-20211113143911607.png" alt="image-20211113143911607"></p><p>service方法就可以根据过来的请求的类型，把对象又给对应的doPost,doGet之类方法</p><p>*可以通过HttpServletRequest对象获取到所有请求信息</p><h3 id="类中常用方法"><a href="#类中常用方法" class="headerlink" title="类中常用方法"></a>类中常用方法</h3><p><img src="/images/image-20211113144003770.png" alt="image-20211113144003770"></p><p>在用post发送请求时，如果参数里有中文会有乱码</p><p>可以在doPost方法中使用（注意要在获取参数之前使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.setCharacterEncoding(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure><h3 id="请求的转发"><a href="#请求的转发" class="headerlink" title="请求的转发"></a>请求的转发</h3><p>服务器收到请求后从一个资源跳转到另一个资源的操作</p><p><img src="/images/image-20211113144029950.png" alt="image-20211113144029950"></p><p>*<strong>请求转发的地址必须要以/为开头，再次复习，/表示的地址为<a href="http://localhosr:8080/%E5%B7%A5%E7%A8%8B%E5%90%8D/%EF%BC%8C%E6%AD%A4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%88%B0IDEA%E4%BB%A3%E7%A0%81%E7%9A%84webapp%E7%9B%AE%E5%BD%95">http://localhosr:8080/工程名/，此地址映射到IDEA代码的webapp目录</a></strong></p><p>*<strong>对于一个Servlet程序，HttpServletRequest.getParameter()可以得到请求参数，而请求参数就是问号后的内容，可以自己写问号并添加键值对</strong></p><p><img src="/images/image-20211113144037847.png" alt="image-20211113144037847"></p><h4 id="请求转发的行为"><a href="#请求转发的行为" class="headerlink" title="请求转发的行为"></a>请求转发的行为</h4><p>1.<strong>获取参数（接收客户递交的材料）</strong></p><p><img src="/images/image-20211113144100509.png" alt="image-20211113144100509"></p><p>参数可以自己改，这个参数代表的就是请求键值对中的键，取到的Info就是键对应的值，如上例，括号里填username那么info得到的就是wzg168</p><p>2.<strong>处理完业务后，加盖一个章，也是一个键值对</strong></p><p><img src="/images/image-20211113144107929.png" alt="image-20211113144107929"></p><p><strong>3.获取下一步转发路径（问路）</strong></p><p><img src="/images/image-20211113144116498.png" alt="image-20211113144116498"></p><p>注意path要以/打头（但是实际测试下来发现可以把打头的/省略）</p><p><strong>4.转发（向柜台2走去）</strong></p><p><img src="/images/image-20211113144124618.png" alt="image-20211113144124618"></p><p><strong>5.接受（柜台二接受那张客户已在柜台一办好业务的材料）</strong></p><p><img src="/images/image-20211113144133242.png" alt="image-20211113144133242"></p><p><strong>6.可以获取转发方的“章”</strong></p><p><img src="/images/image-20211113144140953.png" alt="image-20211113144140953"></p><p><strong>7.办自己的业务</strong></p><h4 id="请求转发的特点"><a href="#请求转发的特点" class="headerlink" title="请求转发的特点"></a>请求转发的特点</h4><p>1.由servlet1转发到servlet2，<strong>浏览器地址栏是没有变化的</strong></p><p>2.虽然是访问了多个servlet资源，但是于客户端和服务器的宏观上来看，<strong>整个行为只是一个请求</strong></p><p>3.由2，所以请求的与数据都是一样的，<strong>他们共享request中的数据</strong></p><p>4.对于WEB-INF目录，虽然众所周知/被解析到<a href="http://localhosr:8080/%E5%B7%A5%E7%A8%8B%E5%90%8D/%EF%BC%8C%E4%B8%94%E8%BF%99%E4%B8%AA%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84%E5%88%B0%E4%BA%86IDEA%E7%9A%84webapp%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C**%E4%BD%86%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87%E5%9C%A8/%E5%90%8E%E5%8A%A0WEB-INF%E6%9D%A5%E8%AE%BF%E9%97%AE%E5%88%B0%E4%BB%96**%E3%80%82%E4%BD%86%E6%98%AF%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E6%9D%A5%E8%AE%BF%E9%97%AE%E5%88%B0%E4%BB%96%EF%BC%8C%E5%8D%B3%E5%9C%A8%E8%8E%B7%E5%8F%96%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%BD%AC%E5%8F%91%E8%B7%AF%E5%BE%84%EF%BC%88%E9%97%AE%E8%B7%AF%EF%BC%89%E7%9A%84%E6%AD%A5%E9%AA%A4%E4%B8%AD%E6%8A%8A%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E6%94%B9%E4%B8%BA&quot;/WEB-INF/%E6%83%B3%E8%A6%81%E8%AE%BF%E9%97%AE%E7%9A%84html%E7%AD%89%E6%96%87%E4%BB%B6&quot;%EF%BC%8C%E5%B0%B1%E8%83%BD%E5%9C%A8%E8%AE%BF%E9%97%AEservlet1%E5%AE%8C%E6%AF%95%E5%90%8E%E8%B7%B3%E8%BD%AC%E8%BF%87%E5%8E%BB">http://localhosr:8080/工程名/，且这个路径映射到了IDEA的webapp文件夹，**但是浏览器是无法直接通过在/后加WEB-INF来访问到他**。但是！！！！可以通过请求转发来访问到他，即在获取下一步转发路径（问路）的步骤中把括号中的内容改为&quot;/WEB-INF/想要访问的html等文件&quot;，就能在访问servlet1完毕后跳转过去</a></p><p>​    <strong>总结一下，是可以请求转发到WEB-INF目录下的，但是浏览器不能直接访问</strong></p><p>5.由于在问路步骤时填的参数都是要以/打头，意思就是他只能以<a href="http://localhost:8080/%E5%B7%A5%E7%A8%8B%E5%90%8D/%E4%BD%9C%E4%B8%BA%E5%85%B6%E5%AE%9E%E8%B7%AF%E5%BE%84">http://localhost:8080/工程名/作为其实路径</a></p><p>（实际测试发现，path中的打头的/其实可以省略，但是在运行过程中，会默认一个/作为开头，指向<a href="http://ipport/%E5%B7%A5%E7%A8%8B%E5%90%8D%EF%BC%89">http://ipport/工程名）</a></p><p>​    <strong>所以，通过请求转发时访问不到工程以外的资源的</strong></p><h2 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h2><p><strong>用于设置页面相对路径的参照地址</strong></p><p>怎么理解？</p><p>如果不用base，设置的相对路径就是以当前目录作为起始，去找寻。</p><p>但是如果用了base，在base标签里href值就作为了相对路径的起始地址。也就是把当前目录作为起始地址这个默认值给覆盖掉了</p><p><img src="/images/image-20211113144323458.png" alt="image-20211113144323458"></p><p>另外base标签中的资源名是可以省略的，因为资源名的存在对于路径而言本来就没什么意义。以图上的为例，c.html是可有可无的，因为他本来代表的是以b目录下为起始路径<strong>（但是b后的斜杠不能省略哈，如果把/省略了就相当于把b当作一个可有可无的资源了，就是以a目录下为起始地址了）</strong></p><h2 id="HttpServletResponse类"><a href="#HttpServletResponse类" class="headerlink" title="HttpServletResponse类"></a>HttpServletResponse类</h2><p>和HttpServletRequest一样，每次请求进到tomcat服务器，tomcat就会把信息封装到HttpServletResponse对象中，给Servlet程序去使用。</p><p>若要设置返回给客户端的信息，就可以通过HttpServletResponse对象来进行设置</p><h3 id="两个响应流"><a href="#两个响应流" class="headerlink" title="两个响应流"></a>两个响应流</h3><p><img src="/images/image-20211113144415380.png" alt="image-20211113144415380"></p><h3 id="向客户端回传数据"><a href="#向客户端回传数据" class="headerlink" title="向客户端回传数据"></a>向客户端回传数据</h3><p>*设置编码方式一</p><p><img src="/images/image-20211113144512409.png" alt="image-20211113144512409"></p><p>*方式二更加方便</p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20211109225512725.png" alt="image-20211109225512725"></p><p><img src="/images/image-20211113144518627.png" alt="image-20211113144518627"></p><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20211109225626670.png" alt="image-20211109225626670"></p><p><strong>重定向图解</strong></p><p><img src="/images/image-20211113144526510.png" alt="image-20211113144526510"></p><h4 id="重定向示例"><a href="#重定向示例" class="headerlink" title="重定向示例"></a><strong>重定向示例</strong></h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="*方式一"></a>*方式一</h5><p><img src="/images/image-20211113144539395.png" alt="image-20211113144539395"></p><p>结果</p><p><img src="/images/image-20211113144610131.png" alt="image-20211113144610131"></p><h5 id="方式二（推荐使用）"><a href="#方式二（推荐使用）" class="headerlink" title="*方式二（推荐使用）"></a>*方式二（推荐使用）</h5><p>由于发生重定向的情况本来就是响应码302所描述的情况，所以302状态码压根就不需要setStatus设置</p><p>一行代码sendRedirect()，告诉重定向的位置，就能搞定</p><p><img src="/images/image-20211113144616900.png" alt="image-20211113144616900"></p><h4 id="重定向特点"><a href="#重定向特点" class="headerlink" title="重定向特点"></a>重定向特点</h4><p><img src="/images/image-20211113144623582.png" alt="image-20211113144623582"></p><p><strong>怎么理解第3点？</strong></p><p>正如Request的性质，对于发给tomcat的每一次请求，他都会把信息封装到HttpServletRequest对象中。第一次请求的被重定向了，然后需要向Location中的地址发起第二次请求。<strong>两次请求是不一样的了，自然HttpServletRequest对象也就不是同一个对象了</strong>，所以并不共享数据。</p><p><strong>对比请求转发，怎么理解第5点？</strong></p><p>请求转发中填的路径path必须以/打头，就把路径定死了只能在<a href="http://localhosr:8080/%E5%B7%A5%E7%A8%8B%E5%90%8D/">http://localhosr:8080/工程名/</a> 的路径下再往深处访问。<strong>而重定向发回给客户端的Location地址并没有限制</strong>，所以可以访问工程外的资源例如百度网站等</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JavaWeb </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
