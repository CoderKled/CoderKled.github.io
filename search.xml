<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM学习笔记</title>
      <link href="/2021/11/10/JVM/"/>
      <url>/2021/11/10/JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h2 id="1-Class文件结构"><a href="#1-Class文件结构" class="headerlink" title="1.Class文件结构"></a>1.Class文件结构</h2><p>*只有两种数据类型：无符号数，表</p><p>*前四个字节（一个字节放两个十六进制位）是魔数，判定该class是否能被虚拟机接受，0xCAFEBABE</p><p>*紧接着四个字节的前两个是次版本号，后两个是主版本号</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>*从第九个字节开始是常量池，而第九个字节标记了常量池的大小。在class文件中，只有常量池的容量是从1开始计数，其余都是0开始。如第九个字节是0x16 -&gt; 22 -&gt; 即常量池有21项常量1~21</p><p>*每一项常量都是一个表</p><p><em>CONSTANT_Utf8_info型的常量的最大长度就是JAVA中方法或字段的最大长度。*<em>CONSTANT_Utf8_info中length是u2类型，所以如果JAVA程序中定义了超过65535，即64KB的字符变量或者方法名就无法编译</em></em></p><p>*查看字节码内容 javap -verbose</p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>*常量池结束后紧接着的2个字节代表访问标志，用于识别这个Class是接口？abstract？public？等等</p><h3 id="类索引，父类索引，接口索引集合"><a href="#类索引，父类索引，接口索引集合" class="headerlink" title="类索引，父类索引，接口索引集合"></a>类索引，父类索引，接口索引集合</h3><p>*因为JAVA中除了Object，都有父类，所以除了Object的JAVA类的父类索引都不为0</p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="1-类加载时机"><a href="#1-类加载时机" class="headerlink" title="1.类加载时机"></a>1.类加载时机</h2><p>1.加载，验证，准备，初始化，卸载的顺序是固定的，而解析则不一定</p><p>2.六种情况必须立即对类进行初始化：</p><p>​    （1）遇到new,getstatic,putstatic, invokestatic四条指令时，而会生成这四条指令的典型场景有</p><p>​        1.用new实例化对象时<strong>（静态加载）</strong></p><p>​        <strong>2.除被final修饰的静态字段被读取或设置</strong></p><p>​        3.调用静态方法<strong>（静态加载）</strong></p><p>​    （2）对类型进行反射调用时<strong>（动态加载）</strong></p><p>​    <strong>（3）初始化类时，如果他的父类还没初始化，必须先初始化他的父类（接口的这一点和类不同，接口在初始化时，并不要求他的父接口全部完成初始化，只有真的用到父接口时（如引用了父接口内定义的常量）时才会初始化）</strong>  <strong>（属于静态加载）</strong></p><p>​    （4）JVM启动时，用户需指定一个要执行的主类（包含Main的那个类），JVM会对其初始化</p><p>​    （5）对一个MethodHandle实例解析结果为REF_newInvokeSpecial, REF_getStatic, REF_putStatic,  REF_invokeStatic时</p><p>​    （6）默认方法（被default修饰的接口方法）的实现类发生初始化时，必须先初始化这个接口</p><p>3.P264 265 266的被动引用例子，要作为JAVA笔记中代码块调用顺序的补充</p><p>​    （1）通过子类直接引用父类的静态字段，不会触发子类的初始化</p><p>​    （2）通过数组定义来所引用的类，不会触发此类的初始化</p><p>​    （3）与上面第二点呼应。常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，不会触发初始化</p><h2 id="2-类的加载过程（验证-准备-解析属于连接过程）"><a href="#2-类的加载过程（验证-准备-解析属于连接过程）" class="headerlink" title="2.类的加载过程（验证+准备+解析属于连接过程）"></a>2.类的加载过程（验证+准备+解析属于连接过程）</h2><h3 id="2-1加载"><a href="#2-1加载" class="headerlink" title="2.1加载"></a>2.1加载</h3><p>1.完成三件事</p><p>（1）通过类名定义此类的二进制流</p><p>（2）将此字节流代表的的静态存储结构转化为方法区运行时数据结构</p><p>（3）在内存中生成代表此<strong>类的java.lang.Class对象</strong>作为方法区这个类的各种数据访问入口</p><p>2.加载尚未完成，链接可能就开始了。但是这俩的开始时间的先后顺序时固定的</p><h3 id="2-2验证"><a href="#2-2验证" class="headerlink" title="2.2验证"></a>2.2验证</h3><p><img src="E:/Blogg/blog/source/images/image-20211110213129342.png" alt="image-20211110213129342"></p><p>1.如果不通过验证就会抛出java.lang.VerifyError或其子类异常</p><p>验证内容</p><p>1.文件格式验证（CAFEBABE等）</p><p>2.元数据验证（这个类是否有父类（除Object都有父类），有没有继承不允许被继承的类等）</p><p>3.字节码验证（确保程序语义是否合法，符合逻辑）</p><p>4.符号引用验证（确保解析正常）</p><h3 id="2-3准备（针对静态）"><a href="#2-3准备（针对静态）" class="headerlink" title="2.3准备（针对静态）"></a>2.3准备（针对静态）</h3><p>1.为静态变量分配内存并设置默认初始值</p><p><strong>注意，如果一个静态变量被final修饰就不适用了，因为final在编译的时候就已经分配了，所以在此阶段会直接给这个常量编译时赋的值而不是默认值了</strong></p><h3 id="2-4解析"><a href="#2-4解析" class="headerlink" title="2.4解析"></a>2.4解析</h3><p>此阶段将符号引用转化为直接引用</p><h3 id="2-5初始化"><a href="#2-5初始化" class="headerlink" title="2.5初始化"></a>2.5初始化</h3><p><strong>（准备是赋默认值，初始化是赋程序员给的值如num=2，准备只会让num=0）静态代码块，就是在这个时候被调用的（还有静态变量的显式赋值）</strong></p><p>1.初始化阶段就是执行类构造器<client>()的过程,他<strong>只操作静态变量，方法</strong>。因为它是编译器自动收集类中所有对静态变量赋值动作和静态代码块中的语句合并来的</p><p>2.<code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</p><p>理解：</p><p><img src="E:/Blogg/blog/source/images/image-20211110213141384.png" alt="image-20211110213141384"></p><p>这段代码number=20那里初始化不会报错的原因就是因为在准备阶段，静态的number已经被赋值为0了，所以即便是先执行静态代码块中的内容，程序也知道number是已经被声明过的。所以在初始化阶段，会那顺序来初始化，就把Number=0覆盖掉，变成20，然后再覆盖，变成10。 为什么后面会报错呢？因为这种形式的代码只能赋值，不能调用（这叫非法前向调用）</p><p>3.<clinit>()与类的构造器不同。在虚拟机的视角下，类的构造器是<init>()。父类的clinit是优先于自己的</p><p>4.<strong>虚拟机在加载类时只会调用一次clinit()，然后就把它放在方法区</strong>。对于多线程，如果有很多个线程要初始化一个类，<strong>只会有一个线程去执行这个类的clinit() （即执行静态代码块等等），其他线程都会被阻塞在外面直到clinit进行完毕。</strong></p><h2 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3.类加载器"></a>3.类加载器</h2><p>1.Java的核心类库例如String类库都是由引导加载器加载的，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sout(String.class.getClassLoader())</span><br></pre></td></tr></table></figure><p>输出null值，因为BootStrapClassLoader对象是拿不到的</p><p>对于用户自定义类来说使用的是系统类加载器加载即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sout(A.class.getClassLoader())</span><br></pre></td></tr></table></figure><p>输出的是一个AppClassLoader的对象信息</p><h4 id="1-启动类加载器（引导类加载器BootStrapClassLoader）（C-C-写的）"><a href="#1-启动类加载器（引导类加载器BootStrapClassLoader）（C-C-写的）" class="headerlink" title="1.启动类加载器（引导类加载器BootStrapClassLoader）（C/C++写的）"></a>1.启动类加载器（引导类加载器BootStrapClassLoader）（C/C++写的）</h4><p>1.是JVM的一部分，用来加载JAVA的核心类库</p><p>2.没有父加载器<strong>（就他没继承ClassLoader）</strong></p><p>3.<strong>加载包名为java,javax,sun等开头的类</strong></p><h4 id="2-扩展类加载器"><a href="#2-扩展类加载器" class="headerlink" title="2.扩展类加载器"></a>2.扩展类加载器</h4><p>1.派生于ClassLoader</p><p>2**.加载jre/lib/ext中**的字节码文件，如果用户创建的JAR包放在了jre/lib/ext中，那么也会由扩展类加载器来加载</p><h4 id="3-系统类加载器AppClassLoader"><a href="#3-系统类加载器AppClassLoader" class="headerlink" title="3.系统类加载器AppClassLoader"></a>3.系统类加载器AppClassLoader</h4><p>1.是一个内部类</p><p>2.派生于ClassLoader</p><p>3.父类加载器是扩展类加载器</p><p><img src="E:/Blogg/blog/source/images/image-20211110213154403.png" alt="image-20211110213154403"></p><h4 id="4-用户自定义加载器"><a href="#4-用户自定义加载器" class="headerlink" title="4.用户自定义加载器"></a>4.用户自定义加载器</h4><p>后面会讲，使用情况</p><p>1.隔离加载类</p><p>2.修改类加载的方式</p><p>3.扩展加载源</p><p>4.防止源码泄露（因为JAVA可以反编译所以会泄露）</p><h4 id="5-关于ClassLoader（凡是ClassLoader下的都是JAVA写的）"><a href="#5-关于ClassLoader（凡是ClassLoader下的都是JAVA写的）" class="headerlink" title="5.关于ClassLoader（凡是ClassLoader下的都是JAVA写的）"></a>5.关于ClassLoader（凡是ClassLoader下的都是JAVA写的）</h4><p>1.是一个抽象类</p><p>2.除BootStraop都的类加载器都继承于他</p><p><img src="E:/Blogg/blog/source/images/image-20211110213208520.png" alt="image-20211110213208520"></p><h2 id="7-5双亲委派机制"><a href="#7-5双亲委派机制" class="headerlink" title="7.5双亲委派机制"></a>7.5双亲委派机制</h2><p>1.（跟类的加载比较像，自己是在父类加载完后才进行），如果一个类加载器收到了加载请求，不会自己先去加载而是向父类加载去委托，如果他的父类加载器还存在父类，就一直网上找到达顶层加载器。如果父类的那些加载器可以完成对该类的加载就成功返回，如果不行才会自己去加载<strong>（这就是为什么自己写一个java.lang.String类，然后在自己另一个类中去执行调用，调用不到的原因。因为首先被父类加载器判断是可以由父类加载的，就没自定义加载器什么事了）</strong>（如果顶层（bootstrap）发现这个类不该由我加载，就会给第二层（扩展类加载器）问他行不行，以此类推到子加载器（一般默认是系统加载器APPClassLoader，或者是用户自定义类加载器）发现由他管，就加载） <strong>（蛇形）</strong></p><p><img src="E:/Blogg/blog/source/images/image-20211110213225530.png" alt="image-20211110213225530"></p><h3 id="这就是沙箱安全机制"><a href="#这就是沙箱安全机制" class="headerlink" title="这就是沙箱安全机制"></a>这就是沙箱安全机制</h3><p><strong>一个好的例子（前面是在别的类中执行，现在这里是直接在自定义String类中运行）</strong></p><p><img src="E:/Blogg/blog/source/images/image-20211110213237932.png" alt="image-20211110213237932"></p><p>如果在自己定义的java.lang.String里加一个Main函数，会报错。因为此时就是想去执行对自己定义的String类的加载，由于是java开头的包，就会交由引导类加载器来加载。而引导类加载器要加载的核心类库是没有main方法的，所以报错<strong>（这里体现的就是沙箱安全机制）</strong></p><p>2.优势</p><p>避免重复加载</p><p>保护程序安全，防止核心API被篡改</p><h2 id="7-6其他"><a href="#7-6其他" class="headerlink" title="7.6其他"></a>7.6其他</h2><p>1.判断两个Class是不是同一个</p><p>类的完整名（包括包名要一致）</p><p><strong>加载这个Class的ClassLoader要相同（这个就与双亲委派呼应起来了）</strong></p><p>2.JVM必须只要加载一个类是由引导类（启动类）加载器加载的还是用户类加载器加载的。如果是用户类加载器加载的话，JVM就会将这个类加载器的引用作为类型的信息的一部分放在方法区中<strong>（这就是为什么去获取BootStrapClassLoader的时候返回的是null，而其他调用是能看到类型的）</strong></p><p>3.<img src="E:/Blogg/blog/source/images/image-20211110213252785.png" alt="image-20211110213252785"></p><h1 id="（网编）运行时数据区（3-12）（重点是虚拟机栈，堆，方法区）"><a href="#（网编）运行时数据区（3-12）（重点是虚拟机栈，堆，方法区）" class="headerlink" title="（网编）运行时数据区（3~12）（重点是虚拟机栈，堆，方法区）"></a>（网编）运行时数据区（3~12）（重点是虚拟机栈，堆，方法区）</h1><p><img src="E:/Blogg/blog/source/images/image-20211110213312004.png" alt="image-20211110213312004"></p><p>红色区域（两个一组）是一个进程，一个虚拟机对应一组（一个虚拟机就会对应一个进程），灰色区域（三个一组）是一个线程对应一组</p><p>假设一个进程有五个线程，那么就会有五组灰色区域，5个线程共用一组红色区域</p><h2 id="3-运行时数据区及线程"><a href="#3-运行时数据区及线程" class="headerlink" title="3.运行时数据区及线程"></a>3.运行时数据区及线程</h2><p><img src="E:/Blogg/blog/source/images/image-20211110213320069.png" alt="image-20211110213320069"></p><p>类比一下也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品。</p><p>每个JVM只有一个Runtime实例</p><p>*<strong>运行时数据区内部图</strong></p><p><img src="E:/Blogg/blog/source/images/image-20211110213330920.png" alt="image-20211110213330920"></p><h3 id="1-程序计数器（PC寄存器）"><a href="#1-程序计数器（PC寄存器）" class="headerlink" title="1.程序计数器（PC寄存器）"></a>1.程序计数器（PC寄存器）</h3><p>1.用于存储下一条指令的地址</p><p>2.每个线程都有自己的程序计数器，是线程私有的，生命周期与线程一致</p><p>3.任何时间，线程都只有一个方法在运行</p><p><img src="E:/Blogg/blog/source/images/image-20211110213338717.png" alt="image-20211110213338717"></p><h5 id="两个常见的面试问题"><a href="#两个常见的面试问题" class="headerlink" title="*两个常见的面试问题"></a>*两个常见的面试问题</h5><p>1.</p><p><img src="E:/Blogg/blog/source/images/image-20211110213347020.png" alt="image-20211110213347020"></p><p>2.</p><p><img src="E:/Blogg/blog/source/images/image-20211110213356273.png" alt="image-20211110213356273"></p><h2 id="5-虚拟机栈"><a href="#5-虚拟机栈" class="headerlink" title="5.虚拟机栈*"></a>5.虚拟机栈*</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>优点：跨平台，指令集小</p><p>缺点：性能低（不是指速度慢）</p><p>*对于栈来说没有垃圾回收问题，因为栈只有入栈和出栈两种操作。但是会存在异常的情况</p><p><strong>==============面试题======================</strong></p><p><strong>开发中遇到的异常有哪些？</strong></p><p>首先，在JAVA虚拟机中，java栈的大小可以是动态也可以是静态</p><p>1.如果采用静态的，那么每个线程的java虚拟机栈容量在线程创建的时候就定好了。如果线程请求分配的容量大于原本的容量，就会抛出StackOverFlowError</p><p>2.如果采用动态的，（1）在尝试扩展的时候无法申请到足够内存，（2）或在创建新线程时没有足够内存区创建对应的虚拟机栈，就会抛出OutOfMemoryError</p><p><strong>================================================</strong></p><p>*栈是运行时的单位，堆是存储的单位</p><p>*<strong>每个线程都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应着一次次的JAVA方法调用</strong>。虚拟机栈是线程私有的</p><p>虚拟机栈的作用：</p><p>管程序运行，它保存方法的局部变量（8种基本数据类型，对象的<strong>引用地址</strong>（对象本身在堆中）），部分结果，并参与方法的调用和返回</p><h3 id="2-栈帧（栈的存储单位）"><a href="#2-栈帧（栈的存储单位）" class="headerlink" title="2.栈帧（栈的存储单位）"></a>2.栈帧（栈的存储单位）</h3><p>1.每个线程都有自己的栈，里面的数据的基本单位是栈帧</p><p>2.每个方法对应一个栈帧</p><p>3.一个时间点上只会有一个活动的栈帧</p><p>4.不同线程中的栈帧是不能相互引用的（很好理解，因为每个线程本来就是相对独立的，他们只是可以共享他们所在的那个进程的资源）</p><p>5.Java中有两种返回方式（1）正常的return（void函数其实在结束的时候也会return）（2）抛出异常（指的是未捕获的异常，抛给调用自己的方法）。 两种方式都将导致当前栈帧弹出</p><h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><p><img src="E:/Blogg/blog/source/images/image-20211110213414446.png" alt="image-20211110213414446"></p><h4 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1.局部变量表*"></a>1.局部变量表*</h4><p>1.是一个数组，用于存储方法参数和在方法体内的局部变量（即各类基本数据类型，对象的引用，以及returnAddress类型）</p><p>2.由于是建立在线程的栈上，是线程的私有数据，所以不存在安全问题</p><p>3.所需要的容量大小在编译器就已经确定了，在运行期间不会更改</p><p><img src="E:/Blogg/blog/source/images/image-20211110213427454.png" alt="image-20211110213427454"></p><p><strong>注意一下成员变量和局部变量的区别</strong></p><p>*<strong>局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></p><h5 id="关于slot的理解"><a href="#关于slot的理解" class="headerlink" title="关于slot的理解"></a>关于slot的理解</h5><p>1.是局部变量表里最基本单元</p><p>2.用于存储基本数据类型，引用类型以及returnAddress类型</p><p><strong>3.32位数据占一个槽，64位的占两个（long，double）</strong></p><p>4.<strong>如果当前帧是由构造方法或者普通实例方法（即非静态的方法）创建的，那么对于这个对象的引用this就会放在index为0的slot处</strong>（每个方法或这个构造方法其实都隐含着this的）  <strong>（这也是为什么static方法中是不能用this的（因为this不存在于静态方法的局部变量表中））</strong></p><p><img src="E:/Blogg/blog/source/images/image-20211110213437024.png" alt="image-20211110213437024"></p><p>5.slot是可以重复利用的，当局部变量表里的变量被回收时（就比如</p><p><img src="E:/Blogg/blog/source/images/image-20211110213450472.png" alt="image-20211110213450472"></p><p>b会被回收，所以b的位子就被回收给c用了，所以这个局部变量表的长度是3而不是4</p><h4 id="2-操作数栈"><a href="#2-操作数栈" class="headerlink" title="2.操作数栈*"></a>2.操作数栈*</h4><p>1.主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</p><p>2.如果调用的方法有返回值，那么它结束后，返回值会被压入当前栈帧的<strong>操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令</p><p>=================<strong>操作过程</strong>==========================</p><p><img src="E:/Blogg/blog/source/images/image-20211110213504648.png" alt="image-20211110213504648"></p><p>要注意，局部变量表的0位置在图中没画出来，0位置就是这个类的this</p><p><img src="E:/Blogg/blog/source/images/image-20211110213521503.png" alt="image-20211110213521503"></p><p><img src="E:/Blogg/blog/source/images/image-20211110213531240.png" alt="image-20211110213531240"></p><p><img src="E:/Blogg/blog/source/images/image-20211110213547524.png" alt="image-20211110213547524"></p><p><img src="E:/Blogg/blog/source/images/image-20211110213559429.png" alt="image-20211110213559429"></p><p><strong>===================================================</strong></p><h4 id="3-帧数据区（一些附加信息，动态链接，方法返回地址）"><a href="#3-帧数据区（一些附加信息，动态链接，方法返回地址）" class="headerlink" title="3.帧数据区（一些附加信息，动态链接，方法返回地址）"></a>3.帧数据区（一些附加信息，动态链接，方法返回地址）</h4><h5 id="1-动态链接（指向运行时常量池的方法引用）"><a href="#1-动态链接（指向运行时常量池的方法引用）" class="headerlink" title="1.动态链接（指向运行时常量池的方法引用）"></a>1.动态链接（指向运行时常量池的方法引用）</h5><p>*在Java源文件被编译到字节码文件中后，所有变量和方法都会作为<strong>符号引用</strong>保存在class文件的常量池里</p><p>*描述一个方法（一个方法对应一个栈帧）调用另一个其他方法时，就是通过常量池中指向方法的符号引用来表示的。<strong>动态链接的作用就是把符号引用转化为直接引用</strong>（在类加载的解析阶段进行）（符转直其实就是看着符号标的位置去方法区找对应的方法）</p><p><img src="E:/Blogg/blog/source/images/image-20211110213611105.png" alt="image-20211110213611105"></p><p>//常量池中的符号引用</p><p><img src="E:/Blogg/blog/source/images/image-20211110213619626.png" alt="image-20211110213619626"></p><p>//代码中指向常量池的引用  ‘’#’’（也就是动态链接）</p><p><img src="E:/Blogg/blog/source/images/image-20211110213626901.png" alt="image-20211110213626901"></p><p>目前的结构图</p><p><img src="E:/Blogg/blog/source/images/image-20211110213635825.png" alt="image-20211110213635825"></p><h6 id="为什么需要常量池呢？"><a href="#为什么需要常量池呢？" class="headerlink" title="为什么需要常量池呢？"></a>为什么需要常量池呢？</h6><p>常量池提供一些符号和常量，便于指令识别。这样做也就不会让class文件因为装了太多方法和常量而变得很大，引用就好了。</p><h5 id="2-方法的调用"><a href="#2-方法的调用" class="headerlink" title="2.方法的调用**"></a>2.方法的调用**</h5><p>静态链接：当一个字节码文件被装载进JVM内部时，<strong>目标方法在编译期可知且运行期保持不变</strong>。这种情况的符号引用转直接引用叫静态链接</p><p>（早期绑定）</p><p>动态链接：<strong>被调方法在编译器无法被确定下来</strong>，只有在程序运行期才能将符号引用转化为直接引用，叫动态链接</p><p>（晚期绑定）</p><p>非虚方法：</p><p>编译器就确定了具体调用版本且在运行时不改变</p><p>静态，<strong>私有</strong>，final(用invokevirtue调但他不是虚方法)，实例构造器，<strong>父类方法</strong>都是非虚方法</p><p>其他的方法就都是虚的</p><p>非虚方法在编译时是非常确定会去哪里调哪个方法</p><p><img src="E:/Blogg/blog/source/images/image-20211110213646390.png" alt="image-20211110213646390"></p><p>lamda表达式就是用invokedynamic来调的，因为只有运行的时候才知道lamda表达式中的类型</p><p>JAVA是静态类型语言，Python是动态类型语言</p><p><img src="E:/Blogg/blog/source/images/image-20211110213655245.png" alt="image-20211110213655245"></p><p>静态和动态的区别在于，静态类型语言判断变量自身的类型信息，动态语言通过变量的值来判断类型（变量没有类型，而变量值有）</p><h6 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h6><p>*为了提高性能，不每次都在调用时向上找找找，于是JVM在方法区建立虚方法表（因为非虚方法都很确定在哪里调，所以不需要在这个表里）表中存放着各个方法的入口（就不需要向上向上找了）</p><p>*虚方法表何时创建？</p><p>在类加载链接阶段创建，当类准备阶段完成后，类的方法表也初始化完毕</p><p><strong>虚方法表示例</strong></p><p><img src="E:/Blogg/blog/source/images/image-20211110213705084.png" alt="image-20211110213705084"></p><h5 id="3-方法返回地址"><a href="#3-方法返回地址" class="headerlink" title="3.方法返回地址"></a>3.方法返回地址</h5><p>*存储该方法在pc寄存器（存储下一条要执行的指令的值）中的值</p><p>*无论目前的方法所调用的那个方法是正常退出还是出现未处理异常而非正常退出，都会返回到被调用的位置。</p><p><strong>方法的退出本质就是当前栈帧出栈的过程</strong></p><p>正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法指令的下一条指令的地址</strong></p><p>异常退出时，返回地址通过异常表确定，栈帧一般不会保存这部分信息</p><p><strong>这也是为什么异常退出不会给调用者返回任何值</strong></p><h5 id="4-一些附加信息"><a href="#4-一些附加信息" class="headerlink" title="4.一些附加信息"></a>4.一些附加信息</h5><p>栈帧允许携带与JVM实现相关的一些附加信息，不能保证每个栈帧都有</p><h3 id="3-虚拟机栈的相关面试题"><a href="#3-虚拟机栈的相关面试题" class="headerlink" title="3.虚拟机栈的相关面试题**"></a>3.虚拟机栈的相关面试题**</h3><p><strong>1.举例栈溢出的情况</strong></p><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM（OutOfMemoryError）</p><p>（可通过-Xss来设置栈的大小）</p><p><strong>2.调整栈大小，就能保证不出现溢出吗</strong></p><p>可以视情况做到，但是不能保证</p><p>死循环的话不管栈有多大都会溢出（栈小很快溢出，栈大慢点溢出罢了）</p><p><strong>3.分配的栈内存越大越好吗？</strong></p><p>理论上越大，能降低出现SOF的概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p><p><strong>4.垃圾回收是否会涉及到虚拟机栈</strong></p><p>不会</p><p><img src="E:/Blogg/blog/source/images/image-20211110213804815.png" alt="image-20211110213804815"></p><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20211027110358803.png" alt="image-20211027110358803"></p><p><strong>5.方法中定义的局部变量是否线程安全</strong></p><p><a href="https://youthlql.gitee.io/post/5b1b6560.html">https://youthlql.gitee.io/post/5b1b6560.html</a></p><h2 id="6-本地方法栈"><a href="#6-本地方法栈" class="headerlink" title="6.本地方法栈"></a>6.本地方法栈</h2><p><img src="E:/Blogg/blog/source/images/image-20211110213822495.png" alt="image-20211110213822495"></p><p>用来装native修饰的本地方法</p><p><img src="E:/Blogg/blog/source/images/image-20211110213831964.png" alt="image-20211110213831964"></p><h2 id="7-堆"><a href="#7-堆" class="headerlink" title="7.堆*"></a>7.堆*</h2><p>*每一个JVM实例（也就是每一个进程）都对应一个堆内存</p><p>*可处于物理上不连续的空间中，但是逻辑上是连续的</p><p>*<strong>线程共享堆，但不是绝对的共享。里面也可以划分线程线程私有的缓冲区</strong>TLAB</p><p>*所有的对象实例（几乎所有）（注意是实例，引用在虚拟机栈里）和数组，都在堆里</p><p>*</p><p><img src="E:/Blogg/blog/source/images/image-20211110213840140.png" alt="image-20211110213840140"></p><p>*设置堆空间大小（年轻代+老年代，不包括元空间）</p><p><img src="E:/Blogg/blog/source/images/image-20211110213852799.png" alt="image-20211110213852799"></p><p>ms: memory start</p><h1 id="没分章节的内容"><a href="#没分章节的内容" class="headerlink" title="*没分章节的内容"></a>*没分章节的内容</h1><h2 id="1-本地方法接口"><a href="#1-本地方法接口" class="headerlink" title="1.本地方法接口"></a>1.本地方法接口</h2><p><strong>为什么要用本地方法？</strong></p><p>1.C , C++盛行，需要交互</p><p>2.要与操作系统交互，因为操作系统是C/C++写的，所以需要本地方法</p><p>3.Sun的解释器是C实现的</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记，JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈反射</title>
      <link href="/2021/11/10/%E6%B5%85%E8%B0%88%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/11/10/%E6%B5%85%E8%B0%88%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h1><h2 id="1-动态语言-amp-静态语言"><a href="#1-动态语言-amp-静态语言" class="headerlink" title="1.动态语言&amp;静态语言"></a>1.动态语言&amp;静态语言</h2><p>从声明变量方式看动态与静态语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String author = <span class="string">&quot;CoderKled&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dream <span class="operator">=</span> <span class="string">&quot;Tencet&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distance = <span class="string">&quot;far&quot;</span></span><br></pre></td></tr></table></figure><p>可以看出动态语言与静态语言的区别之一在于：</p><p>静态语言判断变量自身的类型信息需要靠声明</p><p>动态语言的变量的类型信息则是根据其值来判断</p><p>Java不是动态语言，但是可以被称为是“准动态”，其原因在于Java具有一定的动态性，它是由反射机制等所赋予的。</p><h2 id="2-反射功能"><a href="#2-反射功能" class="headerlink" title="2.反射功能"></a>2.反射功能</h2><ul><li><strong>在运行时</strong>分析类的能力（如判断对象所属类，获取类的所有成员变量与方法信息等）</li><li>在运行时检查对象（例如，编写一个适用于所有类的toString方法）</li><li>实现泛型数组操作代码</li><li>利用Method对象</li><li>生成动态代理</li></ul><p>*反射可以在不通过修改源码的情况下控制程序</p><p>*在反射中，方法也是对象，可以用方法对象来调用方法</p><h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。就像一面镜子，透过它就能看到该对象所属类的信息。</p><p>Java运行时系统始终会为所有对象维护一个<strong>运行时类型标识</strong>，这个信息会跟踪每个对象所属的类。虚拟机利用运行时类型信息选择要执行的方法。</p><p>笔者理解为，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><p>a对象的编译类型是Animal，运行类型是Cat，该运行类型标识会一直伴随a对象的整个生命周期</p><h2 id="1-获取Class对象"><a href="#1-获取Class对象" class="headerlink" title="1.获取Class对象"></a>1.获取Class对象</h2><ul><li>方式一：getClass()  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Coder kled = <span class="keyword">new</span> Coder();</span><br><span class="line">Class c = kled.getClass();</span><br></pre></td></tr></table></figure><p>此处呼应前文所讲，系统维护的是一个运行时类型标识，所以getClass得到的是运行类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line">System.out.println(cat.getClass());</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211110210804735.png" alt="image-20211110210804735"></p><ul><li>方式二：静态方法forName()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;Coder&quot;</span>;</span><br><span class="line">Class c = Class.forName(name);</span><br></pre></td></tr></table></figure><ul><li>方式三：类型.class（可以是基本数据类型或void关键字）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = <span class="keyword">int</span>.class;</span><br><span class="line">Class c2 = String.class;</span><br><span class="line">Class c3 = Double[].class;</span><br></pre></td></tr></table></figure><ul><li>方式四：ClassLoader</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = ReflectionTest.class.getClassLoader();<span class="comment">//ReflectionTest是本类类名</span></span><br><span class="line">Class c = classLoader.loadClass(<span class="string">&quot;Coder&quot;</span>);</span><br></pre></td></tr></table></figure><p>由于虚拟机只为每个类型管理<strong>唯一一个</strong>Class对象，所以是可以用==来对两个Class进行对比的。</p><h2 id="2-突击复习instanceof"><a href="#2-突击复习instanceof" class="headerlink" title="2.突击复习instanceof"></a>2.突击复习instanceof</h2><p>判断对象是否是这个特定类或者是它的子类的一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(cat.getClass() == Cat.class);</span><br><span class="line">System.out.println(cat.getClass() == Animal.class);</span><br><span class="line">System.out.println(cat <span class="keyword">instanceof</span>  Animal);</span><br><span class="line">System.out.println(cat <span class="keyword">instanceof</span>  Cat);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211110210732793.png" alt="image-20211110210732793"></p><h2 id="3-getConstructor"><a href="#3-getConstructor" class="headerlink" title="3.getConstructor()"></a>3.getConstructor()</h2><p>若有一个Class类型的对象，可以通过getConstructor()来获取他的构造器对象，但是要根据以下代码注意区分</p><p><img src="/images/image-20211110212258605.png" alt="image-20211110212258605"></p><p><img src="/images/image-20211110212309805.png" alt="image-20211110212309805"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 反射 </tag>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
